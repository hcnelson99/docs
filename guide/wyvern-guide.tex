\documentclass{article}
% generated by Madoko, version 0.9.2-beta
%mdk-data-line={1}

\usepackage[heading-base=2]{madoko}
\usepackage{math-cmds}
\usepackage{proof}


\begin{document}
%mdk-data-line={11}
\newcommand{\trec}[2]{\mathbf{rec}~#1 . #2}
\newcommand{\trans}[1]{\ll #1 \gg}
\newcommand{\keyw}[1]{\textbf{#1}}\mdHxx[id=sec-why-wyvern,label={[1]\{.heading-label\}},toc={},data-line={16},caption={[[1]\{.heading-label\}.{\hspace{0.5em}}]\{.heading-before\}Why Wyvern?},bookmark={1.{\hspace{0.5em}}Why Wyvern?}]{%mdk-data-line={16}
{}\mdSpan[class={heading-before}]{\mdSpan[class={heading-label}]{1}.{\hspace{0.5em}}}%mdk-data-line={16}
{}Why Wyvern?}\begin{mdP}[data-line={19}]%
%mdk-data-line={19}
{}Wyvern is a new programming language exploring how to help software
engineers build software better at scale.  Our primary aim is to do
research that discovers and validates new principles for designing
engineering-focused programming languages.  Part of the %mdk-data-line={22}
{}{\textquotedblleft}validation{\textquotedblright}%mdk-data-line={22}
{}
bit is actually writing interesting programs in Wyvern, and so we
hope to also make it a great language to write code in%mdk-data-line={24}
{}{\textemdash}%mdk-data-line={24}
{}for us,
and for you!%
\end{mdP}%
\begin{mdP}[class={indent,para-continue},data-line={27}]%
%mdk-data-line={27}
{}Wyvern%mdk-data-line={27}
{}{'}%mdk-data-line={27}
{}s design incorporates a lot of great ideas from prior
languages: it is a statically-typed, garbage-collected general-purpose
applications programming language with excellent support for both
object-oriented and functional programming.  However, Wyvern is most
interesting because of the new ideas it explores.  Most of these are
best illustrated through the examples below, but here%mdk-data-line={32}
{}{'}%mdk-data-line={32}
{}s a brief
overview of Wyvern%mdk-data-line={33}
{}{'}%mdk-data-line={33}
{}s most interesting design features and what motivates
them.%
\end{mdP}%
\begin{mdUl}[class={ul,list-star,compact},elem={ul},data-line={36}]%
\begin{mdLi}[class={li,ul-li,list-star-li,compact-li},label={[(1)]\{.ul-li-label\}},elem={li},data-line={36}]%
\begin{mdP}[data-line={36}]%
%mdk-data-line={36}
{}Large programs must be composed from parts, so Wyvern has an
advanced module system with features echoing those of Standard
ML%mdk-data-line={38}
{}{'}%mdk-data-line={38}
{}s module system.  However, modern programs often load and
(re-)compose modules at run time, so Wyvern modules and functors
are first-class objects and functions, respectively, providing
programmers with the power and flexibility they need.%
\end{mdP}%%
\end{mdLi}%
\begin{mdLi}[class={li,ul-li,list-star-li,compact-li},label={[(2)]\{.ul-li-label\}},elem={li},data-line={43}]%
\begin{mdP}[data-line={43}]%
%mdk-data-line={43}
{}No one language can be good at everything, so Wyvern is extensible:
libraries can define new syntax for the abstractions that they
provide, and that syntax can be embedded seamlessly in Wyvern
expressions.%
\end{mdP}%%
\end{mdLi}%
\begin{mdLi}[class={li,ul-li,list-star-li,compact-li},label={[(3)]\{.ul-li-label\}},elem={li},data-line={48}]%
\begin{mdP}[data-line={48}]%
%mdk-data-line={48}
{}Engineers need to control the access that untrusted code has to
resources such as the network or file system, and so Wyvern%mdk-data-line={49}
{}{'}%mdk-data-line={49}
{}s module
system is the first to be designed from the ground up to be
capability-safe.  We are designing an effect system that leverages
these capabilities to provide lightweight and automatically-checked
control of resources.%
\end{mdP}%%
\end{mdLi}%
\begin{mdLi}[class={li,ul-li,list-star-li,compact-li},label={[(4)]\{.ul-li-label\}},elem={li},data-line={55}]%
\begin{mdP}[data-line={55}]%
%mdk-data-line={55}
{}More broadly, understanding and controlling the software architecture
of a program is critical to understanding its properties and evolving
it over time.  Thus we are building a way of expressing software
architecture as an integrated part of Wyvern programs, including a
static view building on the module system and a dynamic view showing
run-time components and the connections between them.  Wyvern
architectures are %mdk-data-line={61}
{}{\textquotedblleft}live{\textquotedblright}%mdk-data-line={61}
{} in that changing the architecture specification
affects the program semantics, and they are %mdk-data-line={62}
{}{\textquotedblleft}trusted{\textquotedblright}%mdk-data-line={62}
{} in that they are
guaranteed to be an accurate abstraction of what the program does.%
\end{mdP}%
\mdHxx[id=sec-hello-world-in-wyvern,label={[2]\{.heading-label\}},toc={},data-line={66},caption={[[2]\{.heading-label\}.{\hspace{0.5em}}]\{.heading-before\}Hello, World! in Wyvern},bookmark={2.{\hspace{0.5em}}Hello, World! in Wyvern}]{%mdk-data-line={66}
{}\mdSpan[class={heading-before}]{\mdSpan[class={heading-label}]{2}.{\hspace{0.5em}}}%mdk-data-line={66}
{}Hello, World! in Wyvern}%
\end{mdLi}%%
\end{mdUl}%
\begin{mdP}[data-line={69}]%
%mdk-data-line={69}
{}Here is a %mdk-data-line={69}
{}{\textquotedblleft}Hello, World!{\textquotedblright}%mdk-data-line={69}
{} program in Wyvern (%mdk-data-line={69}
{}\mdCode[class={code,code1}]{examples/rosetta/hello.wyv}%mdk-data-line={69}
{}):%
\end{mdP}%
\begin{mdPre}[class={para-block,pre-indented},data-line={71}]%
\mdPrecode{require\prespace{1}stdout\prebr{}
\prebr{}
stdout.print({"}Hello,\prespace{1}World!{"})}%
\end{mdPre}%
\begin{mdP}[data-line={75}]%
%mdk-data-line={75}
{}This program already illustrates a couple of basic aspects of Wyvern.  First,
Wyvern is object-oriented: %mdk-data-line={76}
{}\mdCode[class={code,code1}]{stdout}%mdk-data-line={76}
{} is an object, and we are invoking the
%mdk-data-line={77}
{}\mdCode[class={code,code1}]{print}%mdk-data-line={77}
{} method on it.  For expressions, much of Wyvern%mdk-data-line={77}
{}{'}%mdk-data-line={77}
{}s syntax is similar
to Java%mdk-data-line={78}
{}{'}%mdk-data-line={78}
{}s.%
\end{mdP}%
\begin{mdP}[class={indent},data-line={80}]%
%mdk-data-line={80}
{}Second, system resources such as the standard output object, %mdk-data-line={80}
{}\mdCode[class={code,code1}]{stdout}%mdk-data-line={80}
{},
are not ambiently available to programs, but must be explicitly required
from the operating system.  A primary goal of Wyvern%mdk-data-line={82}
{}{'}%mdk-data-line={82}
{}s module system
is helping developers to reason about the use of resources.  Thus even
a simple script such as Hello World must declare the resources it
requires in order to execute.  This allows engineers to determine at a
glance what kind of I/O a program might do, and provides a basis for
making a decision about whether to run this program in a particular
situation.  In this case, even without looking at the actual code, we
know that this program may write to the standard output stream, but will
not access the file system or access the network.%
\end{mdP}%
\mdHxx[id=sec-anonymous-functions,label={[3]\{.heading-label\}},toc={},data-line={93},caption={[[3]\{.heading-label\}.{\hspace{0.5em}}]\{.heading-before\}Anonymous Functions},bookmark={3.{\hspace{0.5em}}Anonymous Functions}]{%mdk-data-line={93}
{}\mdSpan[class={heading-before}]{\mdSpan[class={heading-label}]{3}.{\hspace{0.5em}}}%mdk-data-line={93}
{}Anonymous Functions}\begin{mdP}[data-line={96}]%
%mdk-data-line={96}
{}Wyvern has good support for functional programming, and anonymous functions can be defined in Wyvern using the syntax:%
\end{mdP}%
\begin{mdPre}[class={para-block,pre-indented},data-line={98}]%
\mdPrecode{(x:Int)\prespace{1}={\textgreater}\prespace{1}x\prespace{1}+\prespace{1}1}%
\end{mdPre}%
\begin{mdP}[data-line={100}]%
%mdk-data-line={100}
{}We can bind the expresison above to a variable and invoke it:%
\end{mdP}%
\begin{mdPre}[class={para-block,pre-indented},data-line={102}]%
\mdPrecode{val\prespace{1}addOne\prespace{1}=\prespace{1}(x:Int)\prespace{1}={\textgreater}\prespace{1}x\prespace{1}+\prespace{1}1\prebr{}
addOne(1)\prebr{}
}%
\end{mdPre}%
\begin{mdP}[data-line={105}]%
%mdk-data-line={105}
{}and the result will be 2.%
\end{mdP}%
\begin{mdP}[class={indent},data-line={107}]%
%mdk-data-line={107}
{}Anonymous functions can also have multiple parameters:%
\end{mdP}%
\begin{mdPre}[class={para-block,pre-indented},data-line={109}]%
\mdPrecode{(x:Int,y:Int)\prespace{1}={\textgreater}\prespace{1}x\prespace{1}+\prespace{1}y\prebr{}
}%
\end{mdPre}%
\begin{mdP}[data-line={111}]%
%mdk-data-line={111}
{}or no parameters:%
\end{mdP}%
\begin{mdPre}[class={para-block,pre-indented},data-line={113}]%
\mdPrecode{()\prespace{1}={\textgreater}\prespace{1}7}%
\end{mdPre}%
\begin{mdP}[data-line={115}]%
%mdk-data-line={115}
{}Function types can be denoted with an arrow, and we can annotate
a variable with this type.  If we annotate the type of the variable
we are binding to the function, we can leave out the type annotation
(and even the parentheses) on the function%mdk-data-line={118}
{}{'}%mdk-data-line={118}
{}s argument:%
\end{mdP}%
\begin{mdPre}[class={para-block,pre-indented},data-line={120}]%
\mdPrecode{val\prespace{1}annotatedAddOne\prespace{1}:\prespace{1}Int\prespace{1}-{\textgreater}\prespace{1}Int\prespace{1}=\prespace{1}x\prespace{1}={\textgreater}\prespace{1}x\prespace{1}+\prespace{1}1\prebr{}
}%
\end{mdPre}%
\begin{mdP}[data-line={122}]%
%mdk-data-line={122}
{}This also works if we pass an anonymous function to a higher-order
function:%
\end{mdP}%
\begin{mdPre}[class={para-block,pre-indented},data-line={125}]%
\mdPrecode{val\prespace{1}invokeIt\prespace{1}=\prespace{1}(f:Int\prespace{1}-{\textgreater}\prespace{1}Int,\prespace{1}x:Int)\prespace{1}={\textgreater}\prespace{1}f(x)\prebr{}
invokeIt(x\prespace{1}={\textgreater}\prespace{1}x+1,\prespace{1}5)}%
\end{mdPre}%
\begin{mdP}[data-line={128}]%
%mdk-data-line={128}
{}The code above can be found in %mdk-data-line={128}
{}\mdCode[class={code,code1}]{examples/introductory/functions.wyv}%mdk-data-line={128}
{}%
\end{mdP}%
\mdHxx[id=sec-functions-in-wyvern,label={[4]\{.heading-label\}},toc={},data-line={131},caption={[[4]\{.heading-label\}.{\hspace{0.5em}}]\{.heading-before\}Functions in Wyvern},bookmark={4.{\hspace{0.5em}}Functions in Wyvern}]{%mdk-data-line={131}
{}\mdSpan[class={heading-before}]{\mdSpan[class={heading-label}]{4}.{\hspace{0.5em}}}%mdk-data-line={131}
{}Functions in Wyvern}\begin{mdP}[data-line={134}]%
%mdk-data-line={134}
{}Consider the definition of the %mdk-data-line={134}
{}\mdCode[class={code,code1}]{factorial}%mdk-data-line={134}
{} function in Wyvern (%mdk-data-line={134}
{}\mdCode[class={code,code1}]{examples/rosetta/factorial.wyv}%mdk-data-line={134}
{}):%
\end{mdP}%
\begin{mdPre}[class={para-block,pre-indented},data-line={136}]%
\mdPrecode{import\prespace{1}stdout\prebr{}
\prebr{}
def\prespace{1}factorial(n:Int):Int\prebr{}
\preindent{4}(n\prespace{1}{\textless}\prespace{1}2).ifTrue(\prebr{}
\preindent{8}()\prespace{1}={\textgreater}\prespace{1}1,\prebr{}
\preindent{8}()\prespace{1}={\textgreater}\prespace{1}n\prespace{1}*\prespace{1}factorial(n-1)\prebr{}
\preindent{4})\prebr{}
\prebr{}
stdout.print({"}factorial(15)\prespace{1}=\prespace{1}{"})\prebr{}
stdout.printInt(factorial(15))}%
\end{mdPre}%
\begin{mdP}[data-line={147}]%
%mdk-data-line={147}
{}A function is defined with the %mdk-data-line={147}
{}\mdCode[class={code,code1}]{def}%mdk-data-line={147}
{} keyword, and its argument and
return types are given in Algol-like syntax.  Functions defined with
%mdk-data-line={149}
{}\mdCode[class={code,code1}]{def}%mdk-data-line={149}
{} are recursive, so we can call %mdk-data-line={149}
{}\mdCode[class={code,code1}]{factorial}%mdk-data-line={149}
{} in the body.  The
example illustrates how an integer comparison %mdk-data-line={150}
{}\mdCode[class={code,code1}]{n-2}%mdk-data-line={150}
{} is a boolean object,
on which we can invoke the %mdk-data-line={151}
{}\mdCode[class={code,code1}]{ifTrue}%mdk-data-line={151}
{} method.  This method takes two
functions, one of which is evaluated in the true case and one of which
is evaluated in the false case.%
\end{mdP}%
\begin{mdP}[class={indent},data-line={155}]%
%mdk-data-line={155}
{}Note that %mdk-data-line={155}
{}\mdCode[class={code,code1}]{factorial(15)}%mdk-data-line={155}
{} would overflow in languages such
as Java in which the default integer types is represented using only
32 bits.  In Wyvern, %mdk-data-line={157}
{}\mdCode[class={code,code1}]{Int}%mdk-data-line={157}
{} means an arbitrary precision integer.%
\end{mdP}%
\begin{mdP}[class={indent},data-line={159}]%
%mdk-data-line={159}
{}Wyvern provides a nicer way to write the %mdk-data-line={159}
{}\mdCode[class={code,code1}]{if}%mdk-data-line={159}
{} statement above, if we
are willing to import a library that includes a type-specific language
for then-else clauses:%
\end{mdP}%
\begin{mdPre}[class={para-block,pre-indented},data-line={163}]%
\mdPrecode{import\prespace{1}metadata\prespace{1}wyvern.IfTSL\prebr{}
val\prespace{1}iff\prespace{1}=\prespace{1}(x:Boolean,\prespace{1}y:IfTSL.IfExprR)\prespace{1}={\textgreater}\prespace{1}IfTSL.doifR(x,\prespace{1}y)\prebr{}
\prebr{}
def\prespace{1}fact(n:Int):Int\prebr{}
\preindent{4}iff\prespace{1}(n\prespace{1}{\textless}\prespace{1}2,\prespace{1}{\textasciitilde})\prebr{}
\preindent{8}then\prebr{}
\preindent{12}1\prebr{}
\preindent{8}else\prebr{}
\preindent{12}n\prespace{1}*\prespace{1}fact(n-1)}%
\end{mdPre}%
\begin{mdP}[data-line={173}]%
%mdk-data-line={173}
{}The import statement loads the %mdk-data-line={173}
{}\mdCode[class={code,code1}]{IfTSL}%mdk-data-line={173}
{} module from the %mdk-data-line={173}
{}\mdCode[class={code,code1}]{wyvern}%mdk-data-line={173}
{} package.
The %mdk-data-line={174}
{}\mdCode[class={code,code1}]{metadata}%mdk-data-line={174}
{} keyword indicates that the library defines new syntax,
in this case for %mdk-data-line={175}
{}\mdCode[class={code,code1}]{then}%mdk-data-line={175}
{} and %mdk-data-line={175}
{}\mdCode[class={code,code1}]{else}%mdk-data-line={175}
{} clauses.  We define an %mdk-data-line={175}
{}\mdCode[class={code,code1}]{iff}%mdk-data-line={175}
{} shorthand
for calling the %mdk-data-line={176}
{}\mdCode[class={code,code1}]{doifR}%mdk-data-line={176}
{} function from that library.  Then we can just use
%mdk-data-line={177}
{}\mdCode[class={code,code1}]{then}%mdk-data-line={177}
{} and %mdk-data-line={177}
{}\mdCode[class={code,code1}]{else}%mdk-data-line={177}
{} keywords and indent blocks of code below each one.  Note
that because of the way type-specific languages (TSLs) work in Wyvern, it%mdk-data-line={178}
{}{'}%mdk-data-line={178}
{}s
not possible to put %mdk-data-line={179}
{}\mdCode[class={code,code1}]{then}%mdk-data-line={179}
{} and %mdk-data-line={179}
{}\mdCode[class={code,code1}]{else}%mdk-data-line={179}
{} on a single line.%
\end{mdP}%
\begin{mdP}[class={indent},data-line={181}]%
%mdk-data-line={181}
{}We hope to make this even a bit cleaner in the future.
              %mdk-data-line={182}
{} %mdk-data-line={182}
{}%
\end{mdP}%
\mdHxx[id=sec-objects-and-object-types-in-wyvern,label={[5]\{.heading-label\}},toc={},data-line={184},caption={[[5]\{.heading-label\}.{\hspace{0.5em}}]\{.heading-before\}Objects and Object Types in Wyvern},bookmark={5.{\hspace{0.5em}}Objects and Object Types in Wyvern}]{%mdk-data-line={184}
{}\mdSpan[class={heading-before}]{\mdSpan[class={heading-label}]{5}.{\hspace{0.5em}}}%mdk-data-line={184}
{}Objects and Object Types in Wyvern}\begin{mdP}[data-line={187}]%
%mdk-data-line={187}
{}We can define a sumable integer list type as follows (%mdk-data-line={187}
{}\mdCode[class={code,code1}]{examples/introductory/objects.wyv}%mdk-data-line={187}
{}):%
\end{mdP}%
\begin{mdPre}[class={para-block,pre-indented},data-line={189}]%
\mdPrecode{type\prespace{1}IntList\prebr{}
\preindent{4}def\prespace{1}sum():Int}%
\end{mdPre}%
\begin{mdP}[data-line={192}]%
%mdk-data-line={192}
{}The %mdk-data-line={192}
{}\mdCode[class={code,code1}]{type}%mdk-data-line={192}
{} keyword declares a new object type, called %mdk-data-line={192}
{}\mdCode[class={code,code1}]{IntList}%mdk-data-line={192}
{} in
this case.  The public methods available in the type are listed below,
but no method bodies may be given as we are defining a type, not an
implementation.%
\end{mdP}%
\begin{mdP}[class={indent},data-line={197}]%
%mdk-data-line={197}
{}We can implement a constant representing the empty list and a
constructor for creating a larger list out of a smaller one as
follows:%
\end{mdP}%
\begin{mdPre}[class={para-block,pre-indented},data-line={201}]%
\mdPrecode{val\prespace{1}empty:IntList\prespace{1}=\prespace{1}new\prebr{}
\preindent{4}def\prespace{1}sum():Int\prespace{1}=\prespace{1}0\prebr{}
\prebr{}
def\prespace{1}cons(elem:Int,rest:IntList):IntList\prespace{1}=\prespace{1}new\prebr{}
\preindent{4}def\prespace{1}sum():Int\prespace{1}=\prespace{1}elem\prespace{1}+\prespace{1}rest.sum()\prebr{}
\preindent{4}\prebr{}
cons(3,cons(4,empty)).sum()\prespace{1}//\prespace{1}evalutes\prespace{1}to\prespace{1}7}%
\end{mdPre}%
\begin{mdP}[data-line={209}]%
%mdk-data-line={209}
{}The %mdk-data-line={209}
{}\mdCode[class={code,code1}]{new}%mdk-data-line={209}
{} expression creates an object with the methods given.  In
the example above, we just have one method, %mdk-data-line={210}
{}\mdCode[class={code,code1}]{sum()}%mdk-data-line={210}
{}, which evaluates
to %mdk-data-line={211}
{}\mdCode[class={code,code1}]{0}%mdk-data-line={211}
{} in the case of the %mdk-data-line={211}
{}\mdCode[class={code,code1}]{empty}%mdk-data-line={211}
{} list and sums up the integers in
the list otherwise.%
\end{mdP}%
\mdHxx[id=sec-anonymous-functions-as-objects,label={[6]\{.heading-label\}},toc={},data-line={215},caption={[[6]\{.heading-label\}.{\hspace{0.5em}}]\{.heading-before\}Anonymous Functions as Objects},bookmark={6.{\hspace{0.5em}}Anonymous Functions as Objects}]{%mdk-data-line={215}
{}\mdSpan[class={heading-before}]{\mdSpan[class={heading-label}]{6}.{\hspace{0.5em}}}%mdk-data-line={215}
{}Anonymous Functions as Objects}\begin{mdPre}[class={para-block,pre-indented},data-line={218}]%
\mdPrecode{}%
\end{mdPre}%
\begin{mdP}[data-line={218}]%
%mdk-data-line={218}
{}The anonymous function syntax described above is actually
a shorthand for creating an object with an %mdk-data-line={219}
{}\mdCode[class={code,code1}]{apply}%mdk-data-line={219}
{} method
that has the same arguments and body:%
\end{mdP}%
\begin{mdPre}[class={para-block,pre-indented},data-line={222}]%
\mdPrecode{new\prebr{}
\preindent{4}def\prespace{1}apply(x:Int):Int\prespace{1}=\prespace{1}x\prespace{1}+\prespace{1}1}%
\end{mdPre}%
\begin{mdP}[data-line={225}]%
%mdk-data-line={225}
{}which is an instance of the following type:%
\end{mdP}%
\begin{mdPre}[class={para-block,pre-indented},data-line={227}]%
\mdPrecode{type\prespace{1}IntToIntFn\prebr{}
\preindent{4}def\prespace{1}apply(x:Int):Int}%
\end{mdPre}%
\begin{mdP}[data-line={230}]%
%mdk-data-line={230}
{}As mentioned earlier, the type above can be abbreviated %mdk-data-line={230}
{}\mdCode[class={code,code1}]{Int\prespace{1}-{\textgreater}\prespace{1}Int}%mdk-data-line={230}
{},
as in many other languages with good support for functional programming.%
\end{mdP}%
\mdHxx[id=sec-mutable-state-and-resource-types,label={[7]\{.heading-label\}},toc={},data-line={234},caption={[[7]\{.heading-label\}.{\hspace{0.5em}}]\{.heading-before\}Mutable State and Resource Types},bookmark={7.{\hspace{0.5em}}Mutable State and Resource Types}]{%mdk-data-line={234}
{}\mdSpan[class={heading-before}]{\mdSpan[class={heading-label}]{7}.{\hspace{0.5em}}}%mdk-data-line={234}
{}Mutable State and Resource Types}\begin{mdP}[data-line={237}]%
%mdk-data-line={237}
{}Types with mutable state can be defined, but need to be marked as
%mdk-data-line={238}
{}\mdCode[class={code,code1}]{resource}%mdk-data-line={238}
{} types (%mdk-data-line={238}
{}\mdCode[class={code,code1}]{examples/introductory/cell.wyv}%mdk-data-line={238}
{}):%
\end{mdP}%
\begin{mdPre}[class={para-block,pre-indented},data-line={240}]%
\mdPrecode{resource\prespace{1}type\prespace{1}Cell\prebr{}
\preindent{4}def\prespace{1}set(newValue:Int):Unit\prebr{}
\preindent{4}def\prespace{1}get():Int\prebr{}
\prebr{}
def\prespace{1}makeCell(initVal:Int):Cell\prespace{1}=\prespace{1}new\prebr{}
\preindent{4}var\prespace{1}value\prespace{1}:\prespace{1}Int\prespace{1}=\prespace{1}initVal\prebr{}
\preindent{4}def\prespace{1}set(newValue:Int):Unit\prebr{}
\preindent{8}this.value\prespace{1}=\prespace{1}newValue\prebr{}
\preindent{4}def\prespace{1}get():Int\prespace{1}=\prespace{1}this.value\prebr{}
\prebr{}
val\prespace{1}c\prespace{1}=\prespace{1}makeCell(5)\prebr{}
c.get()\prespace{1}//\prespace{1}evalutes\prespace{1}to\prespace{1}5\prebr{}
c.set(3)\prebr{}
c.get()\prespace{1}//\prespace{1}evalutes\prespace{1}to\prespace{1}3}%
\end{mdPre}%
\begin{mdP}[data-line={255}]%
%mdk-data-line={255}
{}Here %mdk-data-line={255}
{}\mdCode[class={code,code1}]{makeCell}%mdk-data-line={255}
{} uses a %mdk-data-line={255}
{}\mdCode[class={code,code1}]{new}%mdk-data-line={255}
{} statement to create an object with a %mdk-data-line={255}
{}\mdCode[class={code,code1}]{var}%mdk-data-line={255}
{}
field %mdk-data-line={256}
{}\mdCode[class={code,code1}]{value}%mdk-data-line={256}
{}.  %mdk-data-line={256}
{}\mdCode[class={code,code1}]{var}%mdk-data-line={256}
{} fields are assignable, so the %mdk-data-line={256}
{}\mdCode[class={code,code1}]{set}%mdk-data-line={256}
{} funtion is
implemented to assign the %mdk-data-line={257}
{}\mdCode[class={code,code1}]{value}%mdk-data-line={257}
{} field of the receiver object %mdk-data-line={257}
{}\mdCode[class={code,code1}]{this}%mdk-data-line={257}
{} to
the passed-in argument.  Note that we must initialize a %mdk-data-line={258}
{}\mdCode[class={code,code1}]{var}%mdk-data-line={258}
{} field with
an initial value.  If we had not declared %mdk-data-line={259}
{}\mdCode[class={code,code1}]{Cell}%mdk-data-line={259}
{} to be a %mdk-data-line={259}
{}\mdCode[class={code,code1}]{resource}%mdk-data-line={259}
{}
type, we would get an error because the %mdk-data-line={260}
{}\mdCode[class={code,code1}]{new}%mdk-data-line={260}
{} expression creates a
stateful object that is a resource.%
\end{mdP}%
\begin{mdP}[class={indent},data-line={263}]%
%mdk-data-line={263}
{}In the example above, %mdk-data-line={263}
{}\mdCode[class={code,code1}]{Unit}%mdk-data-line={263}
{} is used as the return type of functions
that do not return any interesting value.%
\end{mdP}%
\mdHxx[id=sec-modules,label={[8]\{.heading-label\}},toc={},data-line={267},caption={[[8]\{.heading-label\}.{\hspace{0.5em}}]\{.heading-before\}Modules},bookmark={8.{\hspace{0.5em}}Modules}]{%mdk-data-line={267}
{}\mdSpan[class={heading-before}]{\mdSpan[class={heading-label}]{8}.{\hspace{0.5em}}}%mdk-data-line={267}
{}Modules}\begin{mdP}[data-line={270}]%
%mdk-data-line={270}
{}We can define the %mdk-data-line={270}
{}\mdCode[class={code,code1}]{Cell}%mdk-data-line={270}
{} abstraction above in a module (%mdk-data-line={270}
{}\mdCode[class={code,code1}]{examples/modules/cell.wyv}%mdk-data-line={270}
{}):%
\end{mdP}%
\begin{mdPre}[class={para-block,pre-indented},data-line={272}]%
\mdPrecode{module\prespace{1}cell\prebr{}
\prebr{}
resource\prespace{1}type\prespace{1}Cell\prebr{}
\preindent{4}def\prespace{1}set(newValue:Int):Unit\prebr{}
\preindent{4}def\prespace{1}get():Int\prebr{}
\prebr{}
def\prespace{1}make(initVal:Int):Cell\prespace{1}=\prespace{1}new\prebr{}
\preindent{4}var\prespace{1}value\prespace{1}:\prespace{1}Int\prespace{1}=\prespace{1}initVal\prebr{}
\preindent{4}def\prespace{1}set(newValue:Int):Unit\prebr{}
\preindent{8}this.value\prespace{1}=\prespace{1}newValue\prebr{}
\preindent{4}def\prespace{1}get():Int\prespace{1}=\prespace{1}this.value}%
\end{mdPre}%
\begin{mdP}[data-line={284}]%
%mdk-data-line={284}
{}In Wyvern, analogously to Java, a module named %mdk-data-line={284}
{}\mdCode[class={code,code1}]{m}%mdk-data-line={284}
{} should be stored in
a file %mdk-data-line={285}
{}\mdCode[class={code,code1}]{m.wyv}%mdk-data-line={285}
{} (we expect that the implementation will enforce this in
the near future).  The file system forms a hierarchical namespace with one
name per directory that allows us to find modules by their qualified
name.  In this case, within the %mdk-data-line={288}
{}\mdCode[class={code,code1}]{examples}%mdk-data-line={288}
{} directory of the Wyvern
distribution we have the directory %mdk-data-line={289}
{}\mdCode[class={code,code1}]{modules}%mdk-data-line={289}
{} that contains %mdk-data-line={289}
{}\mdCode[class={code,code1}]{cell.wyv}%mdk-data-line={289}
{},
so we can use it in a program as follows (see %mdk-data-line={290}
{}\mdCode[class={code,code1}]{examples/modules/cellClient.wyv}%mdk-data-line={290}
{}):%
\end{mdP}%
\begin{mdPre}[class={para-block,pre-indented},data-line={292}]%
\mdPrecode{import\prespace{1}modules.cell\prebr{}
\prebr{}
val\prespace{1}myCell\prespace{1}:\prespace{1}cell.Cell\prespace{1}=\prespace{1}cell.make(3)\prebr{}
myCell.set(7)\prebr{}
myCell.get()\prespace{1}//\prespace{1}evalutes\prespace{1}to\prespace{1}7\prebr{}
}%
\end{mdPre}%
\begin{mdP}[data-line={298}]%
%mdk-data-line={298}
{}Here the import statement takes a fully qualified name and uses this to
find the file defining module %mdk-data-line={299}
{}\mdCode[class={code,code1}]{cell}%mdk-data-line={299}
{}.  The module is actually an object
that gets bound to the name %mdk-data-line={300}
{}\mdCode[class={code,code1}]{cell}%mdk-data-line={300}
{}.  We can invoke %mdk-data-line={300}
{}\mdCode[class={code,code1}]{make()}%mdk-data-line={300}
{} on %mdk-data-line={300}
{}\mdCode[class={code,code1}]{cell}%mdk-data-line={300}
{}
just as if it were a method.  Types such as %mdk-data-line={301}
{}\mdCode[class={code,code1}]{Cell}%mdk-data-line={301}
{} defined in the %mdk-data-line={301}
{}\mdCode[class={code,code1}]{cell}%mdk-data-line={301}
{}
module can be referred to by their qualified names, i.e. %mdk-data-line={302}
{}\mdCode[class={code,code1}]{cell.Cell}%mdk-data-line={302}
{}.
In fact, types can be defined as members of an object as well, and the
same qualified syntax can be used to refer to them.  So modules are not
special semantically: they are just a convenient syntax for defining an
object.  Consider what is the type of %mdk-data-line={306}
{}\mdCode[class={code,code1}]{cell}%mdk-data-line={306}
{}?  The answer could be
written as follows:%
\end{mdP}%
\begin{mdPre}[class={para-block,pre-indented},data-line={309}]%
\mdPrecode{type\prespace{1}TCell\prebr{}
\preindent{4}resource\prespace{1}type\prespace{1}Cell\prebr{}
\preindent{8}def\prespace{1}set(newValue:Int):Unit\prebr{}
\preindent{8}def\prespace{1}get():Int\prebr{}
\preindent{4}\prebr{}
\preindent{4}def\prespace{1}make(initVal:Int):this.Cell}%
\end{mdPre}%
\begin{mdP}[data-line={316}]%
%mdk-data-line={316}
{}Wyvern files that define a type use a %mdk-data-line={316}
{}\mdCode[class={code,code1}]{.wyt}%mdk-data-line={316}
{} extension (for Wyvern Type),
and you can find the above definition at %mdk-data-line={317}
{}\mdCode[class={code,code1}]{examples/modules/TCell.wyt}%mdk-data-line={317}
{}.%
\end{mdP}%
\mdHxx[id=sec-resource-modules,label={[9]\{.heading-label\}},toc={},data-line={320},caption={[[9]\{.heading-label\}.{\hspace{0.5em}}]\{.heading-before\}Resource Modules},bookmark={9.{\hspace{0.5em}}Resource Modules}]{%mdk-data-line={320}
{}\mdSpan[class={heading-before}]{\mdSpan[class={heading-label}]{9}.{\hspace{0.5em}}}%mdk-data-line={320}
{}Resource Modules}\begin{mdP}[data-line={323}]%
%mdk-data-line={323}
{}Just as objects with state must be given a resource type, stateful
modules have a resource type.  A %mdk-data-line={324}
{}\mdCode[class={code,code1}]{resource}%mdk-data-line={324}
{} module is one that captures
state in its implementation.  The %mdk-data-line={325}
{}\mdCode[class={code,code1}]{cell}%mdk-data-line={325}
{} module is not a %mdk-data-line={325}
{}\mdCode[class={code,code1}]{resource}%mdk-data-line={325}
{}
module; although it can be used to create stateful %mdk-data-line={326}
{}\mdCode[class={code,code1}]{Cell}%mdk-data-line={326}
{}s, the module
itself does not capture state.  Here is a module that does (%mdk-data-line={327}
{}\mdCode[class={code,code1}]{examples/modules/cellAsModule.wyv}%mdk-data-line={327}
{}):%
\end{mdP}%
\begin{mdPre}[class={para-block,pre-indented},data-line={329}]%
\mdPrecode{module\prespace{1}def\prespace{1}cellAsModule()\prebr{}
\prebr{}
var\prespace{1}value\prespace{1}:\prespace{1}Int\prespace{1}=\prespace{1}0\prebr{}
def\prespace{1}set(newValue:Int):Unit\prebr{}
\preindent{4}value\prespace{1}=\prespace{1}newValue\prebr{}
def\prespace{1}get():Int\prespace{1}=\prespace{1}value}%
\end{mdPre}%
\begin{mdP}[data-line={336}]%
%mdk-data-line={336}
{}Wyvern does not allow implicitly shared global state, because this
often causes problems in software development.  So %mdk-data-line={337}
{}\mdCode[class={code,code1}]{cellAsModule}%mdk-data-line={337}
{} does
not evaluate to an object, but rather a function that, when invoked,
yields a fresh object with its own copy of the internal state defined
by the module.  The %mdk-data-line={340}
{}\mdCode[class={code,code1}]{module\prespace{1}def}%mdk-data-line={340}
{} syntax indicates this; it is reminiscent
of the %mdk-data-line={341}
{}\mdCode[class={code,code1}]{def}%mdk-data-line={341}
{} syntax for defining functions.  We will call functions that
produce modules functors, after Standard ML (and inspired by category
theory, for the mathematically inclined).  We can use %mdk-data-line={343}
{}\mdCode[class={code,code1}]{cellAsModule}%mdk-data-line={343}
{} in
a program as follows (%mdk-data-line={344}
{}\mdCode[class={code,code1}]{examples/modules/cellModuleClient.wyv}%mdk-data-line={344}
{}):%
\end{mdP}%
\begin{mdPre}[class={para-block,pre-indented},data-line={346}]%
\mdPrecode{import\prespace{1}modules.cellAsModule\prebr{}
\prebr{}
val\prespace{1}m1\prespace{1}=\prespace{1}cellAsModule()\prespace{4}\prebr{}
val\prespace{1}m2\prespace{1}=\prespace{1}cellAsModule()\prebr{}
m1.set(1)\prebr{}
m2.set(2)\prebr{}
m1.get()\prespace{1}//\prespace{1}evalutes\prespace{1}to\prespace{1}1\prebr{}
m2.get()\prespace{1}//\prespace{1}evalutes\prespace{1}to\prespace{1}2}%
\end{mdPre}%
\begin{mdP}[data-line={355}]%
%mdk-data-line={355}
{}In this example you can see that we have instantiated the %mdk-data-line={355}
{}\mdCode[class={code,code1}]{resource}%mdk-data-line={355}
{}
module %mdk-data-line={356}
{}\mdCode[class={code,code1}]{cellAsModule}%mdk-data-line={356}
{} twice, and each instance of the module has its
own internal state.%
\end{mdP}%
\begin{mdPre}[class={para-block,pre-indented},data-line={360}]%
\mdPrecode{}%
\end{mdPre}%
\mdHxx[id=sec-module-parameters,label={[10]\{.heading-label\}},toc={},data-line={360},caption={[[10]\{.heading-label\}.{\hspace{0.5em}}]\{.heading-before\}Module Parameters},bookmark={10.{\hspace{0.5em}}Module Parameters}]{%mdk-data-line={360}
{}\mdSpan[class={heading-before}]{\mdSpan[class={heading-label}]{10}.{\hspace{0.5em}}}%mdk-data-line={360}
{}Module Parameters}\begin{mdP}[data-line={363}]%
%mdk-data-line={363}
{}If resource modules are produced by functors (module functions), we
expect to be able to pass
parameters%mdk-data-line={365}
{}{\textendash}%mdk-data-line={365}
{}and so we can.  First let%mdk-data-line={365}
{}{'}%mdk-data-line={365}
{}s define the type that
%mdk-data-line={366}
{}\mdCode[class={code,code1}]{cellAsModule}%mdk-data-line={366}
{} returns.  For convenience, we will put this type in a
file %mdk-data-line={367}
{}\mdCode[class={code,code1}]{TCellAsModule.wyt}%mdk-data-line={367}
{} (here %mdk-data-line={367}
{}\mdCode[class={code,code1}]{.wyt}%mdk-data-line={367}
{} stands for Wyvern Type):%
\end{mdP}%
\begin{mdPre}[class={para-block,pre-indented},data-line={369}]%
\mdPrecode{resource\prespace{1}type\prespace{1}TCellAsModule\prebr{}
\preindent{4}def\prespace{1}set(newValue:Int):Unit\prebr{}
\preindent{4}def\prespace{1}get():Int}%
\end{mdPre}%
\begin{mdP}[data-line={373}]%
%mdk-data-line={373}
{}Here is a client of the cellAsModule (%mdk-data-line={373}
{}\mdCode[class={code,code1}]{examples/modules/cellClientFunctor.wyv}%mdk-data-line={373}
{}):%
\end{mdP}%
\begin{mdPre}[class={para-block,pre-indented},data-line={375}]%
\mdPrecode{module\prespace{1}def\prespace{1}cellClientFunctor(cell\prespace{1}:\prespace{1}modules.TCellAsModule)\prebr{}
\prebr{}
def\prespace{1}addOne():Unit\prebr{}
\preindent{4}cell.set(cell.get()+1)\prebr{}
\preindent{4}\prebr{}
def\prespace{1}getValue():Int\prespace{1}=\prespace{1}cell.get()\prebr{}
}%
\end{mdPre}%
\begin{mdP}[data-line={382}]%
%mdk-data-line={382}
{}We can put module parameters in between the parentheses in the definition
of the functor, specifying the type in the usual way.%
\end{mdP}%
\begin{mdP}[class={indent},data-line={385}]%
%mdk-data-line={385}
{}Now we can use %mdk-data-line={385}
{}\mdCode[class={code,code1}]{cellAsModule}%mdk-data-line={385}
{} together with %mdk-data-line={385}
{}\mdCode[class={code,code1}]{cellClientFunctor}%mdk-data-line={385}
{} in a program (%mdk-data-line={385}
{}\mdCode[class={code,code1}]{examples/modules/cellClientMain.wyv}%mdk-data-line={385}
{}):%
\end{mdP}%
\begin{mdPre}[class={para-block,pre-indented},data-line={387}]%
\mdPrecode{import\prespace{1}myPackage.cellAsModule\prebr{}
import\prespace{1}myPackage.cellClientFunctor\prebr{}
\prebr{}
val\prespace{1}client\prespace{1}=\prespace{1}cellClientFunctor(cellAsModule())\prebr{}
client.addOne()\prebr{}
client.getValue()\prespace{1}//\prespace{1}evalutes\prespace{1}to\prespace{1}1}%
\end{mdPre}%
\mdHxx[id=sec-dynamic-types,label={[11]\{.heading-label\}},toc={},data-line={395},caption={[[11]\{.heading-label\}.{\hspace{0.5em}}]\{.heading-before\}Dynamic Types},bookmark={11.{\hspace{0.5em}}Dynamic Types}]{%mdk-data-line={395}
{}\mdSpan[class={heading-before}]{\mdSpan[class={heading-label}]{11}.{\hspace{0.5em}}}%mdk-data-line={395}
{}Dynamic Types}\begin{mdP}[data-line={398}]%
%mdk-data-line={398}
{}Wyvern is intended to be a mostly statically typed language.  However,
while getting parameterized types to work, we implemented a %mdk-data-line={399}
{}\mdCode[class={code,code1}]{Dyn}%mdk-data-line={399}
{} type that
partially implements dynamic types.  Specifically, %mdk-data-line={400}
{}\mdCode[class={code,code1}]{Dyn}%mdk-data-line={400}
{} is a subtype
of any type, and any type is a subtype of %mdk-data-line={401}
{}\mdCode[class={code,code1}]{Dyn}%mdk-data-line={401}
{}.  (Note that subtyping
is not transitive where %mdk-data-line={402}
{}\mdCode[class={code,code1}]{Dyn}%mdk-data-line={402}
{} is involved, as this would effectively
collapse the type system to a single type.)%
\end{mdP}%
\begin{mdP}[class={indent},data-line={405}]%
%mdk-data-line={405}
{}We recommend avoiding %mdk-data-line={405}
{}\mdCode[class={code,code1}]{Dyn}%mdk-data-line={405}
{} where possible, and gradually transitioning
existing %mdk-data-line={406}
{}\mdCode[class={code,code1}]{Dyn}%mdk-data-line={406}
{} code to remove use of this construct.  If we do keep this
in the long term, we need to think about how it interacts with resource
types.%
\end{mdP}%
\mdHxx[id=sec-declaration-sequences-and-mutual-recursion,label={[12]\{.heading-label\}},toc={},data-line={411},caption={[[12]\{.heading-label\}.{\hspace{0.5em}}]\{.heading-before\}Declaration Sequences and Mutual Recursion},bookmark={12.{\hspace{0.5em}}Declaration Sequences and Mutual Recursion}]{%mdk-data-line={411}
{}\mdSpan[class={heading-before}]{\mdSpan[class={heading-label}]{12}.{\hspace{0.5em}}}%mdk-data-line={411}
{}Declaration Sequences and Mutual Recursion}\begin{mdP}[data-line={414}]%
%mdk-data-line={414}
{}Programs are made up of four kinds of core
declarations: %mdk-data-line={415}
{}\mdCode[class={code,code1}]{val}%mdk-data-line={415}
{}, %mdk-data-line={415}
{}\mdCode[class={code,code1}]{var}%mdk-data-line={415}
{}, %mdk-data-line={415}
{}\mdCode[class={code,code1}]{def}%mdk-data-line={415}
{}, and %mdk-data-line={415}
{}\mdCode[class={code,code1}]{type}%mdk-data-line={415}
{}, as well as expressions.
The %mdk-data-line={416}
{}\mdCode[class={code,code1}]{val}%mdk-data-line={416}
{} and %mdk-data-line={416}
{}\mdCode[class={code,code1}]{var}%mdk-data-line={416}
{} declarations and the expressions in a program
are evaluated
in sequence, and the variables defined earlier in the sequence are
in scope in later declarations and expressions.  In contrast,
%mdk-data-line={420}
{}\mdCode[class={code,code1}]{def}%mdk-data-line={420}
{} and %mdk-data-line={420}
{}\mdCode[class={code,code1}]{type}%mdk-data-line={420}
{} declarations do not evaluate, and therefore these
declaration forms can be safely used to define mutually recursive
functions and types.  Each sequence of declarations that consists
exclusively of %mdk-data-line={423}
{}\mdCode[class={code,code1}]{def}%mdk-data-line={423}
{} and %mdk-data-line={423}
{}\mdCode[class={code,code1}]{type}%mdk-data-line={423}
{} is therefore treated as a mutually
recursive block, so that the definition or type defined in each of
the declarations is in scope in all the other declarations.%
\end{mdP}%
\begin{mdP}[class={indent},data-line={427}]%
%mdk-data-line={427}
{}To understand why we allow recursive %mdk-data-line={427}
{}\mdCode[class={code,code1}]{def}%mdk-data-line={427}
{} and %mdk-data-line={427}
{}\mdCode[class={code,code1}]{type}%mdk-data-line={427}
{} declarations
but do not allow this for %mdk-data-line={428}
{}\mdCode[class={code,code1}]{val}%mdk-data-line={428}
{} and %mdk-data-line={428}
{}\mdCode[class={code,code1}]{var}%mdk-data-line={428}
{} declarations, consider
the following example:%
\end{mdP}%
\begin{mdPre}[class={para-block,pre-indented},data-line={431}]%
\mdPrecode{//\prespace{1}NOTE:\prespace{1}this\prespace{1}example\prespace{1}does\prespace{1}not\prespace{1}typecheck\prebr{}
type\prespace{1}IntCell\prebr{}
\preindent{4}def\prespace{1}get():Int\prebr{}
\prebr{}
def\prespace{1}foo():IntCell\prespace{1}=\prespace{1}baz()\prebr{}
val\prespace{1}bar:IntCell\prespace{1}=\prespace{1}foo()\prebr{}
def\prespace{1}baz():IntCell\prespace{1}=\prespace{1}bar\prebr{}
\prebr{}
bar.get()}%
\end{mdPre}%
\begin{mdP}[data-line={441}]%
%mdk-data-line={441}
{}When we try to initialize the %mdk-data-line={441}
{}\mdCode[class={code,code1}]{bar}%mdk-data-line={441}
{} value, we call %mdk-data-line={441}
{}\mdCode[class={code,code1}]{foo()}%mdk-data-line={441}
{}, which in
turn invokes %mdk-data-line={442}
{}\mdCode[class={code,code1}]{baz()}%mdk-data-line={442}
{}.  However, %mdk-data-line={442}
{}\mdCode[class={code,code1}]{baz()}%mdk-data-line={442}
{} reads the %mdk-data-line={442}
{}\mdCode[class={code,code1}]{bar}%mdk-data-line={442}
{} variable, which
is what we are defining, so there is no well-defined result.  Languages
such as Java handle this by initializing %mdk-data-line={444}
{}\mdCode[class={code,code1}]{bar}%mdk-data-line={444}
{} to %mdk-data-line={444}
{}\mdCode[class={code,code1}]{null}%mdk-data-line={444}
{} at first and
then writing a permanent value to it after the initializer executes.
However, in order to avoid null pointer errors, Wyvern does not allow
%mdk-data-line={447}
{}\mdCode[class={code,code1}]{null}%mdk-data-line={447}
{} as a value.  Languages such as Haskell would use a special
%mdk-data-line={448}
{}{\textquotedblleft}black hole{\textquotedblright}%mdk-data-line={448}
{} value and signal a run-time error if the black hole is
ever used, as in the %mdk-data-line={449}
{}\mdCode[class={code,code1}]{bar.get}%mdk-data-line={449}
{} statement at the end.
We avoid this semantics as it adds complexity and means the
program can fail at run time.  Of course, infinite loops can still
exist in Wyvern, but they come from recursive functions, never
recursively defined values.%
\end{mdP}%
\mdHxx[id=sec-some-more-examples,label={[13]\{.heading-label\}},toc={},data-line={456},caption={[[13]\{.heading-label\}.{\hspace{0.5em}}]\{.heading-before\}Some More Examples},bookmark={13.{\hspace{0.5em}}Some More Examples}]{%mdk-data-line={456}
{}\mdSpan[class={heading-before}]{\mdSpan[class={heading-label}]{13}.{\hspace{0.5em}}}%mdk-data-line={456}
{}Some More Examples}\begin{mdP}[data-line={459}]%
%mdk-data-line={459}
{}The Wyvern standard library files are in subdirectories of %mdk-data-line={459}
{}\mdCode[class={code,code1}]{stdlib}%mdk-data-line={459}
{}.  For example, earlier we used the %mdk-data-line={459}
{}\mdCode[class={code,code1}]{IfTSL}%mdk-data-line={459}
{} library, defined in %mdk-data-line={459}
{}\mdCode[class={code,code1}]{stdlib/wyver/IfTSL.wyv}%mdk-data-line={459}
{}.%
\end{mdP}%
\begin{mdP}[class={indent},data-line={461}]%
%mdk-data-line={461}
{}Platform-specific definitions are in the %mdk-data-line={461}
{}\mdCode[class={code,code1}]{platform}%mdk-data-line={461}
{} subdirectory of %mdk-data-line={461}
{}\mdCode[class={code,code1}]{stdlib}%mdk-data-line={461}
{}, in a sub-subdirectory named after the platform (e.g. %mdk-data-line={461}
{}\mdCode[class={code,code1}]{java}%mdk-data-line={461}
{}).
For example, %mdk-data-line={462}
{}\mdCode[class={code,code1}]{stdout}%mdk-data-line={462}
{} is defined in %mdk-data-line={462}
{}\mdCode[class={code,code1}]{stdlib/platform/java/stdout.wyv}%mdk-data-line={462}
{} for the %mdk-data-line={462}
{}\mdCode[class={code,code1}]{java}%mdk-data-line={462}
{} platform; there is an analogous definition for the %mdk-data-line={462}
{}\mdCode[class={code,code1}]{python}%mdk-data-line={462}
{} platform too.  The definition of %mdk-data-line={462}
{}\mdCode[class={code,code1}]{stdout}%mdk-data-line={462}
{} for %mdk-data-line={462}
{}\mdCode[class={code,code1}]{java}%mdk-data-line={462}
{} uses some Java helper code defined in the Java class %mdk-data-line={462}
{}\mdCode[class={code,code1}]{wyvern.stdlib.support.Stdio}%mdk-data-line={462}
{}.%
\end{mdP}%
\begin{mdP}[class={indent},data-line={464}]%
%mdk-data-line={464}
{}An example of a utility library that provides a small part of a regular expression package is in %mdk-data-line={464}
{}\mdCode[class={code,code1}]{wyvern/util/matching/regex.wyv}%mdk-data-line={464}
{}.  The design approximately follows the corresponding Scala library.%
\end{mdP}%
\begin{mdP}[class={indent},data-line={466}]%
%mdk-data-line={466}
{}An example of a data structure library is %mdk-data-line={466}
{}\mdCode[class={code,code1}]{wyvern/collections/list.wyv}%mdk-data-line={466}
{}.  Also see %mdk-data-line={466}
{}\mdCode[class={code,code1}]{wyvern/option.wyv}%mdk-data-line={466}
{}.%
\end{mdP}%
\begin{mdP}[class={indent},data-line={468}]%
%mdk-data-line={468}
{}All of the above examples are tested by the Wyvern regression test suite that is run as part of %mdk-data-line={468}
{}\mdCode[class={code,code1}]{ant\prespace{1}test}%mdk-data-line={468}
{} when building Wyvern.%
\end{mdP}%
\begin{mdDiv}[class={logomadoko,block},elem={logomadoko},text-align={right},font-size={xx-small},margin-top={4em},data-line={471}]%
%mdk-data-line={472}
{}Created with{\mdNbsp}\mdA{https://www.madoko.net}{}{Madoko.net}.%
\end{mdDiv}%


\end{document}
