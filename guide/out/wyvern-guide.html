<!DOCTYPE html>
<html lang="en-US">
<head>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
  <meta name="generator" content="Madoko, version 1.1.4" />
  <meta name="viewport" content="initial-scale=1.0" />
  <meta name="author" content="Jonathan Aldrich" />
  <title>Guide to Programming in Wyvern</title>
  <style type="text/css"  class="link">
  /*# sourceURL=madoko.css */
  
  .madoko .toc>.tocblock .tocblock .tocblock {
    margin-left: 2.25em;
  }
  .madoko .toc>.tocblock .tocblock {
    margin-left: 1.5em;
  }
  .madoko .toc-contents>.tocblock>.tocitem {
    font-weight: bold;
  }
  .madoko .toc {
    margin-top: 1em;
  }
  .madoko p.para-continue {
    margin-bottom: 0pt;
  }
  .madoko .para-block+p {
    margin-top: 0pt;
  }
  .madoko ul.para-block, .madoko ol.para-block {
    margin-top: 0pt;
    margin-bottom: 0pt;
  }
  .madoko ul.para-end, .madoko ol.para-end {
    margin-bottom: 1em;
  }
  .madoko dl {
    margin-left: 0em;
  }
  .madoko blockquote {
    font-style: italic;
  }
  .madoko a.localref {
    text-decoration: none;
  }
  .madoko a.localref:hover {
    text-decoration: underline;
  }
  .madoko .footnotes {
    font-size: smaller;
    margin-top: 2em;
  }
  .madoko .footnotes hr {
    width: 50%;
    text-align: left;
  }
  .madoko .footnote { 
    margin-left: 1em;
  }
  .madoko .footnote-before {
    margin-left: -1em;
    width: 1em;
    display: inline-block;
  }
  .madoko .align-center, .madoko .align-center>p {
    text-align: center !important;
  }
  .madoko .align-center pre {
    text-align: left;
  }
  .madoko .align-center>* {
    margin-left: auto !important;
    margin-right: auto !important;
  }
  .madoko .align-left, .madoko .align-left>p {
    text-align: left !important;
  }
  .madoko .align-left>* {
    margin-left: 0pt !important;
    margin-right: auto !important;
  }
  .madoko .align-right, .madoko .align-right>p {
    text-align: right !important;
  }
  .madoko .align-right>* {
    margin-left: auto !important;
    margin-right: 0pt !important;
  }
  .madoko .align-center>table,
  .madoko .align-left>table,
  .madoko .align-right>table {
    text-align: left !important;
  }
  .madoko .equation-before {
    float: right;
  }
  .madoko .bibitem {
    font-size: smaller;
  }
  .madoko .bibsearch {
    font-size: x-small;
    text-decoration:none;
    color: black;
    font-family: "Segoe UI Symbol", Symbola, serif;
  }
  .madoko .block, .madoko .figure, .madoko .bibitem, .madoko .equation, .madoko div.math {
    margin-top: 1ex;
    margin-bottom: 1ex;
  }
  .madoko .figure {
    padding: 0.5em;
    margin-left: 0pt;
    margin-right: 0pt;
  }
  .madoko .hidden {
    display: none;
  }
  .madoko .invisible {
    visibility: hidden;
  }
  .madoko.preview .invisible {
    visibility: visible;
    opacity: 0.5;
  }
  .madoko code.code, .madoko span.code {
    white-space: pre-wrap;
  }
  .madoko hr, hr.madoko {
    border: none;
    border-bottom: black solid 1px;
    margin-bottom: 0.5ex;
  }
  .madoko .framed>*:first-child {
    margin-top: 0pt;
  }
  .madoko .framed>*:last-child {
    margin-bottom: 0pt;
  }
  .madoko ul.list-style-type-dash {
      list-style-type: none !important;
  }
  .madoko ul.list-style-type-dash > li:before {
      content: "\2013"; 
      position: absolute;
      margin-left: -1em; 
  }
  .madoko table.madoko {
    border-collapse: collapse;
  }
  .madoko td, .madoko th {
    padding: 0ex 0.5ex;
    margin: 0pt;
    vertical-align: top;
  }
  .madoko .cell-border-left {
    border-left: 1px solid black;
  }
  .madoko .cell-border-right {
    border-right: 1px solid black;
  }
  .madoko thead>tr:first-child>.cell-line,
  .madoko tbody:first-child>tr:first-child>.cell-line {
    border-top: 1px solid black;
    border-bottom: none;
  }
  .madoko .cell-line, .madoko .cell-double-line {
    border-bottom: 1px solid black;
    border-top: none;
  }
  .madoko .cell-double-line {
    border-top: 1px solid black;
    padding-top: 1.5px !important;
  }
  .madoko .input-mathpre .MathJax_Display {
    text-align: left !important;
  }
  .madoko div.input-mathpre {
    text-align: left;
    margin-top: 1.5ex;
    margin-bottom: 1ex;
  }
  .madoko .math-rendering {
    text-align: left;
    white-space: pre;
    color: gray;
  }
  .madoko .mathdisplay {
    text-align: center;
  }
  .madoko .pretty table {
    border-collapse: collapse;
  }
  .madoko .pretty td {
    padding: 0em;
  }
  .madoko .pretty td.empty {
    min-width: 1.5ex;
  }
  .madoko .pretty td.expander {
    width: 100em;
  }
  body.madoko, .madoko .serif {
    font-family: Cambria,"Times New Roman","Liberation Serif","Times",serif;
  }
  .madoko .sans-serif {
    font-family: "Calibri", "Optima", sans-serif;
  }
  .madoko .symbol {
    font-family: "Segoe UI Symbol", Symbola, serif;
  }
  body.madoko {  
    -webkit-text-size-adjust: 100%;       
    text-rendering: optimizeLegibility;
  }
  body.madoko {
    max-width: 88ex; 
    margin: 1em auto;
    padding: 0em 2em;  
  }
  body.preview.madoko {
    padding: 0em 1em;
  }
  .madoko p {
    text-align: justify;
  }
  .madoko h1, .madoko h2, .madoko h3, .madoko h4 { 
    margin-top: 1.22em; 
    margin-bottom: 1ex;
  }
  .madoko h1+p, .madoko h2+p, .madoko h3+p, .madoko h4+p, .madoko h5+p  { 
    margin-top: 1ex;    
  }
  .madoko h5, .madoko h6 { 
    margin-top: 1ex;
    font-size: 1em;
  }
  .madoko h5 { 
    margin-bottom: 0.5ex;
  }
  .madoko h5 + p {
    margin-top: 0.5ex;
  }
  .madoko h6 { 
    margin-bottom: 0pt;
  }
  .madoko h6 + p {
    margin-top: 0pt;
  }
  .madoko pre, .madoko code, .madoko kbd, .madoko samp, .madoko tt, 
  .madoko .monospace, .madoko .token-indent, .madoko .reveal pre, .madoko .reveal code, .madoko .email {
    font-family: Consolas,"Andale Mono WT","Andale Mono",Lucida Console,Monaco,monospace,monospace;
    font-size: 0.85em;
  }
  .madoko pre code, .madoko .token-indent {
    font-size: 0.95em;
  }
  .madoko pre code {
    font-family: inherit !important;
  }
  .madoko ol.linenums li {
    background-color: white;
    list-style-type: decimal;
  }
  .madoko .remote {
    background-color: #F0FFF0;
  }
  .madoko .remote + * {
    margin-top: 0pt;
  }
  @media print {
    body.madoko {
      font-size: 10pt;
    }
    @page {
      margin: 1in 1.5in;
    }
  }
  @media only screen and (max-device-width:1024px) {
    body.madoko {
      padding: 0em 0.5em;    
    }
    .madoko li {
      text-align: left;
    }
  }
  
    </style>
  
  </head>
<body class="madoko">

<div class="body madoko" style="line-adjust:0">

<div class="mathdefs input-mathdefs" data-line="10"></div><h2 id="sec-why-wyvern" class="h1" data-line="16" data-heading-depth="1" style="display:block"><span data-line="16"></span><span class="heading-before"><span class="heading-label">1</span>.&#8194;</span><span data-line="16"></span>Why Wyvern?</h2>
<p class="p noindent" data-line="19"><span data-line="19"></span>Wyvern is a new programming language exploring how to help software
engineers build software better at scale.  Our primary aim is to do
research that discovers and validates new principles for designing
engineering-focused programming languages.  Part of the <span data-line="22"></span>&#8220;validation&#8221;<span data-line="22"></span>
bit is actually writing interesting programs in Wyvern, and so we
hope to also make it a great language to write code in<span data-line="24"></span>&#8212;<span data-line="24"></span>for us,
and for you!
</p>
<p class="p indent" data-line="27"><span data-line="27"></span>Wyvern<span data-line="27"></span>&#39;<span data-line="27"></span>s design incorporates a lot of great ideas from prior
languages: it is a statically-typed, garbage-collected general-purpose
applications programming language with excellent support for both
object-oriented and functional programming.  However, Wyvern is most
interesting because of the new ideas it explores.  Most of these are
best illustrated through the examples below, but here<span data-line="32"></span>&#39;<span data-line="32"></span>s a brief
overview of Wyvern<span data-line="33"></span>&#39;<span data-line="33"></span>s most interesting design features and what motivates
them.
</p>
<ul class="ul list-star compact" data-line="36">
<li class="li ul-li list-star-li compact-li" data-line="36">
<p data-line="36"><span data-line="36"></span>Large programs must be composed from parts, so Wyvern has an
advanced module system with features echoing those of Standard
ML<span data-line="38"></span>&#39;<span data-line="38"></span>s module system.  However, modern programs often load and
(re-)compose modules at run time, so Wyvern modules and functors
are first-class objects and functions, respectively, providing
programmers with the power and flexibility they need.
</p></li>
<li class="li ul-li list-star-li compact-li" data-line="43">
<p data-line="43"><span data-line="43"></span>No one language can be good at everything, so Wyvern is extensible:
libraries can define new syntax for the abstractions that they
provide, and that syntax can be embedded seamlessly in Wyvern
expressions.
</p></li>
<li class="li ul-li list-star-li compact-li" data-line="48">
<p data-line="48"><span data-line="48"></span>Engineers need to control the access that untrusted code has to
resources such as the network or file system, and so Wyvern<span data-line="49"></span>&#39;<span data-line="49"></span>s module
system is the first to be designed from the ground up to be
capability-safe.  We are designing an effect system that leverages
these capabilities to provide lightweight and automatically-checked
control of resources.
</p></li>
<li class="li ul-li list-star-li compact-li" data-line="55">
<p data-line="55"><span data-line="55"></span>More broadly, understanding and controlling the software architecture
of a program is critical to understanding its properties and evolving
it over time.  Thus we are building a way of expressing software
architecture as an integrated part of Wyvern programs, including a
static view building on the module system and a dynamic view showing
run-time components and the connections between them.  Wyvern
architectures are <span data-line="61"></span>&#8220;live&#8221;<span data-line="61"></span> in that changing the architecture specification
affects the program semantics, and they are <span data-line="62"></span>&#8220;trusted&#8221;<span data-line="62"></span> in that they are
guaranteed to be an accurate abstraction of what the program does.
</p><h2 id="sec-hello-world-in-wyvern" class="h1" data-line="66" data-heading-depth="1" style="display:block"><span data-line="66"></span><span class="heading-before"><span class="heading-label">2</span>.&#8194;</span><span data-line="66"></span>Hello, World! in Wyvern</h2></li></ul>

<p class="p noindent" data-line="69"><span data-line="69"></span>Here is a <span data-line="69"></span>&#8220;Hello, World!&#8221;<span data-line="69"></span> program in Wyvern (<span data-line="69"></span><code class="code code1">examples/rosetta/hello.wyv</code><span data-line="69"></span>):
</p>
<pre class="para-block pre-indented" data-line="71" style="display:block"><code>require stdout

stdout.print(&quot;Hello, World!&quot;)</code></pre>
<p class="p noindent para-continued" data-line="75"><span data-line="75"></span>This program already illustrates a couple of basic aspects of Wyvern.  First,
Wyvern is object-oriented: <span data-line="76"></span><code class="code code1">stdout</code><span data-line="76"></span> is an object, and we are invoking the
<span data-line="77"></span><code class="code code1">print</code><span data-line="77"></span> method on it.  For expressions, much of Wyvern<span data-line="77"></span>&#39;<span data-line="77"></span>s syntax is similar
to Java<span data-line="78"></span>&#39;<span data-line="78"></span>s.
</p>
<p class="p indent" data-line="80"><span data-line="80"></span>Second, system resources such as the standard output object, <span data-line="80"></span><code class="code code1">stdout</code><span data-line="80"></span>,
are not ambiently available to programs, but must be explicitly required
from the operating system.  A primary goal of Wyvern<span data-line="82"></span>&#39;<span data-line="82"></span>s module system
is helping developers to reason about the use of resources.  Thus even
a simple script such as Hello World must declare the resources it
requires in order to execute.  This allows engineers to determine at a
glance what kind of I/O a program might do, and provides a basis for
making a decision about whether to run this program in a particular
situation.  In this case, even without looking at the actual code, we
know that this program may write to the standard output stream, but will
not access the file system or access the network.
</p><h2 id="sec-anonymous-functions" class="h1" data-line="93" data-heading-depth="1" style="display:block"><span data-line="93"></span><span class="heading-before"><span class="heading-label">3</span>.&#8194;</span><span data-line="93"></span>Anonymous Functions</h2>
<p class="p noindent" data-line="96"><span data-line="96"></span>Wyvern has good support for functional programming, and anonymous functions can be defined in Wyvern using the syntax:
</p>
<pre class="para-block pre-indented" data-line="98" style="display:block"><code>(x:Int) =&gt; x + 1</code></pre>
<p class="p noindent para-continued" data-line="100"><span data-line="100"></span>We can bind the expresison above to a variable and invoke it:
</p>
<pre class="para-block pre-indented" data-line="102" style="display:block"><code>val addOne = (x:Int) =&gt; x + 1
addOne(1)
</code></pre>
<p class="p noindent para-continued" data-line="105"><span data-line="105"></span>and the result will be 2.
</p>
<p class="p indent" data-line="107"><span data-line="107"></span>Anonymous functions can also have multiple parameters:
</p>
<pre class="para-block pre-indented" data-line="109" style="display:block"><code>(x:Int,y:Int) =&gt; x + y
</code></pre>
<p class="p noindent para-continued" data-line="111"><span data-line="111"></span>or no parameters:
</p>
<pre class="para-block pre-indented" data-line="113" style="display:block"><code>() =&gt; 7</code></pre>
<p class="p noindent para-continued" data-line="115"><span data-line="115"></span>Function types can be denoted with an arrow, and we can annotate
a variable with this type.  If we annotate the type of the variable
we are binding to the function, we can leave out the type annotation
(and even the parentheses) on the function<span data-line="118"></span>&#39;<span data-line="118"></span>s argument:
</p>
<pre class="para-block pre-indented" data-line="120" style="display:block"><code>val annotatedAddOne : Int -&gt; Int = x =&gt; x + 1
</code></pre>
<p class="p noindent para-continued" data-line="122"><span data-line="122"></span>This also works if we pass an anonymous function to a higher-order
function:
</p>
<pre class="para-block pre-indented" data-line="125" style="display:block"><code>val invokeIt = (f:Int -&gt; Int, x:Int) =&gt; f(x)
invokeIt(x =&gt; x+1, 5)</code></pre>
<p class="p noindent para-continued" data-line="128"><span data-line="128"></span>The code above can be found in <span data-line="128"></span><code class="code code1">examples/introductory/functions.wyv</code><span data-line="128"></span>
</p><h2 id="sec-functions-in-wyvern" class="h1" data-line="131" data-heading-depth="1" style="display:block"><span data-line="131"></span><span class="heading-before"><span class="heading-label">4</span>.&#8194;</span><span data-line="131"></span>Functions in Wyvern</h2>
<p class="p noindent" data-line="134"><span data-line="134"></span>Consider the definition of the <span data-line="134"></span><code class="code code1">factorial</code><span data-line="134"></span> function in Wyvern (<span data-line="134"></span><code class="code code1">examples/rosetta/factorial.wyv</code><span data-line="134"></span>):
</p>
<pre class="para-block pre-indented" data-line="136" style="display:block"><code>require stdout

def factorial(n:Int):Int
    (n &lt; 2).ifTrue(
        () =&gt; 1,
        () =&gt; n * factorial(n-1)
    )

stdout.print(&quot;factorial(15) = &quot;)
stdout.printInt(factorial(15))</code></pre>
<p class="p noindent para-continued" data-line="147"><span data-line="147"></span>A function is defined with the <span data-line="147"></span><code class="code code1">def</code><span data-line="147"></span> keyword, and its argument and
return types are given in Algol-like syntax.  Functions defined with
<span data-line="149"></span><code class="code code1">def</code><span data-line="149"></span> are recursive, so we can call <span data-line="149"></span><code class="code code1">factorial</code><span data-line="149"></span> in the body.  The
example illustrates how an integer comparison <span data-line="150"></span><code class="code code1">n-2</code><span data-line="150"></span> is a boolean object,
on which we can invoke the <span data-line="151"></span><code class="code code1">ifTrue</code><span data-line="151"></span> method.  This method takes two
functions, one of which is evaluated in the true case and one of which
is evaluated in the false case.
</p>
<p class="p indent" data-line="155"><span data-line="155"></span>Note that <span data-line="155"></span><code class="code code1">factorial(15)</code><span data-line="155"></span> would overflow in languages such
as Java in which the default integer types is represented using only
32 bits.  In Wyvern, <span data-line="157"></span><code class="code code1">Int</code><span data-line="157"></span> means an arbitrary precision integer.
</p>
<p class="p indent" data-line="159"><span data-line="159"></span>Wyvern provides a nicer way to write the <span data-line="159"></span><code class="code code1">if</code><span data-line="159"></span> statement above, if we
are willing to import a library that includes a type-specific language
for then-else clauses:
</p>
<pre class="para-block pre-indented" data-line="163" style="display:block"><code>import metadata wyvern.IfTSL
val iff = (x:Boolean, y:IfTSL.IfExprR) =&gt; IfTSL.doifR(x, y)

def fact(n:Int):Int
    iff (n &lt; 2, ~)
        then
            1
        else
            n * fact(n-1)</code></pre>
<p class="p noindent para-continued" data-line="173"><span data-line="173"></span>The import statement loads the <span data-line="173"></span><code class="code code1">IfTSL</code><span data-line="173"></span> module from the <span data-line="173"></span><code class="code code1">wyvern</code><span data-line="173"></span> package.
The <span data-line="174"></span><code class="code code1">metadata</code><span data-line="174"></span> keyword indicates that the library defines new syntax,
in this case for <span data-line="175"></span><code class="code code1">then</code><span data-line="175"></span> and <span data-line="175"></span><code class="code code1">else</code><span data-line="175"></span> clauses.  We define an <span data-line="175"></span><code class="code code1">iff</code><span data-line="175"></span> shorthand
for calling the <span data-line="176"></span><code class="code code1">doifR</code><span data-line="176"></span> function from that library.  Then we can just use
<span data-line="177"></span><code class="code code1">then</code><span data-line="177"></span> and <span data-line="177"></span><code class="code code1">else</code><span data-line="177"></span> keywords and indent blocks of code below each one.  Note
that because of the way type-specific languages (TSLs) work in Wyvern, it<span data-line="178"></span>&#39;<span data-line="178"></span>s
not possible to put <span data-line="179"></span><code class="code code1">then</code><span data-line="179"></span> and <span data-line="179"></span><code class="code code1">else</code><span data-line="179"></span> on a single line.
</p>
<p class="p indent" data-line="181"><span data-line="181"></span>We hope to make this even a bit cleaner in the future.
              <span data-line="182"></span> <span data-line="182"></span> 
</p><h2 id="sec-objects-and-object-types-in-wyvern" class="h1" data-line="184" data-heading-depth="1" style="display:block"><span data-line="184"></span><span class="heading-before"><span class="heading-label">5</span>.&#8194;</span><span data-line="184"></span>Objects and Object Types in Wyvern</h2>
<p class="p noindent" data-line="187"><span data-line="187"></span>We can define a sumable integer list type as follows (<span data-line="187"></span><code class="code code1">examples/introductory/objects.wyv</code><span data-line="187"></span>):
</p>
<pre class="para-block pre-indented" data-line="189" style="display:block"><code>type IntList
    def sum():Int</code></pre>
<p class="p noindent para-continued" data-line="192"><span data-line="192"></span>The <span data-line="192"></span><code class="code code1">type</code><span data-line="192"></span> keyword declares a new object type, called <span data-line="192"></span><code class="code code1">IntList</code><span data-line="192"></span> in
this case.  The public methods available in the type are listed below,
but no method bodies may be given as we are defining a type, not an
implementation.
</p>
<p class="p indent" data-line="197"><span data-line="197"></span>We can implement a constant representing the empty list and a
constructor for creating a larger list out of a smaller one as
follows:
</p>
<pre class="para-block pre-indented" data-line="201" style="display:block"><code>val empty:IntList = new
    def sum():Int = 0

def cons(elem:Int,rest:IntList):IntList = new
    def sum():Int = elem + rest.sum()
    
cons(3,cons(4,empty)).sum() // evalutes to 7</code></pre>
<p class="p noindent para-continued" data-line="209"><span data-line="209"></span>The <span data-line="209"></span><code class="code code1">new</code><span data-line="209"></span> expression creates an object with the methods given.  In
the example above, we just have one method, <span data-line="210"></span><code class="code code1">sum()</code><span data-line="210"></span>, which evaluates
to <span data-line="211"></span><code class="code code1">0</code><span data-line="211"></span> in the case of the <span data-line="211"></span><code class="code code1">empty</code><span data-line="211"></span> list and sums up the integers in
the list otherwise.
</p><h2 id="sec-strings-and-characters" class="h1" data-line="215" data-heading-depth="1" style="display:block"><span data-line="215"></span><span class="heading-before"><span class="heading-label">6</span>.&#8194;</span><span data-line="215"></span>Strings and Characters</h2>
<p class="p noindent" data-line="218"><span data-line="218"></span>String literals can be written in quotes, using the same escapes as in Java.
Strings support several operations, including <span data-line="219"></span><code class="code code1">==</code><span data-line="219"></span>, <span data-line="219"></span><code class="code code1">&lt;</code><span data-line="219"></span>, <span data-line="219"></span><code class="code code1">&gt;</code><span data-line="219"></span>, <span data-line="219"></span><code class="code code1">length()</code><span data-line="219"></span>,
and <span data-line="220"></span><code class="code code1">charAt(Int)</code><span data-line="220"></span>.  The last of these returns a <span data-line="220"></span><code class="code code1">Character</code><span data-line="220"></span>, which supports
<span data-line="221"></span><code class="code code1">==</code><span data-line="221"></span>, <span data-line="221"></span><code class="code code1">&lt;</code><span data-line="221"></span>, and <span data-line="221"></span><code class="code code1">&gt;</code><span data-line="221"></span> operations.  A simple program illustrating these is in
<span data-line="222"></span><code class="code code1">examples/introductory/strings.wyv</code><span data-line="222"></span>
</p>
<p class="p indent" data-line="224"><span data-line="224"></span>Wyvern will support character literals but doesn<span data-line="224"></span>&#39;<span data-line="224"></span>t yet.
</p><h2 id="sec-anonymous-functions-as-objects" class="h1" data-line="227" data-heading-depth="1" style="display:block"><span data-line="227"></span><span class="heading-before"><span class="heading-label">7</span>.&#8194;</span><span data-line="227"></span>Anonymous Functions as Objects</h2>
<pre class="para-block pre-indented" data-line="230" style="display:block"><code></code></pre>
<p class="p noindent para-continued" data-line="230"><span data-line="230"></span>The anonymous function syntax described above is actually
a shorthand for creating an object with an <span data-line="231"></span><code class="code code1">apply</code><span data-line="231"></span> method
that has the same arguments and body:
</p>
<pre class="para-block pre-indented" data-line="234" style="display:block"><code>new
    def apply(x:Int):Int = x + 1</code></pre>
<p class="p noindent para-continued" data-line="237"><span data-line="237"></span>which is an instance of the following type:
</p>
<pre class="para-block pre-indented" data-line="239" style="display:block"><code>type IntToIntFn
    def apply(x:Int):Int</code></pre>
<p class="p noindent para-continued" data-line="242"><span data-line="242"></span>As mentioned earlier, the type above can be abbreviated <span data-line="242"></span><code class="code code1">Int -&gt; Int</code><span data-line="242"></span>,
as in many other languages with good support for functional programming.
</p><h2 id="sec-mutable-state-and-resource-types" class="h1" data-line="246" data-heading-depth="1" style="display:block"><span data-line="246"></span><span class="heading-before"><span class="heading-label">8</span>.&#8194;</span><span data-line="246"></span>Mutable State and Resource Types</h2>
<p class="p noindent" data-line="249"><span data-line="249"></span>Types with mutable state can be defined, but need to be marked as
<span data-line="250"></span><code class="code code1">resource</code><span data-line="250"></span> types (<span data-line="250"></span><code class="code code1">examples/introductory/cell.wyv</code><span data-line="250"></span>):
</p>
<pre class="para-block pre-indented" data-line="252" style="display:block"><code>resource type Cell
    def set(newValue:Int):Unit
    def get():Int

def makeCell(initVal:Int):Cell = new
    var value : Int = initVal
    def set(newValue:Int):Unit
        this.value = newValue
    def get():Int = this.value

val c = makeCell(5)
c.get() // evalutes to 5
c.set(3)
c.get() // evalutes to 3</code></pre>
<p class="p noindent para-continued" data-line="267"><span data-line="267"></span>Here <span data-line="267"></span><code class="code code1">makeCell</code><span data-line="267"></span> uses a <span data-line="267"></span><code class="code code1">new</code><span data-line="267"></span> statement to create an object with a <span data-line="267"></span><code class="code code1">var</code><span data-line="267"></span>
field <span data-line="268"></span><code class="code code1">value</code><span data-line="268"></span>.  <span data-line="268"></span><code class="code code1">var</code><span data-line="268"></span> fields are assignable, so the <span data-line="268"></span><code class="code code1">set</code><span data-line="268"></span> funtion is
implemented to assign the <span data-line="269"></span><code class="code code1">value</code><span data-line="269"></span> field of the receiver object <span data-line="269"></span><code class="code code1">this</code><span data-line="269"></span> to
the passed-in argument.  Note that we must initialize a <span data-line="270"></span><code class="code code1">var</code><span data-line="270"></span> field with
an initial value.  If we had not declared <span data-line="271"></span><code class="code code1">Cell</code><span data-line="271"></span> to be a <span data-line="271"></span><code class="code code1">resource</code><span data-line="271"></span>
type, we would get an error because the <span data-line="272"></span><code class="code code1">new</code><span data-line="272"></span> expression creates a
stateful object that is a resource.
</p>
<p class="p indent" data-line="275"><span data-line="275"></span>In the example above, <span data-line="275"></span><code class="code code1">Unit</code><span data-line="275"></span> is used as the return type of functions
that do not return any interesting value.
</p><h2 id="sec-modules" class="h1" data-line="279" data-heading-depth="1" style="display:block"><span data-line="279"></span><span class="heading-before"><span class="heading-label">9</span>.&#8194;</span><span data-line="279"></span>Modules</h2>
<p class="p noindent" data-line="282"><span data-line="282"></span>We can define the <span data-line="282"></span><code class="code code1">Cell</code><span data-line="282"></span> abstraction above in a module (<span data-line="282"></span><code class="code code1">examples/modules/cell.wyv</code><span data-line="282"></span>):
</p>
<pre class="para-block pre-indented" data-line="284" style="display:block"><code>module cell

resource type Cell
    def set(newValue:Int):Unit
    def get():Int

def make(initVal:Int):Cell = new
    var value : Int = initVal
    def set(newValue:Int):Unit
        this.value = newValue
    def get():Int = this.value</code></pre>
<p class="p noindent para-continued" data-line="296"><span data-line="296"></span>In Wyvern, analogously to Java, a module named <span data-line="296"></span><code class="code code1">m</code><span data-line="296"></span> should be stored in
a file <span data-line="297"></span><code class="code code1">m.wyv</code><span data-line="297"></span> (we expect that the implementation will enforce this in
the near future).  The file system forms a hierarchical namespace with one
name per directory that allows us to find modules by their qualified
name.  In this case, within the <span data-line="300"></span><code class="code code1">examples</code><span data-line="300"></span> directory of the Wyvern
distribution we have the directory <span data-line="301"></span><code class="code code1">modules</code><span data-line="301"></span> that contains <span data-line="301"></span><code class="code code1">cell.wyv</code><span data-line="301"></span>,
so we can use it in a program as follows (see <span data-line="302"></span><code class="code code1">examples/modules/cellClient.wyv</code><span data-line="302"></span>):
</p>
<pre class="para-block pre-indented" data-line="304" style="display:block"><code>import modules.cell

val myCell : cell.Cell = cell.make(3)
myCell.set(7)
myCell.get() // evalutes to 7
</code></pre>
<p class="p noindent para-continued" data-line="310"><span data-line="310"></span>Here the import statement takes a fully qualified name and uses this to
find the file defining module <span data-line="311"></span><code class="code code1">cell</code><span data-line="311"></span>.  The module is actually an object
that gets bound to the name <span data-line="312"></span><code class="code code1">cell</code><span data-line="312"></span>.  We can invoke <span data-line="312"></span><code class="code code1">make()</code><span data-line="312"></span> on <span data-line="312"></span><code class="code code1">cell</code><span data-line="312"></span>
just as if it were a method.  Types such as <span data-line="313"></span><code class="code code1">Cell</code><span data-line="313"></span> defined in the <span data-line="313"></span><code class="code code1">cell</code><span data-line="313"></span>
module can be referred to by their qualified names, i.e. <span data-line="314"></span><code class="code code1">cell.Cell</code><span data-line="314"></span>.
In fact, types can be defined as members of an object as well, and the
same qualified syntax can be used to refer to them.  So modules are not
special semantically: they are just a convenient syntax for defining an
object.  Consider what is the type of <span data-line="318"></span><code class="code code1">cell</code><span data-line="318"></span>?  The answer could be
written as follows:
</p>
<pre class="para-block pre-indented" data-line="321" style="display:block"><code>type TCell
    resource type Cell
        def set(newValue:Int):Unit
        def get():Int
    
    def make(initVal:Int):this.Cell</code></pre>
<p class="p noindent para-continued" data-line="328"><span data-line="328"></span>Wyvern files that define a type use a <span data-line="328"></span><code class="code code1">.wyt</code><span data-line="328"></span> extension (for Wyvern Type),
and you can find the above definition at <span data-line="329"></span><code class="code code1">examples/modules/TCell.wyt</code><span data-line="329"></span>.
</p><h2 id="sec-resource-modules" class="h1" data-line="332" data-heading-depth="1" style="display:block"><span data-line="332"></span><span class="heading-before"><span class="heading-label">10</span>.&#8194;</span><span data-line="332"></span>Resource Modules</h2>
<p class="p noindent" data-line="335"><span data-line="335"></span>Just as objects with state must be given a resource type, stateful
modules have a resource type.  A <span data-line="336"></span><code class="code code1">resource</code><span data-line="336"></span> module is one that captures
state in its implementation.  The <span data-line="337"></span><code class="code code1">cell</code><span data-line="337"></span> module is not a <span data-line="337"></span><code class="code code1">resource</code><span data-line="337"></span>
module; although it can be used to create stateful <span data-line="338"></span><code class="code code1">Cell</code><span data-line="338"></span>s, the module
itself does not capture state.  Here is a module that does (<span data-line="339"></span><code class="code code1">examples/modules/cellAsModule.wyv</code><span data-line="339"></span>):
</p>
<pre class="para-block pre-indented" data-line="341" style="display:block"><code>module def cellAsModule()

var value : Int = 0
def set(newValue:Int):Unit
    value = newValue
def get():Int = value</code></pre>
<p class="p noindent para-continued" data-line="348"><span data-line="348"></span>Wyvern does not allow implicitly shared global state, because this
often causes problems in software development.  So <span data-line="349"></span><code class="code code1">cellAsModule</code><span data-line="349"></span> does
not evaluate to an object, but rather a function that, when invoked,
yields a fresh object with its own copy of the internal state defined
by the module.  The <span data-line="352"></span><code class="code code1">module def</code><span data-line="352"></span> syntax indicates this; it is reminiscent
of the <span data-line="353"></span><code class="code code1">def</code><span data-line="353"></span> syntax for defining functions.  We will call functions that
produce modules functors, after Standard ML (and inspired by category
theory, for the mathematically inclined).  We can use <span data-line="355"></span><code class="code code1">cellAsModule</code><span data-line="355"></span> in
a program as follows (<span data-line="356"></span><code class="code code1">examples/modules/cellModuleClient.wyv</code><span data-line="356"></span>):
</p>
<pre class="para-block pre-indented" data-line="358" style="display:block"><code>import modules.cellAsModule

val m1 = cellAsModule()    
val m2 = cellAsModule()
m1.set(1)
m2.set(2)
m1.get() // evalutes to 1
m2.get() // evalutes to 2</code></pre>
<p class="p noindent para-continued" data-line="367"><span data-line="367"></span>In this example you can see that we have instantiated the <span data-line="367"></span><code class="code code1">resource</code><span data-line="367"></span>
module <span data-line="368"></span><code class="code code1">cellAsModule</code><span data-line="368"></span> twice, and each instance of the module has its
own internal state.
</p>
<pre class="para-block pre-indented" data-line="372" style="display:block"><code></code></pre><h2 id="sec-module-parameters" class="h1" data-line="372" data-heading-depth="1" style="display:block"><span data-line="372"></span><span class="heading-before"><span class="heading-label">11</span>.&#8194;</span><span data-line="372"></span>Module Parameters</h2>
<p class="p noindent" data-line="375"><span data-line="375"></span>If resource modules are produced by functors (module functions), we
expect to be able to pass
parameters<span data-line="377"></span>&#8211;<span data-line="377"></span>and so we can.  First let<span data-line="377"></span>&#39;<span data-line="377"></span>s define the type that
<span data-line="378"></span><code class="code code1">cellAsModule</code><span data-line="378"></span> returns.  For convenience, we will put this type in a
file <span data-line="379"></span><code class="code code1">TCellAsModule.wyt</code><span data-line="379"></span> (here <span data-line="379"></span><code class="code code1">.wyt</code><span data-line="379"></span> stands for Wyvern Type):
</p>
<pre class="para-block pre-indented" data-line="381" style="display:block"><code>resource type TCellAsModule
    def set(newValue:Int):Unit
    def get():Int</code></pre>
<p class="p noindent para-continued" data-line="385"><span data-line="385"></span>Here is a client of the cellAsModule (<span data-line="385"></span><code class="code code1">examples/modules/cellClientFunctor.wyv</code><span data-line="385"></span>):
</p>
<pre class="para-block pre-indented" data-line="387" style="display:block"><code>module def cellClientFunctor(cell : modules.TCellAsModule)

def addOne():Unit
    cell.set(cell.get()+1)
    
def getValue():Int = cell.get()
</code></pre>
<p class="p noindent para-continued" data-line="394"><span data-line="394"></span>We can put module parameters in between the parentheses in the definition
of the functor, specifying the type in the usual way.
</p>
<p class="p indent" data-line="397"><span data-line="397"></span>Now we can use <span data-line="397"></span><code class="code code1">cellAsModule</code><span data-line="397"></span> together with <span data-line="397"></span><code class="code code1">cellClientFunctor</code><span data-line="397"></span> in a program (<span data-line="397"></span><code class="code code1">examples/modules/cellClientMain.wyv</code><span data-line="397"></span>):
</p>
<pre class="para-block pre-indented" data-line="399" style="display:block"><code>import myPackage.cellAsModule
import myPackage.cellClientFunctor

val client = cellClientFunctor(cellAsModule())
client.addOne()
client.getValue() // evalutes to 1</code></pre><h2 id="sec-dynamic-types" class="h1" data-line="407" data-heading-depth="1" style="display:block"><span data-line="407"></span><span class="heading-before"><span class="heading-label">12</span>.&#8194;</span><span data-line="407"></span>Dynamic Types</h2>
<p class="p noindent" data-line="410"><span data-line="410"></span>Wyvern is intended to be a mostly statically typed language.  However,
while getting parameterized types to work, we implemented a <span data-line="411"></span><code class="code code1">Dyn</code><span data-line="411"></span> type that
partially implements dynamic types.  Specifically, <span data-line="412"></span><code class="code code1">Dyn</code><span data-line="412"></span> is a subtype
of any type, and any type is a subtype of <span data-line="413"></span><code class="code code1">Dyn</code><span data-line="413"></span>.  (Note that subtyping
is not transitive where <span data-line="414"></span><code class="code code1">Dyn</code><span data-line="414"></span> is involved, as this would effectively
collapse the type system to a single type.)
</p>
<p class="p indent" data-line="417"><span data-line="417"></span>We recommend avoiding <span data-line="417"></span><code class="code code1">Dyn</code><span data-line="417"></span> where possible, and gradually transitioning
existing <span data-line="418"></span><code class="code code1">Dyn</code><span data-line="418"></span> code to remove use of this construct.  If we do keep this
in the long term, we need to think about how it interacts with resource
types.
</p><h2 id="sec-declaration-sequences-and-mutual-recursion" class="h1" data-line="423" data-heading-depth="1" style="display:block"><span data-line="423"></span><span class="heading-before"><span class="heading-label">13</span>.&#8194;</span><span data-line="423"></span>Declaration Sequences and Mutual Recursion</h2>
<p class="p noindent" data-line="426"><span data-line="426"></span>Programs are made up of four kinds of core
declarations: <span data-line="427"></span><code class="code code1">val</code><span data-line="427"></span>, <span data-line="427"></span><code class="code code1">var</code><span data-line="427"></span>, <span data-line="427"></span><code class="code code1">def</code><span data-line="427"></span>, and <span data-line="427"></span><code class="code code1">type</code><span data-line="427"></span>, as well as expressions.
The <span data-line="428"></span><code class="code code1">val</code><span data-line="428"></span> and <span data-line="428"></span><code class="code code1">var</code><span data-line="428"></span> declarations and the expressions in a program
are evaluated
in sequence, and the variables defined earlier in the sequence are
in scope in later declarations and expressions.  In contrast,
<span data-line="432"></span><code class="code code1">def</code><span data-line="432"></span> and <span data-line="432"></span><code class="code code1">type</code><span data-line="432"></span> declarations do not evaluate, and therefore these
declaration forms can be safely used to define mutually recursive
functions and types.  Each sequence of declarations that consists
exclusively of <span data-line="435"></span><code class="code code1">def</code><span data-line="435"></span> and <span data-line="435"></span><code class="code code1">type</code><span data-line="435"></span> is therefore treated as a mutually
recursive block, so that the definition or type defined in each of
the declarations is in scope in all the other declarations.
</p>
<p class="p indent" data-line="439"><span data-line="439"></span>To understand why we allow recursive <span data-line="439"></span><code class="code code1">def</code><span data-line="439"></span> and <span data-line="439"></span><code class="code code1">type</code><span data-line="439"></span> declarations
but do not allow this for <span data-line="440"></span><code class="code code1">val</code><span data-line="440"></span> and <span data-line="440"></span><code class="code code1">var</code><span data-line="440"></span> declarations, consider
the following example:
</p>
<pre class="para-block pre-indented" data-line="443" style="display:block"><code>// NOTE: this example does not typecheck
type IntCell
    def get():Int

def foo():IntCell = baz()
val bar:IntCell = foo()
def baz():IntCell = bar

bar.get()</code></pre>
<p class="p noindent para-continued" data-line="453"><span data-line="453"></span>When we try to initialize the <span data-line="453"></span><code class="code code1">bar</code><span data-line="453"></span> value, we call <span data-line="453"></span><code class="code code1">foo()</code><span data-line="453"></span>, which in
turn invokes <span data-line="454"></span><code class="code code1">baz()</code><span data-line="454"></span>.  However, <span data-line="454"></span><code class="code code1">baz()</code><span data-line="454"></span> reads the <span data-line="454"></span><code class="code code1">bar</code><span data-line="454"></span> variable, which
is what we are defining, so there is no well-defined result.  Languages
such as Java handle this by initializing <span data-line="456"></span><code class="code code1">bar</code><span data-line="456"></span> to <span data-line="456"></span><code class="code code1">null</code><span data-line="456"></span> at first and
then writing a permanent value to it after the initializer executes.
However, in order to avoid null pointer errors, Wyvern does not allow
<span data-line="459"></span><code class="code code1">null</code><span data-line="459"></span> as a value.  Languages such as Haskell would use a special
<span data-line="460"></span>&#8220;black hole&#8221;<span data-line="460"></span> value and signal a run-time error if the black hole is
ever used, as in the <span data-line="461"></span><code class="code code1">bar.get</code><span data-line="461"></span> statement at the end.
We avoid this semantics as it adds complexity and means the
program can fail at run time.  Of course, infinite loops can still
exist in Wyvern, but they come from recursive functions, never
recursively defined values.
</p><h2 id="sec-some-more-examples" class="h1" data-line="468" data-heading-depth="1" style="display:block"><span data-line="468"></span><span class="heading-before"><span class="heading-label">14</span>.&#8194;</span><span data-line="468"></span>Some More Examples</h2>
<p class="p noindent" data-line="471"><span data-line="471"></span>The Wyvern standard library files are in subdirectories of <span data-line="471"></span><code class="code code1">stdlib</code><span data-line="471"></span>.  For example, earlier we used the <span data-line="471"></span><code class="code code1">IfTSL</code><span data-line="471"></span> library, defined in <span data-line="471"></span><code class="code code1">stdlib/wyvern/IfTSL.wyv</code><span data-line="471"></span>.
</p>
<p class="p indent" data-line="473"><span data-line="473"></span>Platform-specific definitions are in the <span data-line="473"></span><code class="code code1">platform</code><span data-line="473"></span> subdirectory of <span data-line="473"></span><code class="code code1">stdlib</code><span data-line="473"></span>, in a sub-subdirectory named after the platform (e.g. <span data-line="473"></span><code class="code code1">java</code><span data-line="473"></span>).
For example, <span data-line="474"></span><code class="code code1">stdout</code><span data-line="474"></span> is defined in <span data-line="474"></span><code class="code code1">stdlib/platform/java/stdout.wyv</code><span data-line="474"></span> for the <span data-line="474"></span><code class="code code1">java</code><span data-line="474"></span> platform; there is an analogous definition for the <span data-line="474"></span><code class="code code1">python</code><span data-line="474"></span> platform too.  The definition of <span data-line="474"></span><code class="code code1">stdout</code><span data-line="474"></span> for <span data-line="474"></span><code class="code code1">java</code><span data-line="474"></span> uses some Java helper code defined in the Java class <span data-line="474"></span><code class="code code1">wyvern.stdlib.support.Stdio</code><span data-line="474"></span>.
</p>
<p class="p indent" data-line="476"><span data-line="476"></span>An example of a utility library that provides a small part of a regular expression package is in <span data-line="476"></span><code class="code code1">wyvern/util/matching/regex.wyv</code><span data-line="476"></span>.  The design approximately follows the corresponding Scala library.
</p>
<p class="p indent" data-line="478"><span data-line="478"></span>An example of a data structure library is <span data-line="478"></span><code class="code code1">wyvern/collections/list.wyv</code><span data-line="478"></span>.  Also see <span data-line="478"></span><code class="code code1">wyvern/option.wyv</code><span data-line="478"></span>.
</p>
<p class="p indent" data-line="480"><span data-line="480"></span>All of the above examples are tested by the Wyvern regression test suite that is run as part of <span data-line="480"></span><code class="code code1">ant test</code><span data-line="480"></span> when building Wyvern.
</p><span data-line=""></span></div>
</body>

</html>
