Wyvern blog post structure
--------------------------

Introductory post (1000 words)
 - goals of wyvern (security + productivity)
 - key insight: express/enforce large-scale design in a usable way (Usable design-driven assurance)
   - hierarchical information hiding + dynamic instantiation and linking
   - architectural constraints
     - resource use (what and how)
     - module dependencies
     - control of side effects
   - domain-specific languages and models
     - for architecture in a domain, but also for embedded languages
 - design features
   - first-class, decidable module system supporting abstract types
   - capability safety: best 
   - immutability; currently adding effect system
   - embedded DSL support; using this to build architecture
 - why other languages don't do this
 - why extending other languages isn't enough
   - synergies
 - draw from SE, PL, HCI disciplines: what each gives
 - (follow-on work: extensible checking, gradual verification)
 
 
Later posts
 - Complimentary roles of engineering and science (and in particular, PL, SE, and HCI disciplines) in language design
 - basic programming in Wyvern
 - object model
 - modules
 - type system
 - effects
 - capability safety
 - immutability
 - extensible notation
 - architecture
 - synergies in Wyvern's design
