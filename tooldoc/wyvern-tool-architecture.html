<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
  <meta name="generator" content="Madoko, version 0.9.2-beta" />
  <meta name="viewport" content="initial-scale=1.0" />
  <meta name="author" content="Jonathan Aldrich" />
  <title>The Architecture of the Wyvern Language TOols</title>
  <style  class="link">
/* ---------------------------------------------------
   Various settings to display madoko elements correctly.
   For example, lines in tables or a table of contents.

   All rules use specific madoko classes and never just
   a generic element. This means one can safely include
   this CSS into any web page without affecting non-madoko
   content.
----------------------------------------------------*/

/* The table of  contents */
.madoko .toc>.tocblock .tocblock .tocblock {
  margin-left: 2.5em;
}

.madoko .toc>.tocblock .tocblock {
  margin-left: 1.7em;
}

.madoko .toc>.tocblock>.tocitem {
  font-weight: bold;
}

.madoko .toc {
  margin-top: 1em;
}

/* Paragraphs */
.madoko p.para-continue {
  margin-bottom: 0pt;
}

.madoko .para-block+p {
  margin-top: 0pt;
}

.madoko ul.para-block, .madoko ol.para-block {
  margin-top: 0pt;
  margin-bottom: 0pt;
}

.madoko ul.para-end, .madoko ol.para-end {
  margin-bottom: 1em;
}

.madoko dl {
  margin-left: 0em;
}

.madoko blockquote {
  border-left: 5px Gainsboro solid;
  padding-left: 1ex;
  margin-left: 1em;
}

/* Local page links do not get an underline unless hovering */
.madoko a.localref {
  text-decoration: none;
}
.madoko a.localref:hover {
  text-decoration: underline;
}

/* Footnotes */
.madoko .footnotes {
  font-size: smaller;
  margin-top: 2em;
}

.madoko .footnotes hr {
  width: 50%;
  text-align: left;
}

.madoko .footnote { 
  margin-left: 1em;
}
.madoko .footnote-before {
  margin-left: -1em;
  width: 1em;
  display: inline-block;
}

/* Abstract */
.madoko .abstract>p:first-child:before {
  content: "Abstract. ";
  font-weight: bold;
}

.madoko .abstract {
  margin-left: 2.7em;
  margin-right: 2.7em;
  font-size: small;
}


/* Alignment */
.madoko .align-center, .madoko .align-center>p {
  text-align: center !important;
}

.madoko .align-center pre {
  text-align: left;
}

.madoko .align-center>* {
  margin-left: auto !important;
  margin-right: auto !important;
}

.madoko .align-left, .madoko .align-left>p {
  text-align: left !important;
}

.madoko .align-left>* {
  margin-left: 0pt !important;
  margin-right: auto !important;
}

.madoko .align-right, .madoko .align-right>p {
  text-align: right !important;
}

.madoko .align-right>* {
  margin-left: auto !important;
  margin-right: 0pt !important;
}

.madoko .align-center>table,
.madoko .align-left>table,
.madoko .align-right>table {
  text-align: left !important;
}


/* Equations, Figure's etc. */
.madoko .equation-before {
  float: right;
}


/* Bibliography */
.madoko .bibitem {
  font-size: smaller;
}

.madoko .bib-numeric .bibitem {
  margin-left: 3em;
  text-indent: -3em;
}

.madoko .bibitem-before {
  display: none;
}

.madoko .bib-numeric .bibitem-before {
  display: inline-block;
  width: 3em;
  text-align: right;
}

.madoko .bibliography {
}

.madoko .bibsearch {
  font-size: x-small;
  text-decoration:none;
  color: black;
  font-family: "Segoe UI Symbol", Symbola;
}

/* General */
.madoko .block, .madoko .figure, .madoko .bibitem, .madoko .equation, .madoko div.math {
  margin-top: 1ex;
  margin-bottom: 1ex;
}

.madoko .figure {
  padding: 0.5em;
  margin-left: 0pt;
  margin-right: 0pt;
}

.madoko .hidden {
  display: none;
}

.madoko .invisible {
  visibility: hidden;
}

.madoko.preview .invisible {
  visibility: visible;
  opacity: 0.5;
}

.madoko code.code, .madoko span.code {
  white-space: pre-wrap;
}

.madoko hr, hr.madoko {
  border: none;
  border-bottom: black solid 1px;
  margin-bottom: 0.5ex;
}

.madoko .framed>*:first-child {
  margin-top: 0pt;
}
.madoko .framed>*:last-child {
  margin-bottom: 0pt;
}


/* Title, authors */
.madoko .title {
  font-size: xx-large;
  font-weight: bold;
  margin-bottom: 1ex;
}

.madoko .subtitle {
  font-size: x-large;
  margin-bottom: 1ex;
  margin-top: -1ex;
}

.madoko .titleblock>* {
  margin-left: auto;
  margin-right: auto;
  text-align: center;
}

.madoko .titleblock table {
  width: 80%;
}

.madoko .authorblock .author {
  font-size: large;
}

.madoko .titlenote {
  margin-top: -0.5ex;
  margin-bottom: 1.5ex;
}

/* Lists */

.madoko ul.list-star {
  list-style-type: disc;
}

.madoko ul.list-dash {
    list-style-type: none !important;
}

.madoko ul.list-dash > li:before {
    content: "\2013"; 
    position: absolute;
    margin-left: -1em; 
}

.madoko ul.list-plus {
  list-style-type: square;
}

/* Tables */
.madoko table.madoko {
  border-collapse: collapse;
}
.madoko td, .madoko th {
  padding: 0ex 0.5ex;
  margin: 0pt;
  vertical-align: top;
}

.madoko .cell-border-left {
  border-left: 1px solid black;
}
.madoko .cell-border-right {
  border-right: 1px solid black;
}


.madoko thead>tr:first-child>.cell-line,
.madoko tbody:first-child>tr:first-child>.cell-line {
  border-top: 1px solid black;
  border-bottom: none;
}

.madoko .cell-line, .madoko .cell-double-line {
  border-bottom: 1px solid black;
  border-top: none;
}

.madoko .cell-double-line {
  border-top: 1px solid black;
  padding-top: 1.5px !important;
}


/* Math Pre */
.madoko .input-mathpre .MathJax_Display {
  text-align: left !important;
}

.madoko div.input-mathpre {
  text-align: left;
  margin-top: 1.5ex;
  margin-bottom: 1ex;
}

.madoko .math-rendering {
  color: gray;
}

/* Math */
.madoko .mathdisplay {
  text-align: center;
}


/*---------------------------------------------------------------------------
  Default style for syntax highlighting
---------------------------------------------------------------------------*/

.highlighted                        { color: black; }
.highlighted .token.identifier      { }
.highlighted .token.operators       { }
.highlighted .token.keyword         { color: blue }
.highlighted .token.string          { color: maroon } 
.highlighted .token.string.escape   { color: gray }
.highlighted .token.comment         { color: darkgreen }
.highlighted .token.comment.doc     { font-style: normal }
.highlighted .token.constant        { color: purple; }
.highlighted .token.entity          {  }
.highlighted .token.tag             { color: blue }
.highlighted .token.info-token      { color: black }
.highlighted .token.warn-token      { color: black }
.highlighted .token.error-token     { color: darkred }
.highlighted .token.debug-token     { color: gray }
.highlighted .token.regexp          { color: maroon }
.highlighted .token.attribute.name  { color: navy }
.highlighted .token.attribute.value { color: maroon }
.highlighted .token.constructor     { color: purple }
.highlighted .token.namespace       { color: navy }
.highlighted .token.header          { color: navy }
.highlighted .token.type            { color: teal } 
.highlighted .token.type.delimiter  { color: teal; } 
.highlighted .token.predefined      { color: navy }
.highlighted .token.invalid         { border-bottom: red dotted 1px }
.highlighted .token.code            { color: maroon }
.highlighted .token.code.keyword    { color: navy }
.highlighted .token.typevar         { font-style: italic; }

.highlighted .token.delimiter   {  } /* .[curly,square,parenthesis,angle,array,bracket] */
.highlighted .token.number      {  }    /* .[hex,octal,binary,float] */
.highlighted .token.variable    {  }  /* .[name,value]  */
.highlighted .token.meta        { color: navy }      /* .[content] */

.highlighted .token.bold            { font-weight: bold; }
.highlighted .token.italic          { font-style: italic; }


/* Pretty formatting of code */
.madoko pre.pretty, .madoko code.pretty { 
  font-family: Cambria,Times,Georgia,serif;
  font-size: 100%;
}

.madoko .pretty table {
  border-collapse: collapse;
}
.madoko .pretty td {
  padding: 0em;
}
.madoko .pretty td.empty {
  min-width: 1.5ex;
}
.madoko .pretty td.expander {
  width: 100em;
}
.madoko .pretty .token.identifier         { font-style: italic }
.madoko .pretty .token.constructor        { font-style: italic }


/* ---------------------------------------------------
   Styling for full documents
----------------------------------------------------*/
body.madoko, .madoko-body {
  font-family: Cambria,"Times New Roman","Liberation Serif","Times",serif;
  -webkit-text-size-adjust: 100%; /* so math displays well on mobile devices */
}

body.madoko, .madoko-body {
  padding: 0em 2em;
  max-width: 88ex; /* about 88 characters */
  margin: 1em auto;
}

body.madoko.preview {
  padding: 0em 1em;
}

.madoko p,
.madoko li {
  text-align: justify;
}

/* style headings nicer, especially h5 and h6 */
.madoko h1, .madoko h2, .madoko h3, .madoko h4 { 
  margin-top: 1.22em; 
  margin-bottom: 1ex;
}
.madoko h1+p, .madoko h2+p, .madoko h3+p, .madoko h4+p, .madoko h5+p  { 
  margin-top: 1ex;    
}
.madoko h5, .madoko h6 { 
  margin-top: 1ex;
  font-size: 1em;
}
.madoko h5 { 
  margin-bottom: 0.5ex;
}
.madoko h5 + p {
  margin-top: 0.5ex;
}
.madoko h6 { 
  margin-bottom: 0pt;
}
.madoko h6 + p {
  margin-top: 0pt;
}


/* Fix monospace display (see http://code.stephenmorley.org/html-and-css/fixing-browsers-broken-monospace-font-handling/) */
.madoko pre, .madoko code, .madoko kbd, .madoko samp, .madoko tt, .madoko .monospace, .madoko .token.indent, .madoko .reveal pre, .madoko .reveal code, .madoko .email {
  font-family: Consolas,"Andale Mono WT","Andale Mono",Lucida Console,Monaco,monospace,monospace;
  font-size: 0.85em;
}
.madoko pre code, .madoko .token.indent {
  font-size: 0.95em;
}

.madoko pre code {
  font-family: inherit !important;
}

/* Code prettify */
.madoko ol.linenums li {
  background-color: white;
  list-style-type: decimal;
}

/* Merging */
.madoko .remote {
  background-color: #F0FFF0;
}
.madoko .remote + * {
  margin-top: 0pt;
}

/* ---------------------------------------------------
   Print settings
----------------------------------------------------*/

@media print {
  body.madoko, .madoko-body {
    font-size: 10pt;
  }
  @page {
    margin: 1in 1.5in;
  }
}

/* ---------------------------------------------------
   Mobile device settings
----------------------------------------------------*/

@media only screen and (max-device-width:1024px) {
  body.madoko, .madoko-body {
    padding: 0em 1em;
  }
}

  </style>

</head>
<body class="madoko madoko-body">


<div class="mathdefs hidden input-mathdefs" data-line="7"></div><h2 id="sec-building-wyvern"  data-line="11"  style="bookmark:1.&#8194;Building Wyvern"><span data-line="11"></span><span class="heading-before"><span class="heading-label">1</span>.&#8194;</span><span data-line="11"></span>Building Wyvern</h2>
<p class="para-continue" data-line="13"><span data-line="13"></span>The Wyvern tooling is available in the wyvern repository on GitHub at
<span data-line="14"></span><a href="https://github.com/wyvernlang/wyvern">https://github.com/wyvernlang/wyvern</a><span data-line="14"></span>  To build Wyvern, you
will need to clone the repository and install the tools on which Wyvern
depends.  These are:
</p>
<ul class="ul list-star compact" data-line="18">
<li class="li ul-li list-star-li compact-li" data-line="18"><span data-line="18"></span>Java 8
</li>
<li class="li ul-li list-star-li compact-li" data-line="19"><span data-line="19"></span>ant 1.9.0 (or higher)
</li></ul>

<p data-line="21"><span data-line="21"></span>Once these are installed and available on the system path, you can
build and test the Wyvern tools by running
</p>
<pre class="para-block pre-indented" data-line="24"><code>ant test
</code></pre>
<p data-line="26"><span data-line="26"></span>To use the Eclipse IDE, first make sure you have built the system
using ant: this will generate java files for the Wyvern lexer and
parser.  Then you can import the existing project in the tools
subdirectory into your workspace.  Right-click on your project,
choose Properties, go to the Java Compiler tab, and make JDK
compliance is set to 1.8 (enable project-specific settings
if necessary).
</p>
<p class="indent" data-line="34"><span data-line="34"></span>To run the regression test suite directly via JUnit or an IDE,
go to the package wyvern.tools.tests.suites and run
AntRegressionTestSuite as a JUnit test.  All regression tests
in this suite should run correctly.  However, some tests that
are excluded from the AntRegressionTestSuite (either by not
including them explicitly, or by marking them in
<span data-line="40"></span><code class="code code1">@Category(CurrentlyBroken.class)</code><span data-line="40"></span>) may fail, because they
describe bugs that were discovered but not yet fixed or
functionality we know we want to support but we have
not yet implemented.
</p>
<p class="indent" data-line="45"><span data-line="45"></span>Every time you edit the parser specifications, or pull changes
that affect the parser specifications, you will need to re-run
<span data-line="47"></span>&#8220;ant test&#8221;<span data-line="47"></span> and then right-click on the project and type refresh.
</p><h2 id="sec-overall-architecture"  data-line="51"  style="bookmark:2.&#8194;Overall Architecture"><span data-line="51"></span><span class="heading-before"><span class="heading-label">2</span>.&#8194;</span><span data-line="51"></span>Overall Architecture</h2>
<p class="para-continue" data-line="54"><span data-line="54"></span>Like many language tools, the Wyvern interpreter is structured as a
pipeline.  The stages of the front end are as follows:
</p>
<ol class="ol compact" data-line="57">
<li class="li ol-li compact-li" data-line="57"><span data-line="57"></span><strong>Lexing</strong><span data-line="57"></span>: producing a sequence of tokens from textual input
</li>
<li class="li ol-li compact-li" data-line="58"><span data-line="58"></span><strong>Parsing</strong><span data-line="58"></span>: producing a high-level AST from a sequence of tokens
</li>
<li class="li ol-li compact-li" data-line="59"><span data-line="59"></span><strong>Intermediate Code Generation</strong><span data-line="59"></span>: producing code in a foundational
intermediate representation.
</li>
<li class="li ol-li compact-li" data-line="61"><span data-line="61"></span><strong>Typechecking</strong><span data-line="61"></span>: ensuring that the generated intermediate
representation typechecks.
</li></ol>

<p data-line="64"><span data-line="64"></span>Wyvern has several back ends.  The main one is simply interpreting the
intermediate representation directly.  However, another pathway compiles
down to a lower-level, partially-typed class-based form, then generates
assembly languages using the LLVM infrastructure.
</p>
<p class="indent" data-line="69"><span data-line="69"></span>As of this writing there is a fair bit of code that is out of date.
This will be removed as the current implementation is more fleshed out,
but is left in the codebase at the moment because it is a good reference
for some of the functionality we are reimplementing.
</p>
<p class="indent" data-line="74"><span data-line="74"></span>The rest of this document will describe each of these stages in turn,
discussing the code by using the processing of the <span data-line="75"></span><code class="code code1">val</code><span data-line="75"></span> concept as
a running example.
</p><h2 id="sec-lexing"  data-line="78"  style="bookmark:3.&#8194;Lexing"><span data-line="78"></span><span class="heading-before"><span class="heading-label">3</span>.&#8194;</span><span data-line="78"></span>Lexing</h2>
<p data-line="81"><span data-line="81"></span>The lexer is implemented based on the Copper parser and scanner generator
(<span data-line="82"></span><a href="http://www.melt.cs.umn.edu/copper/">http://www.melt.cs.umn.edu/copper/</a><span data-line="82"></span>).  Copper was chosen because it
supports context-sensitive, stateful lexing.  Wyvern uses state and a
simple form of context-sensitive lexing both to make indentation-sensitive
syntax easier to process, and to defer lexing for blocks of domain-specific
code.  For documentation on the syntax of Copper, see the Copper website.
</p>
<p class="indent" data-line="88"><span data-line="88"></span>The implementation of lexing is in
<span data-line="89"></span><code class="code code1">tools/src/wyvern/tools/lexing/WyvernLexer.x</code><span data-line="89"></span>  The state used in the
lexer is at the top of the file: we track whether a tilde (<span data-line="90"></span><code class="code code1">~</code><span data-line="90"></span>) symbol
was found in the current line, indicating a DSL block in the next line;
a boolean flag indicating that the next line is a DSL block, and a flag
recording whether we are currently scanning a DSL block.  Finally, there
is a stack of indentation levels for indentation-sensitive syntax.
</p>
<p class="indent" data-line="96"><span data-line="96"></span>A few helper functions at the beginning handle indentation levels,
logical line detection, and token creation.  Tokens are declared in the
usual way; for example see the <span data-line="98"></span><code class="code code1">valKwd_t</code><span data-line="98"></span> token used for the <span data-line="98"></span><code class="code code1">val</code><span data-line="98"></span>
keyword.
</p>
<p class="indent" data-line="101"><span data-line="101"></span>After the tokens, there is a simple parser that detects lines as sequences
of tokens separated by generated indent and newline tokens, with DSL
block tokens embedded as appropriate.  We can find <span data-line="103"></span><code class="code code1">val</code><span data-line="103"></span> in the <span data-line="103"></span><code class="code code1">keyw</code><span data-line="103"></span>
production, which is in turn part of a non-whitespace line element
(<span data-line="105"></span><code class="code code1">nonWSLineElement</code><span data-line="105"></span>).  This element is combined with other elements of
a line to form lines and then programs.
</p>
<p class="indent" data-line="108"><span data-line="108"></span>An example test case that illustrates creating and using the lexer is
<span data-line="109"></span><code class="code code1">wyvern.tools.tests.LexingTests.testDSLBLock1()</code><span data-line="109"></span>, which calls the
<span data-line="110"></span><code class="code code1">checkLex()</code><span data-line="110"></span> function in the same file to parse a string and compare
the tokens generated to the expected token sequence.  Here <span data-line="111"></span><code class="code code1">checkLex()</code><span data-line="111"></span>
simply creates a <span data-line="112"></span><code class="code code1">WyvernLexer</code><span data-line="112"></span> and invokes <span data-line="112"></span><code class="code code1">parse</code><span data-line="112"></span> on it to get a
list of tokens.
</p><h2 id="sec-parsing"  data-line="115"  style="bookmark:4.&#8194;Parsing"><span data-line="115"></span><span class="heading-before"><span class="heading-label">4</span>.&#8194;</span><span data-line="115"></span>Parsing</h2>
<p data-line="118"><span data-line="118"></span>The parser is implemented using JavaCC
(<span data-line="119"></span><a href="https://java.net/projects/javacc">https://java.net/projects/javacc</a><span data-line="119"></span>).  We chose JavaCC because it is
fairly easy to understand and use, generates efficient parsers using
a top-down parsing approach, and (unlike Copper) it can take a stream
of lexical tokens generated by an earlier phase.
</p>
<p class="indent" data-line="124"><span data-line="124"></span>The parser is implemented in
<span data-line="125"></span><code class="code code1">tools/src/wyvern/tools/coreparser/WyvernParser.jj</code><span data-line="125"></span>  The significant
options (shown at the top of the file) are to use our own custom
token manager (which produces tokens from the lexer described above)
and to generate a non-static parser (sacrifices a tiny bit of
performance but makes testing or parallel parsing much easier because
it avoids global state).
</p>
<p class="indent" data-line="132"><span data-line="132"></span>JavaCC requires that we declare our tokens up front, and it generates
a constant for each token in <span data-line="133"></span><code class="code code1">WyvernParserConstants.java</code><span data-line="133"></span>.  We declare
one token for each kind of token produced by the lexer.  The
constants from <span data-line="135"></span><code class="code code1">WyvernParserConstants</code><span data-line="135"></span> are used in <span data-line="135"></span><code class="code code1">WyvernLexer.x</code><span data-line="135"></span> to
construct <span data-line="136"></span><code class="code code1">Token</code><span data-line="136"></span> objects of the type expected by JavaCC.  There is
some code in <span data-line="137"></span><code class="code code1">WyvernTokenManager</code><span data-line="137"></span> and <span data-line="137"></span><code class="code code1">LexerUtils</code><span data-line="137"></span> that identifies
which tokens are <span data-line="138"></span>&#8220;special&#8221;<span data-line="138"></span> (i.e. ignored when parsing<span data-line="138"></span>&#8211;<span data-line="138"></span>things like
comments and whitespace that is not significant for indentation).
</p>
<p class="indent" data-line="141"><span data-line="141"></span>The <span data-line="141"></span><code class="code code1">WyvernParser</code><span data-line="141"></span> is then implemented in standard JavaCC recursive
descent style.  For documentation on the syntax, see the JavaCC
website and examples.  The top-level production is <span data-line="143"></span><code class="code code1">CompilationUnit</code><span data-line="143"></span>.
Each production returns an AST<span data-line="144"></span>&#8211;<span data-line="144"></span>this is a type parameter of
<span data-line="145"></span><code class="code code1">WyvernParser</code><span data-line="145"></span> in order to reduce coupling with the rest of the
codebase, but in practice it is instantiated with the root of the
high-level AST hierarchy, <span data-line="147"></span><code class="code code1">wyvern.tools.typedAST.interfaces.TypeAST</code><span data-line="147"></span>.
From the <span data-line="148"></span><code class="code code1">CompilationUnit</code><span data-line="148"></span> we parse a <span data-line="148"></span><code class="code code1">ModuleBody</code><span data-line="148"></span>, then a
<span data-line="149"></span><code class="code code1">DeclSequence</code><span data-line="149"></span>, then a <span data-line="149"></span><code class="code code1">Declaration</code><span data-line="149"></span>, one case of which is
<span data-line="150"></span><code class="code code1">ValDeclaration</code><span data-line="150"></span>.  We use an abstract factory to build the AST so as
to decouple the parser from AST generation.  The factory is of type
<span data-line="152"></span><code class="code code1">wyvern.tools.parsing.coreparser.ASTBuilder</code><span data-line="152"></span> and the relevant
implementation of this interface is
<span data-line="154"></span><code class="code code1">wyvern.tools.parsing.coreparser.WyvernASTBuilder</code><span data-line="154"></span>.  Notice that when
creating the <span data-line="155"></span><code class="code code1">val</code><span data-line="155"></span> declaration AST element we extract the text location
information from the identifier; this can be used to identify the
location in the source code if errors in this declaration are found
later (e.g. during typechecking).  Here the <span data-line="158"></span><code class="code code1">loc()</code><span data-line="158"></span> helper function
takes the <span data-line="159"></span><code class="code code1">Token</code><span data-line="159"></span> an extracts a <span data-line="159"></span><code class="code code1">FileLocation</code><span data-line="159"></span> object that stores the
filename, line, and column.
</p>
<p class="indent" data-line="162"><span data-line="162"></span>The <span data-line="162"></span><code class="code code1">WyvernASTBuilder</code><span data-line="162"></span>&#39;<span data-line="162"></span>s <span data-line="162"></span><code class="code code1">valDecl</code><span data-line="162"></span> function simply constructs a
<span data-line="163"></span><code class="code code1">wyvern.tools.typedAST.core.declarations.ValDeclaration</code><span data-line="163"></span> object
with the passed-in parameters.
</p>
<p class="indent" data-line="166"><span data-line="166"></span>Use of the parser can be seen in
<span data-line="167"></span><code class="code code1">wyvern.tools.tests.CoreParserTests.testIdentityApp()</code><span data-line="167"></span>, which
creates a <span data-line="168"></span><code class="code code1">WyvernParser</code><span data-line="168"></span> object by using the <span data-line="168"></span><code class="code code1">makeParser</code><span data-line="168"></span>
utility and then parses an expression by calling <span data-line="169"></span><code class="code code1">Expression(null)</code><span data-line="169"></span>
on the result (here the <span data-line="170"></span><code class="code code1">null</code><span data-line="170"></span> argument is used for flags which are
not needed in this test case but are important for parsing uses of
<span data-line="172"></span><code class="code code1">new</code><span data-line="172"></span> in Wyvern).  We would call <span data-line="172"></span><code class="code code1">CompilationUnit()</code><span data-line="172"></span> if we wanted to
parse a whole compilation unit.
</p>
<p class="indent" data-line="175"><span data-line="175"></span>To close the loop, looking at the <span data-line="175"></span><code class="code code1">makeParser</code><span data-line="175"></span> helper, it creates a
<span data-line="176"></span><code class="code code1">WyvernTokenManager</code><span data-line="176"></span> from the input character stream.  This token
manager will in turn create the <span data-line="177"></span><code class="code code1">WyvernLexer</code><span data-line="177"></span> mentioned above.  The
<span data-line="178"></span><code class="code code1">WyvernTokenManager</code><span data-line="178"></span> is passed to a new <span data-line="178"></span><code class="code code1">WyvernParser</code><span data-line="178"></span> object.  We
set the builder to be used to a <span data-line="179"></span><code class="code code1">WyvernASTBuilder</code><span data-line="179"></span> and the
<span data-line="180"></span><code class="code code1">WyvernParser</code><span data-line="180"></span> is ready to parse.
</p><h2 id="sec-intermediate-code-generation"  data-line="183"  style="bookmark:5.&#8194;Intermediate Code Generation"><span data-line="183"></span><span class="heading-before"><span class="heading-label">5</span>.&#8194;</span><span data-line="183"></span>Intermediate Code Generation</h2>
<p data-line="186"><span data-line="186"></span>Intermediate code generation takes a <span data-line="186"></span><code class="code code1">TypedAST</code><span data-line="186"></span> generated by the
parser and generates code in the Wyvern Intermediate Language
(Wyvern IL).  The translation is partially type-based, in that
blocks of intermediate code already produced are typechecked and
the results are used to buide the translation of other parts
(most importantly DSL code blocks).
</p>
<p class="indent" data-line="193"><span data-line="193"></span>The abstract syntax of Wyvern IL is described in
<span data-line="194"></span><code class="code code1">vm-spec.pdf</code><span data-line="194"></span> in the <span data-line="194"></span><code class="code code1">vm</code><span data-line="194"></span> directory of the Wyvern <span data-line="194"></span><code class="code code1">docs</code><span data-line="194"></span>
repository.  Wyvern IL is implemented in the
<span data-line="196"></span><code class="code code1">wyvern.target.corewyvernIL</code><span data-line="196"></span> package and its subpackages.
The design is expressed in UML diagrams in the wyvern repository,
in the <span data-line="198"></span><code class="code code1">docs\design</code><span data-line="198"></span> subdirectory.  Some of the diagrams may be
slightly out of date in the details but in concept they are
accurate.
</p>
<p class="indent" data-line="202"><span data-line="202"></span>Intermediate code generation is illustrated in the test case
<span data-line="203"></span><code class="code code1">wyvern.tools.tests.ILTests.testFieldRead()</code><span data-line="203"></span> and the code that
it invokes.
</p><h2 id="sec-typechecking"  data-line="206"  style="bookmark:6.&#8194;Typechecking"><span data-line="206"></span><span class="heading-before"><span class="heading-label">6</span>.&#8194;</span><span data-line="206"></span>Typechecking</h2><h2 id="sec-interpreting-wyvern"  data-line="209"  style="bookmark:7.&#8194;Interpreting Wyvern"><span data-line="209"></span><span class="heading-before"><span class="heading-label">7</span>.&#8194;</span><span data-line="209"></span>Interpreting Wyvern</h2><h2 id="sec-lowering-to-a-class-based-ir"  data-line="212"  style="bookmark:8.&#8194;Lowering to a Class-Based IR"><span data-line="212"></span><span class="heading-before"><span class="heading-label">8</span>.&#8194;</span><span data-line="212"></span>Lowering to a Class-Based IR</h2><h2 id="sec-generating-llvm-code"  data-line="215"  style="bookmark:9.&#8194;Generating LLVM Code"><span data-line="215"></span><span class="heading-before"><span class="heading-label">9</span>.&#8194;</span><span data-line="215"></span>Generating LLVM Code</h2>
<div class="logomadoko block" data-line="219" style="text-align:right;font-size:xx-small;margin-top:4em"><span data-line="220"></span>Created with&nbsp;<a href="https://www.madoko.net">Madoko.net</a>.</div><span data-line=""></span>
</body>

</html>
