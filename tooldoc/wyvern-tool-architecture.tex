\documentclass{article}
% generated by Madoko, version 0.9.2-beta
%mdk-data-line={1}

\usepackage[heading-base=2]{madoko}


\begin{document}
%mdk-data-line={8}
\newcommand{\keyw}[1]{\textbf{#1}}\mdHxx[id=sec-building-wyvern,label={[1]\{.heading-label\}},toc={},data-line={11},caption={[[1]\{.heading-label\}.{\hspace{0.5em}}]\{.heading-before\}Building Wyvern},bookmark={1.{\hspace{0.5em}}Building Wyvern}]{%mdk-data-line={11}
{}\mdSpan[class={heading-before}]{\mdSpan[class={heading-label}]{1}.{\hspace{0.5em}}}%mdk-data-line={11}
{}Building Wyvern}\begin{mdP}[class={para-continue},data-line={13}]%
%mdk-data-line={13}
{}The Wyvern tooling is available in the wyvern repository on GitHub at
%mdk-data-line={14}
{}\mdA{https://github.com/wyvernlang/wyvern}{}{https://github.com/wyvernlang/wyvern}%mdk-data-line={14}
{}  To build Wyvern, you
will need to clone the repository and install the tools on which Wyvern
depends.  These are:%
\end{mdP}%
\begin{mdUl}[class={ul,list-star,compact},elem={ul},data-line={18}]%
\begin{mdLi}[class={li,ul-li,list-star-li,compact-li},label={[(1)]\{.ul-li-label\}},elem={li},data-line={18}]%
%mdk-data-line={18}
{}Java 8%
\end{mdLi}%
\begin{mdLi}[class={li,ul-li,list-star-li,compact-li},label={[(2)]\{.ul-li-label\}},elem={li},data-line={19}]%
%mdk-data-line={19}
{}ant 1.9.0 (or higher)%
\end{mdLi}%%
\end{mdUl}%
\begin{mdP}[data-line={21}]%
%mdk-data-line={21}
{}Once these are installed and available on the system path, you can
build and test the Wyvern tools by running%
\end{mdP}%
\begin{mdPre}[class={para-block,pre-indented},data-line={24}]%
\mdPrecode{ant\prespace{1}test\prebr{}
}%
\end{mdPre}%
\begin{mdP}[data-line={26}]%
%mdk-data-line={26}
{}To use the Eclipse IDE, first make sure you have built the system
using ant: this will generate java files for the Wyvern lexer and
parser.  Then you can import the existing project in the tools
subdirectory into your workspace.  Right-click on your project,
choose Properties, go to the Java Compiler tab, and make JDK
compliance is set to 1.8 (enable project-specific settings
if necessary).%
\end{mdP}%
\begin{mdP}[class={indent},data-line={34}]%
%mdk-data-line={34}
{}To run the regression test suite directly via JUnit or an IDE,
go to the package wyvern.tools.tests.suites and run
AntRegressionTestSuite as a JUnit test.  All regression tests
in this suite should run correctly.  However, some tests that
are excluded from the AntRegressionTestSuite (either by not
including them explicitly, or by marking them in
%mdk-data-line={40}
{}\mdCode[class={code,code1}]{@Category(CurrentlyBroken.class)}%mdk-data-line={40}
{}) may fail, because they
describe bugs that were discovered but not yet fixed or
functionality we know we want to support but we have
not yet implemented.%
\end{mdP}%
\begin{mdP}[class={indent},data-line={45}]%
%mdk-data-line={45}
{}Every time you edit the parser specifications, or pull changes
that affect the parser specifications, you will need to re-run
%mdk-data-line={47}
{}{\textquotedblleft}ant test{\textquotedblright}%mdk-data-line={47}
{} and then right-click on the project and type refresh.%
\end{mdP}%
\mdHxx[id=sec-overall-architecture,label={[2]\{.heading-label\}},toc={},data-line={51},caption={[[2]\{.heading-label\}.{\hspace{0.5em}}]\{.heading-before\}Overall Architecture},bookmark={2.{\hspace{0.5em}}Overall Architecture}]{%mdk-data-line={51}
{}\mdSpan[class={heading-before}]{\mdSpan[class={heading-label}]{2}.{\hspace{0.5em}}}%mdk-data-line={51}
{}Overall Architecture}\begin{mdP}[class={para-continue},data-line={54}]%
%mdk-data-line={54}
{}Like many language tools, the Wyvern interpreter is structured as a
pipeline.  The stages of the front end are as follows:%
\end{mdP}%
\begin{mdOl}[class={ol,compact},elem={ol},data-line={57}]%
\begin{mdLi}[class={li,ol-li,compact-li},label={[(1)]\{.ol-li-label\}},elem={li},data-line={57}]%
%mdk-data-line={57}
{}\mdStrong{Lexing}%mdk-data-line={57}
{}: producing a sequence of tokens from textual input%
\end{mdLi}%
\begin{mdLi}[class={li,ol-li,compact-li},label={[(2)]\{.ol-li-label\}},elem={li},data-line={58}]%
%mdk-data-line={58}
{}\mdStrong{Parsing}%mdk-data-line={58}
{}: producing a high-level AST from a sequence of tokens%
\end{mdLi}%
\begin{mdLi}[class={li,ol-li,compact-li},label={[(3)]\{.ol-li-label\}},elem={li},data-line={59}]%
%mdk-data-line={59}
{}\mdStrong{Intermediate Code Generation}%mdk-data-line={59}
{}: producing code in a foundational
intermediate representation.%
\end{mdLi}%
\begin{mdLi}[class={li,ol-li,compact-li},label={[(4)]\{.ol-li-label\}},elem={li},data-line={61}]%
%mdk-data-line={61}
{}\mdStrong{Typechecking}%mdk-data-line={61}
{}: ensuring that the generated intermediate
representation typechecks.%
\end{mdLi}%%
\end{mdOl}%
\begin{mdP}[data-line={64}]%
%mdk-data-line={64}
{}Wyvern has several back ends.  The main one is simply interpreting the
intermediate representation directly.  However, another pathway compiles
down to a lower-level, partially-typed class-based form, then generates
assembly languages using the LLVM infrastructure.%
\end{mdP}%
\begin{mdP}[class={indent},data-line={69}]%
%mdk-data-line={69}
{}As of this writing there is a fair bit of code that is out of date.
This will be removed as the current implementation is more fleshed out,
but is left in the codebase at the moment because it is a good reference
for some of the functionality we are reimplementing.%
\end{mdP}%
\begin{mdP}[class={indent},data-line={74}]%
%mdk-data-line={74}
{}The rest of this document will describe each of these stages in turn,
discussing the code by using the processing of the %mdk-data-line={75}
{}\mdCode[class={code,code1}]{val}%mdk-data-line={75}
{} concept as
a running example.%
\end{mdP}%
\mdHxx[id=sec-lexing,label={[3]\{.heading-label\}},toc={},data-line={78},caption={[[3]\{.heading-label\}.{\hspace{0.5em}}]\{.heading-before\}Lexing},bookmark={3.{\hspace{0.5em}}Lexing}]{%mdk-data-line={78}
{}\mdSpan[class={heading-before}]{\mdSpan[class={heading-label}]{3}.{\hspace{0.5em}}}%mdk-data-line={78}
{}Lexing}\begin{mdP}[data-line={81}]%
%mdk-data-line={81}
{}The lexer is implemented based on the Copper parser and scanner generator
(%mdk-data-line={82}
{}\mdA{http://www.melt.cs.umn.edu/copper/}{}{http://www.melt.cs.umn.edu/copper/}%mdk-data-line={82}
{}).  Copper was chosen because it
supports context-sensitive, stateful lexing.  Wyvern uses state and a
simple form of context-sensitive lexing both to make indentation-sensitive
syntax easier to process, and to defer lexing for blocks of domain-specific
code.  For documentation on the syntax of Copper, see the Copper website.%
\end{mdP}%
\begin{mdP}[class={indent},data-line={88}]%
%mdk-data-line={88}
{}The implementation of lexing is in
%mdk-data-line={89}
{}\mdCode[class={code,code1}]{tools/src/wyvern/tools/lexing/WyvernLexer.x}%mdk-data-line={89}
{}  The state used in the
lexer is at the top of the file: we track whether a tilde (%mdk-data-line={90}
{}\mdCode[class={code,code1}]{{\textasciitilde}}%mdk-data-line={90}
{}) symbol
was found in the current line, indicating a DSL block in the next line;
a boolean flag indicating that the next line is a DSL block, and a flag
recording whether we are currently scanning a DSL block.  Finally, there
is a stack of indentation levels for indentation-sensitive syntax.%
\end{mdP}%
\begin{mdP}[class={indent},data-line={96}]%
%mdk-data-line={96}
{}A few helper functions at the beginning handle indentation levels,
logical line detection, and token creation.  Tokens are declared in the
usual way; for example see the %mdk-data-line={98}
{}\mdCode[class={code,code1}]{valKwd\_t}%mdk-data-line={98}
{} token used for the %mdk-data-line={98}
{}\mdCode[class={code,code1}]{val}%mdk-data-line={98}
{}
keyword.%
\end{mdP}%
\begin{mdP}[class={indent},data-line={101}]%
%mdk-data-line={101}
{}After the tokens, there is a simple parser that detects lines as sequences
of tokens separated by generated indent and newline tokens, with DSL
block tokens embedded as appropriate.  We can find %mdk-data-line={103}
{}\mdCode[class={code,code1}]{val}%mdk-data-line={103}
{} in the %mdk-data-line={103}
{}\mdCode[class={code,code1}]{keyw}%mdk-data-line={103}
{}
production, which is in turn part of a non-whitespace line element
(%mdk-data-line={105}
{}\mdCode[class={code,code1}]{nonWSLineElement}%mdk-data-line={105}
{}).  This element is combined with other elements of
a line to form lines and then programs.%
\end{mdP}%
\begin{mdP}[class={indent},data-line={108}]%
%mdk-data-line={108}
{}An example test case that illustrates creating and using the lexer is
%mdk-data-line={109}
{}\mdCode[class={code,code1}]{wyvern.tools.tests.LexingTests.testDSLBLock1()}%mdk-data-line={109}
{}, which calls the
%mdk-data-line={110}
{}\mdCode[class={code,code1}]{checkLex()}%mdk-data-line={110}
{} function in the same file to parse a string and compare
the tokens generated to the expected token sequence.  Here %mdk-data-line={111}
{}\mdCode[class={code,code1}]{checkLex()}%mdk-data-line={111}
{}
simply creates a %mdk-data-line={112}
{}\mdCode[class={code,code1}]{WyvernLexer}%mdk-data-line={112}
{} and invokes %mdk-data-line={112}
{}\mdCode[class={code,code1}]{parse}%mdk-data-line={112}
{} on it to get a
list of tokens.%
\end{mdP}%
\mdHxx[id=sec-parsing,label={[4]\{.heading-label\}},toc={},data-line={115},caption={[[4]\{.heading-label\}.{\hspace{0.5em}}]\{.heading-before\}Parsing},bookmark={4.{\hspace{0.5em}}Parsing}]{%mdk-data-line={115}
{}\mdSpan[class={heading-before}]{\mdSpan[class={heading-label}]{4}.{\hspace{0.5em}}}%mdk-data-line={115}
{}Parsing}\begin{mdP}[data-line={118}]%
%mdk-data-line={118}
{}The parser is implemented using JavaCC
(%mdk-data-line={119}
{}\mdA{https://java.net/projects/javacc}{}{https://java.net/projects/javacc}%mdk-data-line={119}
{}).  We chose JavaCC because it is
fairly easy to understand and use, generates efficient parsers using
a top-down parsing approach, and (unlike Copper) it can take a stream
of lexical tokens generated by an earlier phase.%
\end{mdP}%
\begin{mdP}[class={indent},data-line={124}]%
%mdk-data-line={124}
{}The parser is implemented in
%mdk-data-line={125}
{}\mdCode[class={code,code1}]{tools/src/wyvern/tools/coreparser/WyvernParser.jj}%mdk-data-line={125}
{}  The significant
options (shown at the top of the file) are to use our own custom
token manager (which produces tokens from the lexer described above)
and to generate a non-static parser (sacrifices a tiny bit of
performance but makes testing or parallel parsing much easier because
it avoids global state).%
\end{mdP}%
\begin{mdP}[class={indent},data-line={132}]%
%mdk-data-line={132}
{}JavaCC requires that we declare our tokens up front, and it generates
a constant for each token in %mdk-data-line={133}
{}\mdCode[class={code,code1}]{WyvernParserConstants.java}%mdk-data-line={133}
{}.  We declare
one token for each kind of token produced by the lexer.  The
constants from %mdk-data-line={135}
{}\mdCode[class={code,code1}]{WyvernParserConstants}%mdk-data-line={135}
{} are used in %mdk-data-line={135}
{}\mdCode[class={code,code1}]{WyvernLexer.x}%mdk-data-line={135}
{} to
construct %mdk-data-line={136}
{}\mdCode[class={code,code1}]{Token}%mdk-data-line={136}
{} objects of the type expected by JavaCC.  There is
some code in %mdk-data-line={137}
{}\mdCode[class={code,code1}]{WyvernTokenManager}%mdk-data-line={137}
{} and %mdk-data-line={137}
{}\mdCode[class={code,code1}]{LexerUtils}%mdk-data-line={137}
{} that identifies
which tokens are %mdk-data-line={138}
{}{\textquotedblleft}special{\textquotedblright}%mdk-data-line={138}
{} (i.e. ignored when parsing%mdk-data-line={138}
{}{\textendash}%mdk-data-line={138}
{}things like
comments and whitespace that is not significant for indentation).%
\end{mdP}%
\begin{mdP}[class={indent},data-line={141}]%
%mdk-data-line={141}
{}The %mdk-data-line={141}
{}\mdCode[class={code,code1}]{WyvernParser}%mdk-data-line={141}
{} is then implemented in standard JavaCC recursive
descent style.  For documentation on the syntax, see the JavaCC
website and examples.  The top-level production is %mdk-data-line={143}
{}\mdCode[class={code,code1}]{CompilationUnit}%mdk-data-line={143}
{}.
Each production returns an AST%mdk-data-line={144}
{}{\textendash}%mdk-data-line={144}
{}this is a type parameter of
%mdk-data-line={145}
{}\mdCode[class={code,code1}]{WyvernParser}%mdk-data-line={145}
{} in order to reduce coupling with the rest of the
codebase, but in practice it is instantiated with the root of the
high-level AST hierarchy, %mdk-data-line={147}
{}\mdCode[class={code,code1}]{wyvern.tools.typedAST.interfaces.TypeAST}%mdk-data-line={147}
{}.
From the %mdk-data-line={148}
{}\mdCode[class={code,code1}]{CompilationUnit}%mdk-data-line={148}
{} we parse a %mdk-data-line={148}
{}\mdCode[class={code,code1}]{ModuleBody}%mdk-data-line={148}
{}, then a
%mdk-data-line={149}
{}\mdCode[class={code,code1}]{DeclSequence}%mdk-data-line={149}
{}, then a %mdk-data-line={149}
{}\mdCode[class={code,code1}]{Declaration}%mdk-data-line={149}
{}, one case of which is
%mdk-data-line={150}
{}\mdCode[class={code,code1}]{ValDeclaration}%mdk-data-line={150}
{}.  We use an abstract factory to build the AST so as
to decouple the parser from AST generation.  The factory is of type
%mdk-data-line={152}
{}\mdCode[class={code,code1}]{wyvern.tools.parsing.coreparser.ASTBuilder}%mdk-data-line={152}
{} and the relevant
implementation of this interface is
%mdk-data-line={154}
{}\mdCode[class={code,code1}]{wyvern.tools.parsing.coreparser.WyvernASTBuilder}%mdk-data-line={154}
{}.  Notice that when
creating the %mdk-data-line={155}
{}\mdCode[class={code,code1}]{val}%mdk-data-line={155}
{} declaration AST element we extract the text location
information from the identifier; this can be used to identify the
location in the source code if errors in this declaration are found
later (e.g. during typechecking).  Here the %mdk-data-line={158}
{}\mdCode[class={code,code1}]{loc()}%mdk-data-line={158}
{} helper function
takes the %mdk-data-line={159}
{}\mdCode[class={code,code1}]{Token}%mdk-data-line={159}
{} an extracts a %mdk-data-line={159}
{}\mdCode[class={code,code1}]{FileLocation}%mdk-data-line={159}
{} object that stores the
filename, line, and column.%
\end{mdP}%
\begin{mdP}[class={indent},data-line={162}]%
%mdk-data-line={162}
{}The %mdk-data-line={162}
{}\mdCode[class={code,code1}]{WyvernASTBuilder}%mdk-data-line={162}
{}{'}%mdk-data-line={162}
{}s %mdk-data-line={162}
{}\mdCode[class={code,code1}]{valDecl}%mdk-data-line={162}
{} function simply constructs a
%mdk-data-line={163}
{}\mdCode[class={code,code1}]{wyvern.tools.typedAST.core.declarations.ValDeclaration}%mdk-data-line={163}
{} object
with the passed-in parameters.%
\end{mdP}%
\begin{mdP}[class={indent},data-line={166}]%
%mdk-data-line={166}
{}Use of the parser can be seen in
%mdk-data-line={167}
{}\mdCode[class={code,code1}]{wyvern.tools.tests.CoreParserTests.testIdentityApp()}%mdk-data-line={167}
{}, which
creates a %mdk-data-line={168}
{}\mdCode[class={code,code1}]{WyvernParser}%mdk-data-line={168}
{} object by using the %mdk-data-line={168}
{}\mdCode[class={code,code1}]{makeParser}%mdk-data-line={168}
{}
utility and then parses an expression by calling %mdk-data-line={169}
{}\mdCode[class={code,code1}]{Expression(null)}%mdk-data-line={169}
{}
on the result (here the %mdk-data-line={170}
{}\mdCode[class={code,code1}]{null}%mdk-data-line={170}
{} argument is used for flags which are
not needed in this test case but are important for parsing uses of
%mdk-data-line={172}
{}\mdCode[class={code,code1}]{new}%mdk-data-line={172}
{} in Wyvern).  We would call %mdk-data-line={172}
{}\mdCode[class={code,code1}]{CompilationUnit()}%mdk-data-line={172}
{} if we wanted to
parse a whole compilation unit.%
\end{mdP}%
\begin{mdP}[class={indent},data-line={175}]%
%mdk-data-line={175}
{}To close the loop, looking at the %mdk-data-line={175}
{}\mdCode[class={code,code1}]{makeParser}%mdk-data-line={175}
{} helper, it creates a
%mdk-data-line={176}
{}\mdCode[class={code,code1}]{WyvernTokenManager}%mdk-data-line={176}
{} from the input character stream.  This token
manager will in turn create the %mdk-data-line={177}
{}\mdCode[class={code,code1}]{WyvernLexer}%mdk-data-line={177}
{} mentioned above.  The
%mdk-data-line={178}
{}\mdCode[class={code,code1}]{WyvernTokenManager}%mdk-data-line={178}
{} is passed to a new %mdk-data-line={178}
{}\mdCode[class={code,code1}]{WyvernParser}%mdk-data-line={178}
{} object.  We
set the builder to be used to a %mdk-data-line={179}
{}\mdCode[class={code,code1}]{WyvernASTBuilder}%mdk-data-line={179}
{} and the
%mdk-data-line={180}
{}\mdCode[class={code,code1}]{WyvernParser}%mdk-data-line={180}
{} is ready to parse.%
\end{mdP}%
\mdHxx[id=sec-intermediate-code-generation,label={[5]\{.heading-label\}},toc={},data-line={183},caption={[[5]\{.heading-label\}.{\hspace{0.5em}}]\{.heading-before\}Intermediate Code Generation},bookmark={5.{\hspace{0.5em}}Intermediate Code Generation}]{%mdk-data-line={183}
{}\mdSpan[class={heading-before}]{\mdSpan[class={heading-label}]{5}.{\hspace{0.5em}}}%mdk-data-line={183}
{}Intermediate Code Generation}\begin{mdP}[data-line={186}]%
%mdk-data-line={186}
{}Intermediate code generation takes a %mdk-data-line={186}
{}\mdCode[class={code,code1}]{TypedAST}%mdk-data-line={186}
{} generated by the
parser and generates code in the Wyvern Intermediate Language
(Wyvern IL).  The translation is partially type-based, in that
blocks of intermediate code already produced are typechecked and
the results are used to buide the translation of other parts
(most importantly DSL code blocks).%
\end{mdP}%
\begin{mdP}[class={indent},data-line={193}]%
%mdk-data-line={193}
{}The abstract syntax of Wyvern IL is described in
%mdk-data-line={194}
{}\mdCode[class={code,code1}]{vm-spec.pdf}%mdk-data-line={194}
{} in the %mdk-data-line={194}
{}\mdCode[class={code,code1}]{vm}%mdk-data-line={194}
{} directory of the Wyvern %mdk-data-line={194}
{}\mdCode[class={code,code1}]{docs}%mdk-data-line={194}
{}
repository.  Wyvern IL is implemented in the
%mdk-data-line={196}
{}\mdCode[class={code,code1}]{wyvern.target.corewyvernIL}%mdk-data-line={196}
{} package and its subpackages.
The design is expressed in UML diagrams in the wyvern repository,
in the %mdk-data-line={198}
{}\mdCode[class={code,code1}]{docs{\textbackslash}design}%mdk-data-line={198}
{} subdirectory.  Some of the diagrams may be
slightly out of date in the details but in concept they are
accurate.%
\end{mdP}%
\begin{mdP}[class={indent},data-line={202}]%
%mdk-data-line={202}
{}Intermediate code generation is illustrated in the test case
%mdk-data-line={203}
{}\mdCode[class={code,code1}]{wyvern.tools.tests.ILTests.testFieldRead()}%mdk-data-line={203}
{} and the code that
it invokes.%
\end{mdP}%
\mdHxx[id=sec-typechecking,label={[6]\{.heading-label\}},toc={},data-line={206},caption={[[6]\{.heading-label\}.{\hspace{0.5em}}]\{.heading-before\}Typechecking},bookmark={6.{\hspace{0.5em}}Typechecking}]{%mdk-data-line={206}
{}\mdSpan[class={heading-before}]{\mdSpan[class={heading-label}]{6}.{\hspace{0.5em}}}%mdk-data-line={206}
{}Typechecking}\mdHxx[id=sec-interpreting-wyvern,label={[7]\{.heading-label\}},toc={},data-line={209},caption={[[7]\{.heading-label\}.{\hspace{0.5em}}]\{.heading-before\}Interpreting Wyvern},bookmark={7.{\hspace{0.5em}}Interpreting Wyvern}]{%mdk-data-line={209}
{}\mdSpan[class={heading-before}]{\mdSpan[class={heading-label}]{7}.{\hspace{0.5em}}}%mdk-data-line={209}
{}Interpreting Wyvern}\mdHxx[id=sec-lowering-to-a-class-based-ir,label={[8]\{.heading-label\}},toc={},data-line={212},caption={[[8]\{.heading-label\}.{\hspace{0.5em}}]\{.heading-before\}Lowering to a Class-Based IR},bookmark={8.{\hspace{0.5em}}Lowering to a Class-Based IR}]{%mdk-data-line={212}
{}\mdSpan[class={heading-before}]{\mdSpan[class={heading-label}]{8}.{\hspace{0.5em}}}%mdk-data-line={212}
{}Lowering to a Class-Based IR}\mdHxx[id=sec-generating-llvm-code,label={[9]\{.heading-label\}},toc={},data-line={215},caption={[[9]\{.heading-label\}.{\hspace{0.5em}}]\{.heading-before\}Generating LLVM Code},bookmark={9.{\hspace{0.5em}}Generating LLVM Code}]{%mdk-data-line={215}
{}\mdSpan[class={heading-before}]{\mdSpan[class={heading-label}]{9}.{\hspace{0.5em}}}%mdk-data-line={215}
{}Generating LLVM Code}\begin{mdDiv}[class={logomadoko,block},elem={logomadoko},text-align={right},font-size={xx-small},margin-top={4em},data-line={219}]%
%mdk-data-line={220}
{}Created with{\mdNbsp}\mdA{https://www.madoko.net}{}{Madoko.net}.%
\end{mdDiv}%


\end{document}
