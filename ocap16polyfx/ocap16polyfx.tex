%% For double-blind review submission, w/o CCS and ACM Reference (max submission space)
%% \documentclass[sigplan,10pt,review,anonymous]{acmart}
%% \settopmatter{printfolios=true,printccs=false,printacmref=false}
%% For double-blind review submission, w/ CCS and ACM Reference
%% \documentclass[sigplan,10pt,review,anonymous]{acmart}\settopmatter{printfolios=true}
%% For single-blind review submission, w/o CCS and ACM Reference (max submission space)
\documentclass[sigplan,10pt,review]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}
%% For single-blind review submission, w/ CCS and ACM Reference
%% \documentclass[sigplan,10pt,review]{acmart}\settopmatter{printfolios=true}
%% For final camera-ready submission, w/ required CCS and ACM Reference
%% \documentclass[sigplan,10pt]{acmart}\settopmatter{}

\usepackage{listings}
\lstset{
tabsize=2,
basicstyle=\ttfamily\small
}

%using \kwa outside math mode
\newcommand{\kwat}[1]{$\mathtt{#1}$}

%% Conference information
%% Supplied to authors by publisher for camera-ready submission;
%% use defaults for review submission.
% \acmConference[PL'17]{ACM SIGPLAN Conference on Programming Languages}{January 01--03, 2017}{New York, NY, USA}
\acmYear{2017}
\acmISBN{} % \acmISBN{978-x-xxxx-xxxx-x/YY/MM}
\acmDOI{} % \acmDOI{10.1145/nnnnnnn.nnnnnnn}
\startPage{1}

%% Copyright information
%% Supplied to authors (based on authors' rights management selection;
%% see authors.acm.org) by publisher for camera-ready submission;
%% use 'none' for review submission.
\setcopyright{none}
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
%\setcopyright{rightsretained}
%\copyrightyear{2017}           %% If different from \acmYear

%% Bibliography style
\bibliographystyle{ACM-Reference-Format}
%% Citation style
%\citestyle{acmauthoryear}  %% For author/year citations
%\citestyle{acmnumeric}     %% For numeric citations
%\setcitestyle{nosort}      %% With 'acmnumeric', to disable automatic
                            %% sorting of references within a single citation;
                            %% e.g., \cite{Smith99,Carpenter05,Baker12}
                            %% rendered as [14,5,2] rather than [2,5,14].
%\setcitesyle{nocompress}   %% With 'acmnumeric', to disable automatic
                            %% compression of sequential references within a
                            %% single citation;
                            %% e.g., \cite{Baker12,Baker14,Baker16}
                            %% rendered as [2,3,4] rather than [2-4].

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Note: Authors migrating a paper from traditional SIGPLAN
%% proceedings format to PACMPL format must update the
%% '\documentclass' and topmatter commands above; see
%% 'acmart-pacmpl-template.tex'.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% Some recommended packages.
\usepackage{booktabs}   %% For formal tables:
                        %% http://ctan.org/pkg/booktabs
\usepackage{subcaption} %% For complex figures with subfigures/subcaptions
                        %% http://ctan.org/pkg/subcaption

\begin{document}

%% Title information
\title[Capabilities and Effects]{Capabilities and Effects}

%% Author information
%% Contents and number of authors suppressed with 'anonymous'.
%% Each author should be introduced by \author, followed by
%% \authornote (optional), \orcid (optional), \affiliation, and
%% \email.
%% An author may have multiple affiliations and/or emails; repeat the
%% appropriate command.
%% Many elements are not rendered, but should be provided for metadata
%% extraction tools.

%% Author with single affiliation.
\author{Aaron Craig, Alex Potanin}
%\authornote{with author1 note}          %% \authornote is optional;
                                        %% can be repeated if necessary
%\orcid{nnnn-nnnn-nnnn-nnnn}             %% \orcid is optional
\affiliation{
%  \position{Position1}
  \department{ECS, VUW, NZ}              %% \department is recommended
%  \institution{VUW}            %% \institution is required
%  \streetaddress{Street1 Address1}
%  \city{City1}
%  \state{State1}
%  \postcode{Post-Code1}
%  \country{NZ}                    %% \country is recommended
}
\email{alex@ecs.vuw.ac.nz}          %% \email is recommended

%% Author with two affiliations and emails.
\author{Darya Melicher, Jonathan Aldrich}
%\authornote{with author2 note}          %% \authornote is optional;
                                        %% can be repeated if necessary
%\orcid{nnnn-nnnn-nnnn-nnnn}             %% \orcid is optional
\affiliation{
%  \position{Position2a}
  \department{ISR, CMU, USA}             %% \department is recommended
%  \institution{CMU}           %% \institution is required
%  \streetaddress{Street2a Address2a}
%  \city{City2a}
%  \state{State2a}
%  \postcode{Post-Code2a}
%  \country{USA}                   %% \country is recommended
}
\email{jonathan.aldrich@cs.cmu.edu}         %% \email is recommended

%\affiliation{
%  \position{Position2b}
%  \department{Department2b}             %% \department is recommended
%  \institution{Institution2b}           %% \institution is required
%  \streetaddress{Street3b Address2b}
%  \city{City2b}
%  \state{State2b}
%  \postcode{Post-Code2b}
%  \country{Country2b}                   %% \country is recommended
%}
%\email{first2.last2@inst2b.org}         %% \email is recommended

%% Abstract
%% Note: \begin{abstract}...\end{abstract} environment must come
%% before \maketitle command
\begin{abstract}
Wyvern is a new web programming language designed from the ground up with security being the highest priority in any language design decisions~\cite{darya-modules}. Wyvern has object capabilities~\cite{miller-thesis,newspeak,risk-trust} and a simple object-oriented core~\cite{maspeghi} that lends itself to easy formal reasoning about its features. We recently explored the benefits of capabilities when reasoning about effects~\cite{aaron-popl-submission} which greatly simplifies effect inference for the unannotated parts of the system by utilising the access restrictions imposed by capabilities. In this talk we present how exactly effects benefit from capabilities and show some ideas of how these benefits can be extended to polymorphic effects or richer systems that include first-class modules and type members.
\end{abstract}

%% 2012 ACM Computing Classification System (CSS) concepts
%% Generate at 'http://dl.acm.org/ccs/ccs.cfm'.
\begin{CCSXML}
<ccs2012>
<concept>
<concept_id>10011007.10011006.10011008</concept_id>
<concept_desc>Software and its engineering~General programming languages</concept_desc>
<concept_significance>500</concept_significance>
</concept>
<concept>
<concept_id>10003456.10003457.10003521.10003525</concept_id>
<concept_desc>Social and professional topics~History of programming languages</concept_desc>
<concept_significance>300</concept_significance>
</concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Software and its engineering~General programming languages}
\ccsdesc[300]{Social and professional topics~History of programming languages}
%% End of generated code

%% Keywords
%% comma separated list
% \keywords{keyword1, keyword2, keyword3}  %% \keywords are mandatory in final camera-ready submission

%% \maketitle
%% Note: \maketitle command must come after title commands, author
%% commands, abstract environment, Computing Classification System
%% environment and commands, and keywords command.
\maketitle

\section{From Aaron's Paper}

How could capabilities help with effects?
One challenge to the wider adoption of effect systems is their annotation overhead~\cite{rytz12}.
For example, Java's checked exception system is a kind of effect system, and is often criticised for being cumbersome~\cite{Kiniry2006}.
Effect inference can be used to reduce the annotations required~\cite{koka14}, but this has significant drawbacks: understanding error messages that arise through effect inference requires a detailed understanding of the internal structure of the code, not just its interface.
Capabilities are a promising alternative for reducing the overhead of effect annotations, as suggested by the following example:

\begin{lstlisting}
import log:Str->Unit with effect File.write

e
\end{lstlisting}

In the code above, written in a capability-safe language, what can we infer about the effects on resources (e.g. the file system or network) of evaluating \kwat{e}?
Since we are in a capability-safe language, \kwat{e} has no ambient authority, and so the only way it can have any effect on resources is via the \kwat{log} function it imports.
Note that this reasoning requires nothing about \kwat{e} other than that it obeys the rules of a capability-safe language; in particular, we don't require any effect annotations within \kwat{e}, and we don't need to analyse its structure as an effect inference would have to do.
Also note that \kwat{e} might be arbitrarily large, perhaps consisting of an entire program that we have downloaded from a source that we trust enough to allow it to write to a log, but that we don't trust to access any other resources.
Thus in this scenario, capabilities can be used to reason ``for free'' about the effect of a large body of code based on a few annotations on the components it imports.

The central intuition that we formalised in our recent work~\cite{aaron-popl} is this: the effect of an unannotated expression can be given a bound based on the effects latent in variables that are in scope.
Of course, there are challenges to solve on the way, most notably involving higher-order programs: how can we generalise this intuition if \kwat{log} takes a higher-order argument?
If \kwat{e} evaluates not to unit but to a function, what can we infer about that function's effects?

\section{From SoW on Effects}

Over the past decade object capabilities [Lev84,Mil06,DNMM15] have emerged as a promising technique for providing security guarantees in programming languages.  Modern languages typically allow easy access to security-critical objects which can lead to unauthorised access (e.g. a JavaScript code snippet abusing DOM by executing ?document.body.innerHTML = "";?). Object encapsulation approaches take a much stronger stance by dramatically limiting access and ensuring this cannot be circumvented.For example, Google?s Caja [CAJA] translates the entire JavaScript program into a single function restricted to only accessing explicitly supplied parameters and nothing else. Another object-oriented approach is found in Newspeak [NEWSPK] where first class modules force the programmers to explicitly create and pass any imported modules to the module being created with no additional access being permitted during the module?s execution.We recently combined object capabilities and first class modules to develop a secure web language called Wyvern [WYVERN] that is designed from the ground up to be a statically-checked, object-capability based language with every feature judged on its benefit to web security rather than just productivity or performance. In particular, we recently demonstrated how object capabilities can benefit effects-based reasoning to provide security guarantees about access to sensitive resources (such as files, network, or FFI) [CPGA18] and how software architectures can benefit from being able to enforce non-transitive authority of modules over system resources [MSPA17].Unfortunately, security guarantees almost almost always come at the price of expressiveness. Even the most trivial language features (e.g. methods with effects, generic libraries, inheritance and delegation) are still unsolved problems in secure programming language research. This is, in part, due to the difficulty of reasoning statically about the effect of such expressions on object capability-based security guarantees. This is the primary reason why languages such as Google Caja or Newspeak - developed over a decade ago - did not receive widespread adoption and were put on hold. Either the restrictions on expressiveness were too much for developers to be able to maintain large code bases (as in Caja) or the checks could only be performed at run time with little support for static reasoning (as in Newspeak).

We propose to advance the state of secure web programming by tackling some of these formal road blocks and lay the groundwork for secure programming languages based on object capabilities. Our first objective would be to build on our effects and capabilities formal system to add effect polymorphism allowing functions to be parameterised with effects. The following example shows a simple web server that can write both online (by using a socket) and offline (by using a file). Thus the write effect will be on a system resource to be determined at runtime, yet reasoning about the potential effects on various system resources by an abstract function such as this is still an unsolved problem due to numerous corner cases of what can go wrong at runtime. Our promising approach [CPGA18] demonstrates how capabilities allow possible effects to be restricted sufficiently that the following code can be statically type checked to guarantee that HTTPServer will not be able to access file system unless such capability was given to it:

\begin{lstlisting}
module HTTPServerdef init(out: A <: {File, Socket}): Str -A.write-> Unit with {} =  lambda (msg: Str)    if (msg == ??POST??) then out.write(??post response??)    else if (msg == ??GET??) then out.write(??get response??)    else out.write(??client error 400??)module Main  require HTTPServer, Socket  def main(): Unit =    HTTPServer.init(Socket) ??GET /index.html??// The testing module calls HTTPServer.init with a LogFile,// perhaps so the responses of the server can be tested offline.module Testing  require HTTPServer, LogFile  def testSocket(): Unit =    HTTPServer.init(LogFile) ??GET /index.html??
\end{lstlisting}

We will then proceed to our second objective and add type members to our object-capability and effects system [MPGA18] allowing generic and thus more expressive libraries to provide acceptable security guarantees while allowing expressive modules comparable to ML or newly introduced Java Module System (aka Project Jigsaw) in JDK v9.Third objective is to enable code reuse. We will build on our recent delegation work [LPA15] to be able to provide statically checked object capability based security guarantees in the presence of parameterised first-class modules, effects for resources in use, and delegation.Out fourth objective is to explore the applicability of our approach to dynamic web languages. One current problem with statically type checked object capabilities is that the system?s structure tends to be predetermined at run time. We will explore dynamically changing, revoking, and creating object capabilities while being able to verify strong security guarantees statically. We will build on the experience of the second PI with design and development of a verifying compiler system, Whiley [WHILEY] to add object capabilities and other expressive features described above as well as encode security guarantees similar to the traditional systems [MSPA17,MMT10,Mil06]. Within such a framework we will then allow limited capability changes and explore the limitations for verification in secure languages.

%% Bibliography
\bibliography{alex}

\end{document}