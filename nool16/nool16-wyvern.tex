%-----------------------------------------------------------------------------
%
%               Template for sigplanconf LaTeX Class
%
% Name:         sigplanconf-template.tex
%
% Purpose:      A template for sigplanconf.cls, which is a LaTeX 2e class
%               file for SIGPLAN conference proceedings.
%
% Guide:        Refer to "Author's Guide to the ACM SIGPLAN Class,"
%               sigplanconf-guide.pdf
%
% Author:       Paul C. Anagnostopoulos
%               Windfall Software
%               978 371-2316
%               paul@windfall.com
%
% Created:      15 February 2005
%
%-----------------------------------------------------------------------------


\documentclass[preprint]{sigplanconf}

% The following \documentclass options may be useful:

% preprint      Remove this option only once the paper is in final form.
% 10pt          To set in 10-point type instead of 9-point.
% 11pt          To set in 11-point type instead of 9-point.
% numbers       To obtain numeric citation style instead of author/year.

\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{caption}
\usepackage{float}

\newcommand{\cL}{{\cal L}}
\setcitestyle{numbers}
\setcitestyle{square}

\lstset{basicstyle=\ttfamily\footnotesize,
	  numberstyle=\tiny,
	  numbersep=5pt,
	  xrightmargin=0.2\textwidth}

\begin{document}

\special{papersize=8.5in,11in}
\setlength{\pdfpageheight}{\paperheight}
\setlength{\pdfpagewidth}{\paperwidth}

\conferenceinfo{CONF 'yy}{Month d--d, 20yy, City, ST, Country}
\copyrightyear{20yy}
\copyrightdata{978-1-nnnn-nnnn-n/yy/mm}
\copyrightdoi{nnnnnnn.nnnnnnn}

% Uncomment the publication rights you want to use.
%\publicationrights{transferred}
%\publicationrights{licensed}     % this is the default
%\publicationrights{author-pays}

%\titlebanner{banner above paper title}        % These are ignored unless
%\preprintfooter{short description of paper}   % 'preprint' option specified.

\title{Delegation Revisited}
% \subtitle{Subtitle Text, if any}

\authorinfo{Alex Potanin}
           {Victoria University of Wellington}
           {alex@ecs.vuw.ac.nz}

\authorinfo{Jonathan Aldrich}
           {Carnegie Mellon University}
           {aldrich@cs.cmu.edu}
		   		   
\maketitle

\begin{abstract}
Wyvern is a new secure object-oriented language in sore need of a code reuse functionality. Being object-oriented aficionados we discuss different ways \textit{delegation} can be implemented in Wyvern exploring different possibilities similar to Jones et al. exploring inheritance~\cite{jones:2016:inheritance}.
\end{abstract}

%\category{CR-number}{subcategory}{third-level}

% general terms are not compulsory anymore,
% you may leave them out
% \terms
%

\keywords
delegation, inheritance

\section{Why Objects not Classes?}

Wyvern aims to be a pure object-oriented language~\cite{Aldrich:2013:PIW:2509578.2514738} with value-based semantics. We start with a pure object-oriented core that models objects as records with methods and fields as members following Bruce et al.~\cite{BCP99}. Our model considers classes, modules, and other extensions as simply additional convenient ``sugar'' that can be translated to a pure object-oriented core~\cite{Nistor:2013:WST:2489828.2489830}. A class is thus simply an object that has methods that apply to all ``instances'' of such class that created by a factory method that adds the appropriate common methods and fields to each object representing an ``instance''. Wyvern subtyping is structural and if one is after a case analysis allowed for by nominal types we propose a pure tagged objects extension that does not require or need classes~\cite{DBLP:conf/ecoop/LeeASP15}.

Having taken care of the need for classes as \textit{types}, \textit{case tags}, or \textit{generators}, we now want to provide the last potential use for classes: \textit{code reuse}, which is typically gained by some sort of inheritance in all its gory details and variations~\cite{jones:2016:inheritance}. Our talk will consider different options of avoiding inheritance and classes and why it makes the language more expressive and pure. Our work is inspired by our initial investigation showing that delegation-based formalism captures type state in a simpler and richer fashion than a class-based formalism~\cite{li:2015:ftfjp-typestate}.

\section{Wyvern Delegation}

In our first proposal for delegation support in Wyvern we built on a simple idea that simple function forwarding with a little syntactic sugar can express most inheritance patterns as shown by the example in Figure~\ref{f:wyvern-delegation}. The type of \texttt{Animal} describes instances that can \texttt{eat} and \texttt{swallow} while a \texttt{Dog} can also \texttt{bark}. When we construct an instance of an \texttt{Animal} we distinguish between a current instance being created (\texttt{animalSelf}) and the instance that we might be extending (\texttt{childSelf}) that will be given to us as a parameter to a method that is delegated to a ``prototype''/``super instance'' or whichever you may choose to call it. Thus, an animal can have a local version of eating and a dog that happens to be an animal can have its eating \textit{delegated} to the animal instance.

\begin{figure}
\begin{lstlisting}
type Animal
  def eat()
  def swallow()

type AnimalDelegate
  def eat(self:Animal)
  def swallow()

type Dog extends Animal
  def bark():String

def makeAnimal():AnimalDelegate = new animalSelf =>
  def eat(@Self childSelf:Animal)
    childSelf.swallow()
    animalSelf.swallow()
  def eat() = new LocalStuffToDo()
  def swallow() = new Unit()

def makeDog(base:AnimalDelegate):Dog = new
  delegate Animal to base
  // the ?delegate? declaration above is equiv. to:
  // def eat() = base.eat(this)
  def bark():String = ``Woof''
  def swallow():Unit = new Unit()

val base:AnimalDelegate = makeAnimal()
val a:Animal = makeDog(base)
a.eat() // calls Dog.swallow(), then Animal.swallow()
a.bark() // ``Woof''
\end{lstlisting}
\caption{Example of Delegation in Wyvern}
\label{f:wyvern-delegation}
\end{figure}

The support for such downcalls is provided by the \texttt{delegate T to x} construct which looks at whether each method \texttt{m} in \texttt{T} is defined with the same signature in the current new statement (in which case it does nothing) or if it is defined in the type of \texttt{x} (in which case a wrapper is generated that directly calls \texttt{x.m}) or finally if it is defined in the type of \texttt{x} with the same signature and an extra self parameter (in which case a wrapper calls \texttt{x.m(..., this)}).

We believe that making delegation explicit is better than implicitly (and often blindly as in the case of Java's virtual dispatch for all methods) allowing the superclasses to interact with subclasses using downcalls (or breaking ``uniform identity'' as defined by Jones et al.~\cite{jones:2016:inheritance}) which our preliminary investigation of the Qualitas Corpus~\cite{QualitasCorpus:APSEC:2010} shows to be occurring in $8\%$ of the \textit{extended} classes and is a potential source of hidden bugs and unintended functionality. In general, inheritance (and multiple one is even worse at this) introduces implicit rules on the code execution that are not obvious to the programmer and thus we argue it \textit{increases} complexity.

We believe everything should be a value so that one can abstract over it and compute with it. Thus, if one is to allow classes, they would have to be values. On the other hand, once first-class classes are allowed, reasoning about typed first-class classes with inheritance-like composition is non-trivial and while some variations of Racket achieve it~\cite{Takikawa:2012:GTF:2384616.2384674} it still remains a challenging type checking problem if one is to have a fully statically type checked language with the expressiveness of Smalltalk.

%Maybe functions alone are not sufficient for convenient reuse, but it looks like some form of delegation might be.

%Inheritance (and Self-style delegation, as contrasted with mere forwarding) build in open recursion.  Is this needed often enough to justify a particular language construct for it?

%Evidence that subclasses reuse methods and fields from superclasses, e.g. via super calls [dependence of subclass on superclass]

%No evidence specifically for open recursion: can the uses of downcalls be refactored so that the superclass C can be divided into C? and C??, where the downcall is in C? and the subclass depends only on C???  In this case, the design can perhaps be simulated using only forwarding.

%If we care about reasoning, first-class classes will make that reasoning more challenging.  Of course, with delegation we still have to reason about values statically, but notice that we want to do that anyway, so it comes ?for free? whereas with classes it is more of an added burden.  Combination with types is deadly: Racket is one of the few (only?) systems that has done typed first-class classes with inheritance-like composition, and it was an OOPSLA paper to do it.

%Do they have restrictions, e.g. vs. Smalltalk?  Worth looking into

\section{Where To Next?}

%We already have forms of abstractions (functions) and composition based on values (records, function bodies). Adding abstraction and composition over classes introduces more complexity.

%It?s not just that classes are complex, then you need composition principles and rules too.

Our Wyvern proposal above is just the first of the ones we intend to discuss in the presentation. One can argue that too much infrastructure is showing and its not pretty as it requires an extra type (\texttt{AnimalDelegate}) and an extra explicit \texttt{self} parameter (one for the current object and one for the original object which are of different types!). How could we address this ugliness?

One option we will discuss is \textit{``The Dylan/CLOS Solution''}: every method takes self as a parameter, but it defaults to the receiver. There is a syntax for specifying a replacement. So \texttt{x.m()} passes \texttt{x} as self, but something like \texttt{x.m(self=y)} replaces it. In a typed setting there is still some complexity because the passed-in self parameter has a different type than the (lone) parent object. A simpler version of such example is shown in Figure~\ref{f:dylan-style}.

A second option to discuss is to provide a \textit{Forwarding Construct} that does not pass ``self''. This is less expressive (forwarding, not delegation) but is semantically clean and gets rid of all the ugliness above. We intend to explore (and push) the limits of the expressiveness of forwarding in our talk.

% It can probably handle a lot of examples, including cases where there are downcalls but no upcalls, but certainly not all examples we currently use inheritance for.

A third option is to make the \textit{Parent have a Pointer to the Child} (but potentially awkward due to either recursive initialisation, or reusing the same parent with multiple children). Uniqueness types or a recursive initialisation primitive (e.g. placeholder types by Servetto et al.~\cite{servetto:2013:billion}) could facilitate this, with the latter likely being a better solution to the problem. While we avoid the extra types and akward self parameters, we will pay the space cost of explicit extra pointers to the child and it would make it harder to merge objects.

A fourth alternative is provide a \textit{CLASS} construct that builds everything above inside it and while ``under the covers'' classes are still implemented in terms of delegation the programmer does not need to deal with the complexity. Effectively, as much as in the usual class based inheritance is now hidden, but due to delegation done explicitly underneath a lot of optimisation become possible.

%Provide something like what?s above, but only as part of a ?class? construct that builds everything above in.  Under the covers, classes are still implemented in terms of delegation.  Note that if it?s possible to access the ?self? variable of the superclass, the weird AnimalDelegate type will still show up; and there will still be two different ?self? variables.  And if it?s not possible to do this, we really are hiding just as much under the covers as inheritance does--but on the bright side an optimized implementation becomes easy.


%Tim?s concerns (from paper, see Table 1):
%
%Registration. (Reg.) Is the identity of the super-object stored during initialisation, either explicitly or through lexical capture, the same as the final object? This is clearly the intention of the call to register in graphic?s initialisation in their paper.
%Downcalls. (Down.) Can a method in a super-object call down into a method in a lower object? Can it do so during initialisation? The implementation of the draw method in his paper relies on a downcall to the image method.
%Action at a Distance. (Dist.) Can operations on an object implicitly affect another object? If the registered graphic object is different to amelia, what is the value of its name field after melia is initialised?
%Stability. (Stable) Is the implementation of methods in an object the same throughout its lifetime? Which image method will be invoked by the request to draw at the end of graphic? Can the structural type of an object change after it has been constructed?
%Freshness. (Exist.) Can an object inherit from any other object it has a reference to? Does amelia have to inherit a call to the constructor, or will a preexisting graphic object suffice?
%Multiplicity. (Mult.)  Can an object inherit from multiple other objects? If amelia also wished to have the behaviour of another object, can a second inherits clause be added? If so, how are multiple methods with the same name resolved, and where are fields located?
%
%Tim?s example (to be translated to Wyvern!)
%
%method graphic {
%	object {
%		method image { abstract }
%		method draw { canvas.render(image) }
%		var name := ?A graphic?; displayList.register(self); draw
%	}
%}
%
%def amelia = object {
%	inherits graphic
%	def image = images.amelia; self.name := ?Amelia?
%}


\begin{figure}
\begin{lstlisting}
// This is per type not per method solution as first try.
type Animal
  def eat()
  def swallow()

type Dog extends Animal
  def bark():String

// Self is assigned mine (this) by default.
def makeAnimal(self:Animal = mine):Animal = new mine =>
  def eat()
    self.swallow()
    mine.swallow()
  def swallow() = new Unit()

def makeDog(self:Animal):Dog = new mine =>
  delegate Animal to self
  // the ?delegate? declaration above is equivalent to:
  // def eat() = self.eat()
  def bark():String = ``Woof''
  def swallow():Unit = new Unit()

val a:Animal = makeAnimal()
val d:Animal = makeDog(a)
d.eat() // calls Dog.swallow(), then Animal.swallow()
d.bark() // ``Woof''
\end{lstlisting}
\label{f:dylan-style}
\caption{Alternative ``Dylan-Style'' Example of Delegation}
\end{figure}

%// what about:
%val d:Animal = makeDog() // where will eat come from??? error???

\bibliographystyle{plain}
\bibliography{alex}

\end{document}