\section{Capability Calculus ($\epscalc$)}

$\opercalc$ requires every function to be annotated. The verbosity of such effect systems has been given as a reason for why they have not seen widespread use \cite{rytz12} --- if we relax the requirement that all code be annotated, can a type system say anything useful about the parts which are not? Allowing a mix of annotated and unannotated code helps reduce the cognitive overhead on developers, allowing them to rapidly prototype in the unannotated sublanguage and incrementally add annotations as they are needed. However, reasoning about unannotated code is difficult in general. Figure \ref{fig:unannotated_reasoning} demonstrates the issue: $\kwa{someMethod}$ takes a function $f$ as input and executes it, but the effects of $f$ depends on its implementation. Without more information, there is no way to know what effects might be incurred by $\kwa{someMethod}$.


\begin{figure}[h]
\begin{lstlisting}
def someMethod(f: Unit $\rightarrow$ Unit):
   f()
\end{lstlisting}
\vspace{-7pt}
\caption{What effects can $\kwa{someMethod}$ incur?}
\label{fig:unannotated_reasoning}
\end{figure}

A capability-safe design can help us: because the only authority code can exercise is that which is explicitly given to it, the only capabilities that the unannotated code can use must be passed into it. If these capabilities are being passed in from an annotated environment, we know what effects they capture. These effects are therefore a conservative upper bound on what can happen in the unannotated code. To demonstrate, consider a developer who wants to decide whether to use the $\kwa{logger}$ functor in Figure \ref{fig:cc_motivation}. It must be instantiated with two capabilities, $\kwa{File}$ and $\kwa{Socket}$, and provides an unannotated function $\kwa{log}$.

\begin{figure}[h]
\begin{lstlisting}
module def logger(f:{File},s:{Socket}):Logger

def log(x: Unit): Unit
   ...
\end{lstlisting}
\vspace{-7pt}
\caption{In a capability-safe setting, $\kwa{logger}$ can only exercise authority over the $\kwa{File}$ and $\kwa{Socket}$ capabilities given to it.}
\label{fig:cc_motivation}
\end{figure}

What effects will be incurred if $\kwa{Logger.log}$ is invoked? One approach is to manually\footnote{or automatically---but if the automation produces an unexpected result we must fall back to manual reasoning to understand why.} examine its source code, but this is tedious and error-prone. In many real-world situations, the source code may be obfuscated or unavailable. A capability-based argument can do better: the only authority which $\kwa{Logger}$ can exercise is that which it has been explicitly given. Here, the $\kwa{Logger}$ requires a $\kwa{File}$ and a $\kwa{Socket}$, so $\kwa{ \{ \kwa{File.*, Socket.*} \} }$ is an upper bound on the effects of $\kwa{Logger}$. Knowing $\kwa{Logger}$ could be performing arbitrary reads and writes to $\kwa{File}$, or arbitrary communication with the $\kwa{Socket}$, the developer decides this implementation cannot be trusted and does not use it.

The reasoning we employed only required us to examine the interface of the unannotated code for the capabilities be passed into it. To model this situation in $\epscalc$, we add a new $\kwa{import}$ expression that selects what authority $\varepsilon$ the unannotated code may exercise. In the above example, the expected least authority of $\kwa{Logger}$ is $\{ \kwa{File.append} \}$, so that is what the corresponding $\kwa{import}$ would select. The type system can then check if the capabilities being passed into the unannotated code exceed its selected authority. If it accepts, then $\varepsilon$ safely approximates the effects of the unannotated code. This is the key result: when unannotated code is nested inside annotated code, capability-safety enables us to make a safe inference about its effects by examining what capabilities are being passed in by the annotated code.


\subsection{Grammar ($\epscalc$)}

The grammar of $\epscalc$ is split into rules for annotated code and analogous rules for unannotated code. To distinguish the two, we put a hat above annotated types, expressions, and contexts: $\hat e$, $\hat \tau$, and $\hat \Gamma$ are annotated, while $e$, $\tau$, and $\Gamma$ are unannotated. The rules for unannotated programs and their types are given in Figure \ref{fig:epscalc_unannotated_grammar}. They are much the same as in $\opercalc$, but the type constructor $\rightarrow$ is not annotated with a set of effects. The type $\tau_1 \rightarrow \tau_2$ says nothing about what effects a function may or may not incur. Unannotated types $\tau$ are built using $\rightarrow$ and sets of resources $\{ \bar r \}$. An unannotated context $\Gamma$ maps variables to unannotated types.

\begin{figure}[h]
\vspace{-5pt}

\[
\begin{array}{lll}

\begin{array}{lllr}
e & ::= & ~ & exprs: \\
	& | & x & variable \\
	& | & v & value \\
	& | & e ~ e & application \\
	& | & e.\pi & operation \\
	&&\\

v & ::= & ~ & values: \\
	& | & r & resource~literal \\
	& | & \lambda x: \tau.e & abstraction \\
	&&\\
\end{array}

\hspace{5ex}

\begin{array}{lllr}

\tau & ::= & ~ & types: \\
		& | & \{ \bar r \} \\
		& | & \tau \rightarrow \tau \\ 
		&&\\

\Gamma & ::= & ~ & type~ctx: \\
				& | & \varnothing \\
				& | & \Gamma, x: \tau \\
				&&\\
				
\end{array}

\end{array}
\]

\vspace{-7pt}
\caption{Unannotated programs and types in $\epscalc$.}
\label{fig:epscalc_unannotated_grammar}
\end{figure}


Rules for annotated programs and their types are given in Figure \ref{fig:epscalc_annotated_grammar}. Except for the new $\kwa{import}$ expression, the rules are identical to those in $\opercalc$, except now everything has a hat above it.

\begin{figure}[h]
\vspace{-5pt}

\[
\begin{array}{lll}

\begin{array}{lllr}

\hat e & ::= & ~ & labeled~exprs: \\
	& | & x \\
	& | & \hat v \\
	& | & \hat e ~ \hat e \\
	& | & \hat e.\pi \\
	& | & \kwa{import}(\varepsilon)~x = \hat e~\kwa{in}~e & import \\
	&&\\

\hat v & ::= & ~ & labeled~values: \\
	& | & r \\
	& | & \lambda x: \hat \tau.\hat e \\
	&&\\

\end{array}

& ~~~~~~~~&

\begin{array}{lllr}

\hat \tau & ::= & ~ & labeled ~types: \\
		& | & \{ \bar r \} \\
		& | & \hat \tau \rightarrow_{\varepsilon} \hat \tau \\
		&&\\

\hat \Gamma & ::= & ~ & labeled~type~ctx:\\
				& | & \varnothing \\
				& | & \hat \Gamma, x: \hat \tau \\
				&&\\

\end{array}

\end{array}
\]

\vspace{-7pt}
\caption{Annotated programs and types in $\epscalc$.}
\label{fig:epscalc_annotated_grammar}
\end{figure}

The new form is $\import{\varepsilon}{x}{\hat e}{e}$, which represents the point at which capabilities are passed from annotated code into unannotated code. $e$ is the unannotated code. $\hat e$ is the capability being given to it; we call $\hat e$ an import. For simplicity, we assume only one capability is being passed into $e$. $\hat e$ is associated with the name $x$ inside $e$. $\varepsilon$ is the maximum authority that $e$ is allowed to exercise (its ``selected authority''). As an example, suppose an unannotated $\kwa{Logger}$, which requires $\kwa{File}$, is expected to only $\kwa{append}$ to a file, but has an implementation that writes. This would be modelled by the expression $\import{\kwa{File.append}}{x}{\kwa{File}}{\lambda y: \Unit. \kwa{x.write}}$.

$\kwa{import}$ is the only way to mix annotated and unannotated code, because it is the only situation in which we can say something interesting about the unannotated code. For the rest of our discussion on $\epscalc$, we will only be interested in unannotated code when it is encapsulated by an $\kwa{import}$ expression.

One of the requirements of capability safety is there be no ambient authority.
This requirement is met by forbidding resource literals $r$ from being used directly inside an \kwat{import} statement (they can still be passed in as a capability via the \kwat{import}'s binding variable $x$).
We could enforce this syntactically, by removing $r$ from the language of unannotated expressions, but we choose to do it instead using the typing rule for \kwat{import}, given below.

\subsection{Semantics ($\epscalc$)}

Reductions are defined on annotated expressions. If unannotated code $e$ is wrapped inside annotated code $\import{\varepsilon}{x}{\hat e}{e}$, we transform it into annotated code by labeling its parts with $\varepsilon$. In practice, it is meaningful to execute purely unannotated code --- but our only interest is when that code is wrapped inside an $\kwa{import}$ expression, so we do not bother to give rules for it.

Excluding $\kwa{import}$, the annotated sublanguage of $\epscalc$ is the same as $\opercalc$, so we take every reduction rule of $\opercalc$ as a valid reduction rule in $\epscalc$. For brevity, they are not restated. There are two new rules in $\epscalc$ for reducing $\kwa{import}$ expressions, given in Figure \ref{fig:epscalc_reductions}. \textsc{E-Import1} reduces the capability being imported, while \textsc{E-Import2} first annotates $e$ with its selected authority $\varepsilon$ --- this is $\annot{e}{\varepsilon}$ --- and then substitutes the import $\hat v$ for its name $x$ in $e$ --- this is $[\hat v/x]\annot{e}{\varepsilon}$.

\begin{figure}[h]

\fbox{$\hat e \longrightarrow \hat e~|~\varepsilon$}

\[
\begin{array}{c}
\infer[\textsc{(E-Import1)}]
	{\kwa{import}(\varepsilon)~x = \hat e~\kw{in} e \longrightarrow \kwa{import}(\varepsilon)~x = \hat e'~\kw{in} e~|~\varepsilon'}
	{\hat e \longrightarrow \hat e'~|~\varepsilon'}\\[4ex]

\infer[\textsc{(E-Import2)}]
	{\kwa{import}(\varepsilon)~x = \hat v~\kw{in} e \longrightarrow [\hat v/x]\kwa{annot}(e, \varepsilon)~|~\varnothing}
	{}

\end{array}
\]


\vspace{-7pt}
\caption{New single-step reductions in $\epscalc$.}
\label{fig:epscalc_reductions}
\end{figure}

A definition for $\kwa{annot}$ is given in Figure \ref{fig:annot_defn}. $\annot{e}{\varepsilon}$ produces the expression obtained by recursively labeling the parts of $e$ with the set of effects $\varepsilon$. There are versions of $\kwa{annot}$ defined for expressions and types. Later we shall need to annotate contexts, so the definition is given here. It is worth mentioning that $\kwa{annot}$ operates on a purely syntatic level --- nothing prevents us from annotating a program with something unsafe, so any use of $\kwa{annot}$ must be justified.

\begin{figure}[h]
\vspace{-5pt}

$\kwa{annot} :: e \times \varepsilon \rightarrow \hat e$

\begin{itemize}
	\setlength\itemsep{-0.2em}
	\item[] $\annot{r}{\_} = r$
	\item[] $\annot{\lambda x: \tau_1 . e}{\varepsilon} = \lambda x: \annot{\tau_1}{\varepsilon} . \annot{e}{\varepsilon}$
	\item[] $\annot{e_1~e_2}{\varepsilon} = \kwa{annot}(e_1, \varepsilon)~\kwa{annot}(e_2, \varepsilon)$
	\item[] $\annot{e_1.\pi}{\varepsilon} = \annot{e_1}{\varepsilon}.\pi$
\end{itemize}
	
$\kwa{annot} :: \tau \times \varepsilon \rightarrow \hat \tau$

\begin{itemize}
	\setlength\itemsep{-0.2em}
	\item[] $\annot{\{ \bar r \}}{\_} = \{ \bar r \}$
	\item[] $\annot{\tau_1 \rightarrow \tau_2}{\varepsilon} = \annot{\tau_1}{\varepsilon} \rightarrow_{\varepsilon} \annot{\tau_2}{\varepsilon}$.	
\end{itemize}

$\kwa{annot} :: \Gamma \times \varepsilon \rightarrow \hat \Gamma$

\begin{itemize}
	\setlength\itemsep{-0.2em}
	\item[] $\annot{\varnothing}{\_} = \varnothing$
	\item[] $\annot{\Gamma, x: \tau}{\varepsilon} = \annot{\Gamma}{\varepsilon}, x: \annot{\tau}{\varepsilon}$
\end{itemize}

\vspace{-7pt}
\caption{Definition of $\kwa{annot}$.}
\label{fig:annot_defn}
\end{figure}

\subsection{Static Rules ($\epscalc$)}

A term can be annotated or unannotated, so we need to be able to recognise when either is well-typed. We do not reason about the effects of unannotated code directly, so judgements about them have the form $\Gamma \vdash e: \tau$. Subtyping judgements have the form $\tau <: \tau$. A summary of the rules for unannotated judgements is given in Figure \ref{fig:unannotated_static_rules}. Each is analogous to some rule in $\opercalc$, but the parts relating to effects have been removed.

\begin{figure}[h]
\vspace{-5pt}


\fbox{$\Gamma \vdash e: \tau$}

\[
\begin{array}{c}


\infer[\textsc{(T-Var)}]
	{\Gamma, x: \tau \vdash x: \tau}
	{}
\hspace{5ex}
\infer[\textsc{(T-Resource)}]
	{\Gamma, r: \{ r \} \vdash r : \{ r \}}
	{}

\hspace{5ex}
\infer[\textsc{(T-Abs)}]
	{\Gamma \vdash \lambda x: \tau_1.e : \tau_1 \rightarrow \tau_2}
	{\Gamma, x: \tau_1 \vdash e: \tau_2}\\[4ex]
	
\infer[\textsc{(T-App)}]
	{\Gamma \vdash e_1~e_2: \tau_3}
	{\Gamma \vdash e_1: \tau_2 \rightarrow \tau_3 & \Gamma \vdash e_2: \tau_2}
\hspace{5ex}
\infer[\textsc{(T-OperCall)}]
	{\Gamma \vdash e.\pi: \kwa{Unit}}
	{\Gamma \vdash e: \{ \bar r \}}

\end{array}
\]



\fbox{$\tau <: \tau$}

\[
\begin{array}{c}

\infer[\textsc{(S-Arrow)}]
	{ \tau_1 \rightarrow \tau_2 <: \tau_1' \rightarrow \tau_2' }
	{ \tau_1' <: \tau_1 & \tau_2 <: \tau_2' }
\hspace{5ex}
\infer[\textsc{(S-Resources)}]
	{ \{ \bar r_1 \} <: \{ \bar r_2 \} }
	{ \{ \bar r_1 \} \subseteq \{ \bar r_2 \} }

\end{array}
\]

\vspace{-7pt}
\caption{(Sub)typing judgements for the unannotated sublanguage of $\epscalc$}
\label{fig:unannotated_static_rules}
\end{figure}

Since the annotated subset of $\epscalc$ contains $\opercalc$, all the $\opercalc$ judgements apply, but now we put hats on everything to signify that a typing judgement is being made about annotated code inside an annotated context. This looks like $\hat \Gamma \vdash \hat e: \hat \tau~\kw{with} \varepsilon$. Except for notation the judgements are the same, so we shall not repeat them. The only new rule is \textsc{$\varepsilon$-Import}, given in Figure \ref{fig:import_rule}, which gives the type and approximate effects of an $\kwa{import}$ expression. This is the only way to reason about what effects might be incurred by some unannotated code. The rule is complicated, so to explain it we shall start with a simplified version and spend the rest of this section building up to the final version of \textsc{$\varepsilon$-Import}.

%\begin{figure}[h]
%\vspace{-5pt}
%
%\[
%\begin{array}{c}
%
%\infer[\textsc{($\varepsilon$-Import)}]
%	{ \hat \Gamma \vdash \kwa{import}(\varepsilon)~x = \hat e~\kw{in} e: \kwa{annot}(\tau, \varepsilon)~\kw{with} \varepsilon \cup \varepsilon_1 }
%{{\def\arraystretch{1.4}
%  \begin{array}{c}
%\kwa{effects}(\hat \tau) \cup \hofx{\annot{\tau}{\varnothing}}\subseteq \varepsilon \\
%\hat \Gamma \vdash \hat e: \hat \tau~\kw{with} \varepsilon_1 ~~~~~~ \kwa{ho \hyphen safe}(\hat \tau, \varepsilon) ~~~~~~ x: \kwa{erase}(\hat \tau) \vdash e: \tau
%  \end{array}}} 
% 
%\end{array}
%\]
%\vspace{-7pt}
%\caption{(Sub)typing judgements for the unannotated sublanguage of $\epscalc$}
%\label{fig:import_rule}
%\end{figure}

To begin, typing $\import{\varepsilon}{x}{\hat e}{e}$ in a context $\hat \Gamma$ requires us to know that the import $\hat e$ is well-typed, so we add the premise $\hat \Gamma \vdash \hat e: \hat \tau~\kw{with} \varepsilon_1$. Since $x = \hat e$ is an import, it can be used throughout $e$. However, we do not want $e$ to exercise authority it hasn't explicitly selected, so whatever capabilities are used must be selected by the $\kwa{import}$ expression; therefore, we require that $e$ can be typechecked using only the binding $x: \hat \tau$. There is a problem though: $e$ is unannotated and $\hat \tau$ is annotated, and there is no rule for typechecking unannotated code in an annotated context. To get around this, we define a function $\kwa{erase}$ in Figure \ref{fig:erase_defn} which removes the annotations from a type. We then add $x: \erase{\hat \tau} \vdash e: \tau$ as a premise.

\begin{figure}[h]
\vspace{-5pt}

$\kwa{erase} :: \hat \tau \rightarrow \tau$
\begin{itemize}
	\setlength\itemsep{-0.2em}
	\item[] $\erase{\{ \bar r \}}$
	\item[] $\erase{\hat \tau_1 \rightarrow_{\varepsilon} \hat \tau_2} = \erase{\hat \tau_1} \rightarrow \erase{\hat \tau_2}$
\end{itemize}

\vspace{-7pt}
\caption{Definition of $\kwa{erase}$.}
\label{fig:erase_defn}
\end{figure}

Note that, since the environment $\Gamma$ for $e$ has only one binding (for $x$), it cannot contain any bindings of resource literals---and the rule \textsc{T-Resource} requires a binding in the environment in order to type a resource literal in an expression.  We thus use the restricted environment given by \kwat{import} to prohibit ambient authority. 

The first version of \textsc{$\varepsilon$-Import} is given in Figure \ref{fig:import_rule_1}. Since $\import{\varepsilon}{x}{\hat v}{e} \longrightarrow [\hat v/x]\annot{e}{\varepsilon}$ by \textsc{E-Import2}, the ascribed type is $\annot{\tau}{\varepsilon}$, which is the type of the unannotated code, annotated with its selected authority $\varepsilon$. The effects of the $\kwa{import}$ are $\varepsilon_1 \cup \varepsilon$ --- the former comes from reducing the imported capability, which happens before the body of the $\kwa{import}$ is annotated and executed, and the latter contains all the effects which the unannotated code might incur.


\begin{figure}[h]

\[
\begin{array}{c}

\infer[\textsc{($\varepsilon$-Import1-Bad)}]
	{ \hat \Gamma \vdash \import{\varepsilon}{x}{\hat e}{e}: \kwa{annot}(\tau, \varepsilon)~\kw{with} \varepsilon \cup \varepsilon_1 }
	{ \hat \Gamma \vdash \hat e: \hat \tau~\kw{with} \varepsilon_1 & x: \kwa{erase}(\hat \tau) \vdash e: \tau }

\end{array}
\]
\vspace{-7pt}
\caption{A first (incorrect) rule for type-and-effect checking $\kwa{import}$ expressions.}
\label{fig:import_rule_1}
\end{figure}

At the moment there is no relation between the selected authority $\varepsilon$ and those effects captured by the imported capability $\hat e$. Consider $\hat e' = \import{\varnothing}{x}{\File}{\kwa{x.write}}$, which imports a $\File$ and writes to it, but declares its authority as $\varnothing$. According to \textsc{$\varepsilon$-Import1}, $\vdash \hat e': \Unit~\kw{with} \varnothing$, but this is clearly wrong since $\hat e'$ writes to $\kwa{File}$.
An $\kwa{import}$ should only be well-typed if the capability being imported only captures effects that are in the unannotated code's selected authority $\varepsilon$.
To this end we define a function $\kwa{effects}$, which collects the set of effects that an annotated type captures. A first (but not yet correct) definition is given in Figure \ref{fig:fx_defn}. We can then add the premise $\kwa{effects}(\hat \tau) \subseteq \varepsilon$ to require that any imported capability must not capture authority beyond that selected in $\varepsilon$. The updated rule is given in Figure \ref{fig:import_rule_2}.

\begin{figure}[h]

$\kwa{effects} :: \hat \tau \rightarrow \varepsilon$
\begin{itemize}
	\setlength\itemsep{-0.2em}
	\item[] $\fx{\{ \bar r \}} = \{ r.\pi \mid r \in \bar r, \pi \in \Pi \}$
	\item[] $\fx{\hat \tau_1 \rightarrow_{\varepsilon} \hat \tau_2} = \fx{\hat \tau_1} \cup \varepsilon \cup \fx{\hat \tau_2}$
\end{itemize}
\vspace{-7pt}
\caption{A first (incorrect) definition of $\kwa{effects}$.}
\label{fig:fx_defn}
\end{figure}

\begin{figure}[h]

\[
\begin{array}{c}

\infer[\textsc{($\varepsilon$-Import2-Bad)}]
	{ \hat \Gamma \vdash \import{\varepsilon}{x}{\hat e}{e}: \kwa{annot}(\tau, \varepsilon)~\kw{with} \varepsilon \cup \varepsilon_1 }
	{ \hat \Gamma \vdash \hat e: \hat \tau~\kw{with} \varepsilon_1 & x: \kwa{erase}(\hat \tau) \vdash e: \tau & \kwa{effects}(\hat \tau) \subseteq \varepsilon}

\end{array}
\]
\vspace{-7pt}
\caption{A second (still incorrect) rule for type-and-effect checking $\kwa{import}$ expressions.}
\label{fig:import_rule_2}
\end{figure}

The counterexample from before is now rejected by \textsc{$\varepsilon$-Import2}, but there are still issues: the annotations on one import can be broken by another import. To illustrate, consider Figure \ref{fig:rule_import2_counterexample} where two\footnote{Our formalisation only permits a single capability to be imported, but this discussion leads to a generalisation needed for the rules be safe when multiple capabilities can be imported.  In any case importing multiple capabilities can be handled with an encoding of pairs.} capabilities are imported. This program imports a function $\kwa{go}$ which, when given a $\Unit \rightarrow_{\varnothing} \Unit$ function with no effects, will execute it. The other import is $\kwa{File}$. The unannotated code creates a $\Unit \rightarrow \Unit$ function which writes to $\kwa{File}$ and passes it to $\kwa{go}$, which subsequently incurs $\kwa{File.write}$.

\begin{figure}[h]

\begin{lstlisting}
import({File.*})
   go = $\lambda$x: Unit $\rightarrow_{\varnothing}$ Unit. x unit
   f = File
in
   go ($\lambda$y: Unit. f.write)

\end{lstlisting}

\vspace{-7pt}
\caption{Permitting multiple imports will break \textsc{$\varepsilon$-Import2}.}
\label{fig:rule_import2_counterexample}
\end{figure}

In the world of annotated code it is not possible to pass a file-writing function to $\kwa{go}$, but because the judgement $x: \erase{\hat \tau} \vdash e: \tau$ discards the annotations on $\kwa{go}$, and since the file-writing function has type $\unit \rightarrow \unit$, the unannotated world accepts it. The approximation is actually safe at the top-level, because the $\kwa{import}$ selects $\{ \kwa{File.*} \}$, which contains $\kwa{File.write}$ --- but it contains code that violates the type signature of $\kwa{go}$. We want to prevent this.

If $\kwa{go}$ had the type $\Unit \rightarrow_{\{ \kwa{File.write} \}} \Unit$ the above example would be safe, but a modified version where a file-reading function is passed to $\kwa{go}$ would have the same issue. $\kwa{go}$ is only safe when it expects every effect that the unannotated code might pass to it: if $\kwa{go}$ had the type $\Unit \rightarrow_{\{ \kwa{File.*} \}} \Unit$, then the unannotated code cannot pass it a capability with an effect it isn't already expecting, so the annotation on $\kwa{go}$ cannot be violated. Therefore we require imported capabilities to have authority to incur the effects in $\varepsilon$. To achieve greater control in how we say this, the definition of $\kwa{effects}$ is split into two separate functions called $\kwa{effects}$ and $\kwa{ho \hyphen effects}$. The latter is for higher-order effects, i.e. the effects that are not captured within a function, but rather are possible because of what it is passed as an argument. If values of $\hat \tau$ possess a capability that can be used to incur the effect $r.\pi$, then $r.\pi \in \fx{\hat \tau}$. If values of $\hat \tau$ can incur an effect $r.\pi$, but need to be given the capability by someone else in order to do it, then $r.\pi \in \hofx{\hat \tau}$. Definitions are given in Figure \ref{fig:fx_defns}.


\begin{figure}[h]

$\kwa{effects} :: \hat \tau \rightarrow \varepsilon$

\begin{itemize}
	\setlength\itemsep{-0.2em}
	\item[] $\fx{\{ \bar r \}} = \{ r.\pi \mid r \in \bar r, \pi \in \Pi \}$
	\item[] $\fx{\hat \tau_1 \rightarrow_{\varepsilon} \hat \tau_2} = \hofx{\hat \tau_1} \cup \varepsilon \cup \fx{\hat \tau_2}$
\end{itemize}

$\kwa{ho \hyphen effects} :: \hat \tau \rightarrow \varepsilon$

\begin{itemize}
	\setlength\itemsep{-0.2em}
	\item[] $\hofx{\{ \bar r \}} = \varnothing$
	\item[] $\hofx{\hat \tau_1 \rightarrow_{\varepsilon} \hat \tau_2} = \fx{\hat \tau_1} \cup \hofx{\hat \tau_2}$
\end{itemize}

\vspace{-7pt}
\caption{Effect functions (corrected).}
\label{fig:fx_defns}
\end{figure}

$\kwa{effects}$ and $\kwa{ho \hyphen effects}$ are mutually recursive, with base cases for resource types. Any effect can be directly incurred by a resource on itself, hence $\fx{\{ \bar r \}} = \{ r.\pi \mid r \in \bar r, \pi \in \Pi \}$. A resource cannot be used to indirectly invoke some other effect, so $\hofx{\{ \bar r \}} = \varnothing$. The mutual recursion echoes the subtyping rule for functions. Recall that functions are contravariant in their input type and covariant in their output type. The mutual recursion here is similar: both functions recurse on the input-type using the other function, and recurse on the output-type using the same function.

In light of these new definitions, we still require $\fx{\hat \tau} \subseteq \varepsilon$ --- unannotated code must select any effect its capabilities can incur --- but we add a new premise $\varepsilon \subseteq \hofx{\hat \tau}$, stipulating that imported capabilities must select every effect they could be given by unannotated code. The counterexample from Figure \ref{fig:rule_import2_counterexample} is now rejected, because $\hofx{\Unit \rightarrow_{\varnothing} \Unit) \rightarrow_{\varnothing} \Unit} = \varnothing$, but $\{ \kwa{File.*} \} \not\subseteq \varnothing$.  However, this is \textit{still} not sufficient! Consider $\varepsilon \subseteq \hofx{ \hat \tau_1 \rightarrow_{\varepsilon'} \hat \tau_2 }$. We want \textit{every} higher-order capability involved to be expecting $\varepsilon$. Expanding the definition of $\kwa{ho \hyphen effects}$, this is the same as $\varepsilon \subseteq \fx{\hat \tau_1} \cup \hofx{\hat \tau_2}$. Let $r.\pi \in \varepsilon$ and suppose $r.\pi \in \fx{\hat \tau_1}$, but $r.\pi \notin \hofx{\hat \tau_2}$. Then $\varepsilon \subseteq \fx{\hat \tau_1} \cup \hofx{\hat \tau_2}$ is still true, but $\hat \tau_2$ is not expecting $r.\pi$. Unannotated code could then violate the annotations on $\hat \tau_2$ by passing it a capability for $r.\pi$, using the same trickery as before. The cause of the issue is that $\subseteq$ does not distribute over $\cup$. We want a relation like $\varepsilon \subseteq \fx{\hat \tau_1} \cup \hofx{\hat \tau_2}$, but which also implies $\varepsilon \subseteq \fx{\hat \tau_1}$ and $\varepsilon \subseteq \fx{\hat \tau_2}$. Figure \ref{fig:safe_defns} defines this: $\kwa{safe}$ is a distributive version of $\varepsilon \subseteq \fx{\hat \tau}$ and $\kwa{ho \hyphen safe}$ is a distributive version of $\varepsilon \subseteq \hofx{\hat \tau}$.


\begin{figure}[h]

\noindent
$\fbox{$\safe{\hat \tau}{\varepsilon}$}$

\[
\begin{array}{c}

\infer[\textsc{(Safe-Resource)}]
	{ \kwa{safe}(\{ \bar r \}, \varepsilon) }
	{} 
\hspace{5ex}
	
\infer[\textsc{(Safe-Arrow)}]
	{\kwa{safe}(\hat \tau_1 \rightarrow_{\varepsilon'} \hat \tau_2, \varepsilon)}
	{\varepsilon \subseteq \varepsilon' & \kwa{ho \hyphen safe}(\hat \tau_1, \varepsilon) & \kwa{safe}(\hat \tau_2, \varepsilon)} \\[3ex]

\end{array}
\]

\noindent
$\fbox{$\hosafe{\hat \tau}{\varepsilon}$}$

\[
\begin{array}{c}

\infer[\textsc{(HOSafe-Resource)}]
	{ \kwa{ho \hyphen safe}( \{ \bar r \}, \varepsilon)} 
	{}
\hspace{5ex}

\infer[\textsc{(HOSafe-Arrow)}]
	{ \kwa{ho \hyphen safe}( \hat \tau_1 \rightarrow_{\varepsilon'} \hat \tau_2, \varepsilon ) }
	{ \kwa{safe}(\hat \tau_1, \varepsilon)  & \kwa{ho \hyphen safe}(\hat \tau_2, \varepsilon) }\\[3ex]

\end{array}
\]

\vspace{-7pt}
\caption{Safety judgements in $\epscalc$.}
\label{fig:safe_defns}
\end{figure}

An amended version of \textsc{$\varepsilon$-Import} is given in Figure \ref{fig:import_rule3}. It contains a new premise $\hosafe{\hat \tau}{\varepsilon}$ which formalises the notion that every capability which could given to a value of $\hat \tau$ --- or any of its constituent pieces --- must be expecting the effects $\varepsilon$ it might be given by the unannotated code.

\begin{figure}[h]

\[
\begin{array}{c}

\infer[\textsc{($\varepsilon$-Import3-Bad)}]
	{ \hat \Gamma \vdash \kwa{import}(\varepsilon)~x = \hat e~\kw{in} e: \kwa{annot}(\tau, \varepsilon)~\kw{with} \varepsilon \cup \varepsilon_1 }
{{\def\arraystretch{1.4}
  \begin{array}{c}
\hat \Gamma \vdash \hat e: \hat \tau~\kw{with} \varepsilon_1
~~~~~~
\kwa{effects}(\hat \tau) \subseteq \varepsilon \\
\hosafe{\hat \tau}{\varepsilon} ~~~~~~ x: \kwa{erase}(\hat \tau) \vdash e: \tau
  \end{array}}} 
 
\end{array}
\]

\vspace{-7pt}
\caption{A third (still incorrect) rule for type-and-effect checking $\kwa{import}$ expressions.}
\label{fig:import_rule3}
\end{figure}

The premises so far restrict what authority can be selected by unannotated code, but what about authority passed as a function argument? Consider the example $\hat e = \import{\varnothing}{x}{\unit}{\lambda f: { \File }.~\kwa{f.write}}$. The unannotated code selects no capabilities and returns a function which, when given $\kwa{File}$, incurs $\kwa{File.write}$. This satisfies the premises in \textsc{$\varepsilon$-Import3}, but its annotated type is $\{ \File \} \rightarrow_{\varnothing} \Unit$ --- not good!

Suppose the unannotated code defines a function $f$, which gets annotated with $\varepsilon$ to produce $\annot{f}{\varepsilon}$. Suppose $\annot{f}{\varepsilon}$ is invoked at a later point in the annotated world and incurs the effect $r.\pi$. What is the source of $r.\pi$? If $r.\pi$ was selected by the $\kwa{import}$ expression surrounding $f$, it is safe for $\annot{f}{\varepsilon}$ to incur this effect. Otherwise, $\annot{f}{\varepsilon}$ may have been passed an argument which can be used to incur $r.\pi$, in which case $r.\pi$ is a higher-order effect of $\annot{f}{\varepsilon}$. If the argument is a function, then by the soundness of $\opercalc$, it must be that $r.\pi \in \varepsilon$, or it will not typecheck. If the argument is a resource $r$ then $\annot{f}{\varepsilon}$ may exercise $r.\pi$ without declaring it --- this is the case we do not yet account for.

We want $\varepsilon$ to contain every effect captured by resources passed into $\annot{f}{\varepsilon}$ as arguments. We can do this by inspecting its (unannotated type) for resource sets. For example, if the unannotated code has the type $\kwa{ \{ File \} \rightarrow \Unit}$, then we need $\kwa{ \{ File.* \} }$ in $\varepsilon$. To do this, we add a new premise $\hofx{\annot{\tau}{\varnothing}} \subseteq \varepsilon$. $\kwa{ho \hyphen effects}$ is only defined on annotated types, so we first annotate $\tau$ with $\varnothing$. We are only inspecting the resources passed into $f$ as arguments, so the annotations are not relevant -- annotating $\tau$ with $\varnothing$ is therefore a good choice. We can now handle the example from before. The unannotated code types via the judgement $x: \Unit \vdash \lambda f: \{ \File \}.~\kwa{f.write}: \{ \File \} \rightarrow \Unit$. Its higher-order effects are $\hofx{\annot{ \{ \File \} \rightarrow \Unit}{\varnothing}} = \{ \kwa{File.*} \}$, but $\{ \kwa{File.*} \} \not\subseteq \varnothing$, so the example is safely rejected.

The final version of \textsc{$\varepsilon$-Import} is given in Figure \ref{fig:import_rule}.

\begin{figure}[h]

\[
\begin{array}{c}

\infer[\textsc{($\varepsilon$-Import)}]
	{ \hat \Gamma \vdash \kwa{import}(\varepsilon)~x = \hat e~\kw{in} e: \kwa{annot}(\tau, \varepsilon)~\kw{with} \varepsilon \cup \varepsilon_1 }
{{\def\arraystretch{1.4}
  \begin{array}{c}
\kwa{effects}(\hat \tau) \cup \hofx{\annot{\tau}{\varnothing}}\subseteq \varepsilon \\
\hat \Gamma \vdash \hat e: \hat \tau~\kw{with} \varepsilon_1 ~~~~~~ \kwa{ho \hyphen safe}(\hat \tau, \varepsilon) ~~~~~~ x: \kwa{erase}(\hat \tau) \vdash e: \tau
  \end{array}}} 
 
\end{array}
\]


\vspace{-7pt}
\caption{The final rule for typing imports.}
\label{fig:import_rule}
\end{figure}

We can now model the example from the beginning of this section, where the $\kwa{Logger}$ selects the $\kwa{File}$ capability and exposes an unannotated function $\kwa{log}$ with type $\Unit \rightarrow \Unit$ and implementation $e$. The expected least authority of $\kwa{Logger}$ is $\{ \kwa{File.append} \}$, so its corresponding $\kwa{import}$ expression would be $\import{\kwa{File.append}}{f}{\kwa{File}}{\lambda x: \Unit.~e}$. The imported capability is $ f = \kwa{File}$, and $\fx{\{\File\}} = \{ \kwa{File.*} \} \not\subseteq \{ \kwa{File.append} \}$, so this example is safely rejected: $\kwa{Logger.log}$ has authority to do anything with $\kwa{File}$, and its implementation $e$ might be violating its stipulated least authority $\{ \kwa{File.append} \}$.

\subsection{Soundness ($\epscalc$)} 

For this section we adopt a different notational convention to avoid name clashes: the selected authority of an $\kwa{import}$ will be written $\varepsilon_{s}$ (``epsilon select''). An $\kwa{import}$ expression will look like this: $\import{\varepsilon_s}{x}{\hat e_i}{e}$.

Only annotated programs can be reduced and have their effects approximated, so the soundness theorem only applies to annotated judgements. Its statement is given below.

\begin{theorem}[$\epscalc$ Single-step Soundness]
If $\hat \Gamma \vdash \hat e_A: \hat \tau_A~\kw{with} \varepsilon_A$ and $\hat e_A$ is not a value, then $\hat e_A \longrightarrow \hat e_B~|~\varepsilon$, where $\hat \Gamma \vdash \hat e_B: \hat \tau_B~\kw{with} \varepsilon_B$ and $\hat \tau_B <: \hat \tau_A$ and $\varepsilon_B \cup \varepsilon \subseteq \varepsilon_A$, for some $\hat e_B, \varepsilon, \hat \tau_B, \varepsilon_B$.
\end{theorem}

Because the rules of $\opercalc$, proven sound in section 2, are also rules of $\epscalc$, we do not repeat them here. The progress theorem has a new case for when the typing rule used is \textsc{$\varepsilon$-Import}, but the proof is routine.

\begin{theorem}[$\epscalc$ Progress]
If $\hat \Gamma \vdash \hat e: \hat \tau~\kw{with} \varepsilon$ and $\hat e$ is not a value, then $\hat e \longrightarrow \hat e'~|~\varepsilon'$, for some $\hat e', \varepsilon' \subseteq \varepsilon$.
\end{theorem}

\begin{proof} By induction on derivations of $\hat \Gamma \vdash \hat e: \hat \tau~\kw{with} \varepsilon$.
\end{proof}

The preservation theorem also has an extra case for when the typing rule used is \textsc{$\varepsilon$-Import}. This has two subcases, depending on whether the reduction rule used was \textsc{E-Import1} and \textsc{E-Import2}. The former is straightforward, but the latter is tricky; we need several lemmas to do it. Firstly, since $\varepsilon_s$ is an upper bound on what effects can be incurred by the unannotated code, it should also be an upper bound on what effects can be incurred by the capabilities passed into the unannotated code; therefore, if we take $\hat \tau_i$ and replace its annotations with $\varepsilon_s$, we should get a more general function type $\annot{\erase{\hat \tau_i}}{\varepsilon}$. This result is given as the pair of lemmas below.

\begin{lemma}[$\epscalc$ Approximation 1]
If $\kwa{effects}(\hat \tau) \subseteq \varepsilon$ and $\kwa{ho \hyphen safe}(\hat \tau, \varepsilon)$ then $\hat \tau <: \kwa{annot}(\kwa{erase}(\hat \tau), \varepsilon)$.
\end{lemma}

\begin{lemma}[$\epscalc$ Approximation 2]
If $\kwa{ho \hyphen effects}(\hat \tau) \subseteq \varepsilon$ and $\safe{\hat \tau}{\varepsilon}$ then $\kwa{annot(erase}(\hat \tau), \varepsilon) <: \hat \tau$.
\end{lemma}

\begin{proof}
By simultaneous induction on derivations of $\hosafe{\hat \tau}{\varepsilon}$ and $\safe{\hat \tau}{\varepsilon}$.
\end{proof}

Recall that function types are contravariant in their input, so the subtyping and subsetting relations flip direction when considering the input type of a function. This is why there are two lemmas: one for each direction.

Now, if \textsc{E-Import2} is applied, the reduction has the form $\import{\varepsilon_{s}}{x}{\hat v_i}{e} \longrightarrow [\hat v_i/x]\annot{e}{\varepsilon_s}~|~\varnothing$. Since $x: \erase{\hat \tau} \vdash e: \tau$, it is reasonable to expect (1) $\hat \Gamma \vdash \annot{e}{\varepsilon_s}: \annot{\tau}{\varepsilon_s}~\kw{with} \varepsilon_s$ is true --- the reduction annotates $e$ with $\varepsilon_s$, so the type after annotation ought to be the type of $e$, annotated with $\varepsilon_s$, i.e. $\annot{\tau}{\varepsilon_s}$. Furthermore, $\annot{e}{\varepsilon_s}$ is really the same program as $e$, but with extra labels. These labels do not change what capabilities can be used by the code --- the bound $\varepsilon_s$ on the authority of $e$ is therefore also a bound on the authority of $\annot{e}{\varepsilon_s}$. Now, if judgement (1) holds, then $\hat \Gamma \vdash [\hat v_i/x]\annot{e}{\varepsilon_s}: \annot{\tau}{\varepsilon_s}~\kw{with} \varepsilon_s$ would hold by the substitution lemma. That judgement (1) does hold is the subject of the following lemma.

\begin{lemma}[$\epscalc$ Annotation]
If the following are true:

\begin{enumerate}
	\item $\hat \Gamma \vdash \hat v_i : \hat \tau_i~\kw{with} \varnothing$
	\item $\Gamma, y: \kwa{erase}(\hat \tau_i) \vdash e: \tau$
	\item $\kwa{effects}(\hat \tau_i) \cup \hofx{\annot{\tau}{\varnothing}} \cup \fx{\annot{\Gamma}{\varnothing}} \subseteq \varepsilon_{s}$
	\item $\kwa{ho \hyphen safe}(\hat \tau_i, \varepsilon_s)$
\end{enumerate}

Then $\hat \Gamma, \kwa{annot}(\Gamma, \varepsilon_s), y: \hat \tau_i \vdash \kwa{annot}(e, \varepsilon_s) : \kwa{annot}(\tau, \varepsilon_s)~\kw{with} \varepsilon_s$.
\end{lemma}


The premises of the lemma are very specific to the premises of \textsc{$\varepsilon$-Import}, but generalised to accommodate a proof by induction: $e$ is allowed to typecheck with bindings in $\Gamma$, so long as $\Gamma$ does not introduce any resources whose authority is not already in $\varepsilon_s$. We need $\Gamma$ to keep track of effects introduced by function arguments. For example, typechecking $\kwa{f.write}$ requires a binding for $f$, but $\lambda f: \{\File\}.~\kwa{f.write}$ does not. Proving the lemma requires us to inductively step into the bodies of functions, at which point we need to keep track of what has been bound at that point --- to do this, we permit $e$ to typecheck in a larger environment $\Gamma$. We stipulate $\fx{\annot{\Gamma}{\varnothing}} \subseteq \varepsilon_s$ so that any effects captured by $\Gamma$ are not ambient. Note that when $\Gamma = \varnothing$ we have exactly the premises of \textsc{$\varepsilon$-Import}. When we apply the annotation lemma in the proof of preservation, we shall choose $\Gamma = \varnothing$. A proof-sketch of the annotation lemma is given below.

\begin{proof}
By induction on derivations of $\Gamma, y: \kwa{erase}(\hat \tau_i) \vdash e: \tau$.\\

\textit{Case:} \textsc{T-Var}. Then $e = x$. If $x \neq y$ use \textsc{$\varepsilon$-Var} and \textsc{$\varepsilon$-Subsume}. Otherwise $x = y$. Then $y: \erase{\hat \tau_i} \vdash x: \tau$ implies that $\hat \tau_i = \tau$. Apply the approximation lemma and simplify to obtain $\hat \tau_i <: \annot{\tau_i}{\varepsilon_s}$, then use \textsc{$\varepsilon$-Subsume} to get the result.\\

\textit{Case:} \textsc{T-Resource}. Use \textsc{$\varepsilon$-Resource} and \textsc{$\varepsilon$-Subsume}.\\

\textit{Case:} \textsc{T-Abs}. Use inversion to get a judgement for the body of the function $\Gamma, y: \erase{\hat \tau_i}, x: \tau_2 \vdash e_{body}: \tau_3~\kw{with} \varepsilon_s$. Apply the inductive hypothesis to $e_{body}$ with $\Gamma, x: \tau_2$ as the context in which $e_{body}$ typechecks, noting the premises for the inductive application are satisfied because $\hofx{\annot{\tau}{\varnothing}} \subseteq \varepsilon_s$ implies $\kwa{effects}(\annot{\tau_1}{\varnothing} \subseteq \varepsilon_s$. Then use \textsc{$\varepsilon$-Abs} and \textsc{$\varepsilon$-Subsume}.	\\

\textsc{Case:} \textsc{T-App}. Apply the inductive assumption to the subexpressions, then use \textsc{$\varepsilon$-App} and simplify.\\

\textsc{Case:} \textsc{T-OperCall}. Apply the inductive hypothesis to the receiver and use \textsc{$\varepsilon$-OperCall}. This gives the approximate effects $\varepsilon_s \cup \{ \bar r.\pi \}$. Consider where the binding for $\{ \bar r \}$ is in $\hat \Gamma, \annot{\Gamma}{\varepsilon_s}, y: \hat \tau$ and conclude that $\{ \bar r.\pi \} \subseteq \varepsilon_s$.
\end{proof}

Armed with the annotation lemma, we can now prove preservation.


\begin{theorem}[$\epscalc$ Preservation]
If $\hat \Gamma \vdash \hat e_A: \hat \tau_A~\kw{with} \varepsilon_A$ and $\hat e_A \longrightarrow \hat e_B~|~\varepsilon$, then $\hat \Gamma \vdash \hat e_B: \hat \tau_B~\kw{with} \varepsilon_B$, where $\hat e_B <: \hat e_A$ and $\varepsilon \cup \varepsilon_B \subseteq \varepsilon_A$, for some $\hat e_B, \varepsilon, \hat \tau_B, \varepsilon_B$.
\end{theorem}

\begin{proof} By induction on derivations of $\hat \Gamma \vdash \hat e_A: \hat \tau_A~\kw{with} \varepsilon_A$ and $\hat e_A \longrightarrow \hat e_B~|~\varepsilon$. \\

\textit{Case:} \textsc{$\varepsilon$-Import}. Then $e_A = \import{\varepsilon_s}{x}{\hat e}{e}$. If the reduction rule used was \textsc{E-Import1} then the result follows by applying the inductive hypothesis to $\hat e$. Otherwise $\hat e$ is a value and the reduction used was \textsc{E-Import2}. Apply the annotation lemma with $\Gamma = \varnothing$ to get the judgement $\hat \Gamma, x: \hat \tau \vdash \kwa{annot}(e, \varepsilon_s): \kwa{annot}(\tau, \varepsilon_s)~\kw{with} \varepsilon_s$. By assumption, $\hat \Gamma \vdash \hat v: \hat \tau~\kw{with} \varnothing$, so the substitution lemma applies, giving $\hat \Gamma \vdash [\hat v/x]\kwa{annot}(e, \varepsilon): \annot{\tau}{\varepsilon_s}$. Then $\varepsilon_B = \varepsilon_s = \varepsilon_A \cup \varepsilon$ and $\tau_A = \tau_B = \annot{\tau}{\varepsilon_s}$.
\end{proof}

From progress and preservation we can prove the single-step and multi-step soundness theorems for $\epscalc$. Their proofs are identical to the ones in $\opercalc$.

\begin{theorem}[$\epscalc$ Single-step Soundness]
If $\hat \Gamma \vdash \hat e_A: \hat \tau_A~\kw{with} \varepsilon_A$ and $\hat e_A$ is not a value, then $\hat e_A \longrightarrow \hat e_B~|~\varepsilon$, where $\hat \Gamma \vdash \hat e_B: \hat \tau_B~\kw{with} \varepsilon_B$ and $\hat \tau_B <: \hat \tau_A$ and $\varepsilon_B \cup \varepsilon \subseteq \varepsilon_A$, for some $\hat e_B$, $\varepsilon$, $\hat \tau_B$, and $\varepsilon_B$.
\end{theorem}

\begin{theorem}[$\epscalc$ Multi-step Soundness]
If $\hat \Gamma \vdash \hat e_A: \hat \tau_A~\kw{with} \varepsilon_A$ and $\hat e_A \longrightarrow^{*} e_B~|~\varepsilon$, then $\hat \Gamma \vdash \hat e_B: \hat \tau_B~\kw{with} \varepsilon_B$, where $\hat \tau_B <: \hat \tau_A$ and $\varepsilon_B \cup \varepsilon \subseteq \varepsilon_A$, for some $\hat \tau_B$, $\varepsilon_B$.
\end{theorem}