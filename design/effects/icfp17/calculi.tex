
\section{Calculi}

In this section we introduce a pair of languages: $\opercalc$ (operation calculus) and $\epscalc$ (capability calculus). $\opercalc$ extends the simply-typed lambda calculus with a notion of primitive capabilities and their operations. Every function is annotated with the effects it may incur. The static rules associate a type and a set of effects to programs; the resulting theory is sound with respect to both. We then generalise $\opercalc$ to obtain $\epscalc$, which allows unannotated code to be nested inside annotated code using a new $\kwa{import}$ construct in a capability-safe manner. A safe inference can be made about what effects the unannotated code might incur by inspecting the capabilities are passed into it.

The motivating examples in this section are written in a \textit{Wyvern}-like language. A more thorough discussion of Wyvern and how its programs can be translated into the calculi is given in section 4.

\subsection{$\opercalc$: Operation Calculus}

Primitive capabilities are passed into a program by the system environment and allow their bearer to perform some operations on a particular resource in the system environment. For example, a $\kwa{File}$ might provide read/write operations on a particular file in the file system. For convenience, we often conflate primitive capabilities with the resources they manipulate, referring to both as resources. An effect in $\opercalc$ is a particular operation invoked on some resource; for example, $\kwa{File.write}$. The pieces of an $\opercalc$ program are (conservatively) annotated with the effects they may incur at runtime. Annotations might be given in accordance with the principle of least authority to specify the maximum authority a component may exercise. When this authority is being exceeded, an effect system like that of $\opercalc$ will reject the program, signalling that the implementation is unsafe. For example, consider the pair of modules in Figure \ref{fig:opercalc_motivating}: the $\kwa{Logger}$ possesses a $\File$ capability and exposes a single function $\kwa{log}$. The $\kwa{Client}$ has a single function $\kwa{run}$ which, when passed a $\kwa{Logger}$, will invoke $\kwa{Logger.log}$.

\begin{figure}[h]
\vspace{-5pt}

\begin{lstlisting}
resource module Logger
require File

def log(): Unit with {File.append} =
    File.read
\end{lstlisting}

\begin{lstlisting}
module Client

def run(l: Logger): Unit with {File.append} =
    l.log()
\end{lstlisting}

\vspace{-7pt}
\caption{The implementation of $\kwa{Logger.log}$ exceeds its specified authority.}
\label{fig:opercalc_motivating}
\end{figure}

$\kwa{Client.run}$ and $\kwa{Logger.log}$ are both annotated with $\{ \kwa{File.append} \}$, but the (potentially malicious) implementation of $\kwa{Logger.log}$ incurs the $\kwa{File.read}$ effects. By the end of this section, we will have developed rules for $\opercalc$ that can determine such mismatches between specification and implementation in annotated code. The definition of soundness is also extended to consider whether the static rules safely approximate the runtime effects of a piece of code.

\subsubsection{$\opercalc$ Grammar}~\\

A grammar for $\opercalc$ programs is given in Figure \ref{fig:opercalc_grammar}.

\begin{figure}[h]
\vspace{-5pt}

\[
\begin{array}{lll}

\begin{array}{lllr}

e & ::= & ~ & exprs: \\
	& | & x & variable \\
	& | & v & value \\
	& | & e ~ e & application \\
	& | & e.\pi & operation~call \\
	&&\\

\end{array}

\begin{array}{lllr}

v & ::= & ~ & values: \\ 
	& | & r & resource~literal \\
	& | & \lambda x: \tau.e & abstraction \\
	&&\\

\end{array}

\end{array}
\]

\vspace{-7pt}
\caption{Grammar for $\opercalc$ programs.}
\label{fig:opercalc_grammar}
\end{figure}

A resource literal $r$ is a variable drawn from a fixed set $R$. Resources model those primitive capabilities into the program from the system environment. $\kwa{File}$ and $\kwa{Socket}$ are examples of resource literals. An operation call $e.\pi$ is the invocation of an operation $\pi$ on $e$. For example, invoking the $\kwa{open}$ operation on the $\kwa{File}$ resource would be $\kwa{File.open}$. Operations are drawn from a fixed set $\Pi$. Neither resources nor operations can be created or destroyed at runtime; they simply exist for the duration of the program.

An effect is a pair $(r, \pi) \in R \times \Pi$. Sets of effects are denoted $\varepsilon$. As shorthand, we write $r.\pi$ instead of $(r, \pi)$. Effects should be distinguished from operation calls: an operation call is the invocation of a particular operation on a particular resource in a program, while an effect is a mathematical object describing this behaviour. The notation $r.*$ is short-hand for the set $\{ r.\pi \mid \pi \in \Pi \}$, which contains every effect on $r$. Sometimes we abuse notation by conflating the effect $r.\pi$ with the singleton $\{ r.\pi \}$. We may also write things like $\{ r_1.*, r_2.* \}$, which should be understood as the set of all operations on $r_1$ and $r_2$.\\


\subsubsection{$\opercalc$ Dynamic Rules}~\\

When an operation call is reduced a runtime effect is said to have taken place. Reflecting this, a single-step judgement takes the form $e \longrightarrow e'~|~\varepsilon$, meaning a single computational step can be made to $e$ producing $e'$ and incurring the runtime effects $\varepsilon$ in the process; in the case of single-step reductions, $\varepsilon$ is at most a singleton.

During reduction an operation call may be evaluated. When this happens a runtime effect is said to have taken place. Reflecting this, the form of the single-step reduction judgement is now $e \longrightarrow e~|~\varepsilon$, which means that $e$ reduces to $e'$, incurring the set of effects $\varepsilon$ in the process. In the case of single-step reduction, $\varepsilon$ is at most a single effect. Judgements for single-step reductions are given in Figure \ref{fig:opercalc_singlestep}. The particular style of semantics we have chosen is small-step and call-by-value.

\begin{figure}[h]

\noindent
\fbox{$e \longrightarrow e~|~\varepsilon$}

\[
\begin{array}{c}

\infer[\textsc{(E-App1)}]
	{e_1 e_2 \longrightarrow e_1'~ e_2~|~\varepsilon}
	{e_1 \longrightarrow e_1'~|~\varepsilon}
	~~~~~~
\infer[\textsc{(E-App2)}]
	{v_1 ~ e_2 \longrightarrow v_1 ~ e_2'~|~\varepsilon} 
	{e_2 \longrightarrow e_2'~|~\varepsilon}
~~~~~~
\infer[\textsc{(E-App3)}]
	{ (\lambda x: \tau. e) v_2 \longrightarrow [ v_2/x] e~|~\varnothing }
	{}\\[4ex]
	
\infer[\textsc{(E-OperCall1)}]
	{ e.\pi \longrightarrow  e'.\pi~|~\varepsilon }
	{ e \rightarrow  e'~|~\varepsilon}
		
	~~~~~~
	
\infer[\textsc{(E-OperCall2)}]
	{r.\pi \longrightarrow \kwa{unit}~|~\{ r.\pi \} }
	{}
	 \\[4ex]
	 
\end{array}
\]


\vspace{-7pt}
\caption{Single-step reductions in $\opercalc$.}
\label{fig:opercalc_singlestep}
\end{figure}

The first three rules are analogous to reductions in the lambda calculus. \textsc{E-App1} and \textsc{E-App2} incur the effects of reducing their subexpressions. Because \textsc{E-App3} is simply performing a substitution, it incurs no effects. The first new rule is \textsc{E-OperCall1}, which reduces the receiver of an operation call; the effects incurred are the effects incurred by reducing the receiver. When an operation $\pi$ is invoked on a resource literal $r$, \textsc{E-OperCall2} will reduce it to $\unit$, incurring $\{ r.\pi \}$ as a result. For example, $\kwa{File.write} \longrightarrow \unit~|~\{ \kwa{File.write} \}$ by \textsc{E-OperCall2}.

$\unit$ is a derived form, which has the property of being the only value of its type (also called $\Unit$); because of this, it is used to represent the absence of information. $\opercalc$ does not model the semantics of particular operation calls, so $\unit$ is a sensible dummy-value for them to return. A formal treatment of $\unit$ is given in section 4.

A multi-step reduction can be defined as a sequence of zero\footnote{We permit multi-step reductions of length zero to be consistent with Pierce, who defines multi-step reduction as a reflexive relation \cite[p. 39]{pierce02}.} or more single-step reductions. The resulting set of runtime effects is the union of all the runtime effects from the intermediate single-steps. Judgements for multi-step reductions are given in Figure \ref{fig:opercalc_multistep_defn}.

\begin{figure}[h]

\noindent
\fbox{$ e \longrightarrow^{*}  e~|~\varepsilon$}

\[
\begin{array}{c}

\infer[\textsc{(E-MultiStep1)}]
	{ e \rightarrow^{*}  e~|~\varnothing}
	{}
~~~
\infer[\textsc{(E-MultiStep2)}]
	{ e \rightarrow^{*}  e'~|~\varepsilon}
	{ e \rightarrow  e'~|~\varepsilon}
~~~	
\infer[\textsc{(E-MultiStep3)}]
	{ e \rightarrow^{*}  e''~|~\varepsilon_1 \cup \varepsilon_2}
	{ e \rightarrow^{*}  e'~|~\varepsilon_1 &  e' \rightarrow^{*}  e''~|~\varepsilon_2}
\end{array}
\]

\vspace{-7pt}
\caption{Multi-step reductions in $\opercalc$.}
\label{fig:opercalc_multistep_defn}
\end{figure}

\textsc{E-MultiStep1} says that an expression can ``reduce'' to itself with no runtime effects. \textsc{E-MultiStep2} says that any single-step reduction is also a multi-step reduction. \textsc{E-MultiStep3} says that if $e \longrightarrow e'~|~\varepsilon_1$ and $e' \longrightarrow e''~|~\varepsilon_2$ are sequences of reductions, then so is $e \longrightarrow e''~|~\varepsilon_1 \cup \varepsilon_2$. \\

\subsubsection{$\opercalc$ Static Rules}~\\

A grammar for types and type contexts is given in Figure \ref{fig:opercalc_types}. The base types of $\opercalc$ are sets of resources, denoted $\{ \bar r\}$. If an expression $e$ is associated with type $\{ \bar r \}$, it means $e$ will reduce to one of the literals in $\bar r$ (assuming $e$ terminates). There is a single type constructor $\rightarrow_{\varepsilon}$, where $\varepsilon$ is a concrete set of effects. $\tau_1 \rightarrow_{\varepsilon} \tau_2$ is the type of a function which takes a $\tau_1$ as input, returns a $\tau_2$ as output, and whose body incurs no more than those effects in $\varepsilon$. $\varepsilon$ is a conservative bound: if an effect $r.\pi \in \varepsilon$, it is not guaranteed to happen at runtime, but if $r.\pi \notin \varepsilon$, it cannot happen at runtime. A typing context $\Gamma$ maps variables to types. 

\begin{figure}[h]
\vspace{-5pt}

\[
\begin{array}{lll}

\begin{array}{lllr}

\tau & ::= & ~ & types: \\
		& | & \{ \bar r \} \\
		& | & \tau \rightarrow_{\varepsilon} \tau \\ 
		&&\\
\end{array}

\begin{array}{lllr}

\Gamma & ::= & ~ & type~ctx: \\
				& | & \varnothing \\
				& | & \Gamma, x: \tau \\
				&&\\
\end{array}

\end{array}
\]

\vspace{-7pt}
\caption{Grammar for types in $\opercalc$.}
\label{fig:opercalc_types}
\end{figure}

This syntactic definition treats typing contexts as sequences of variable-type pairings, but they should be treated in the usual way. Resource-sets are also syntactically defined as sequences, but should be interpreted as sets: $\{ \kwa{File, Socket} \}$ and $\{ \kwa{Socket, File} \}$ are the same type. Lastly, the empty set of resources $\varnothing$ is a valid type, but has no inhabitants.

To illustrate the types of some functions, if $\kwa{log_1}$ has the type $\{ \kwa{File} \} \rightarrow_{\kwa{File.append}} \Unit$, then invoking $\kwa{log_1}$ will either incur $\kwa{File.append}$ or no effects. If $\kwa{log_2}$ has the type $\{ \kwa{File} \} \rightarrow_{\kwa{File.*}} \Unit$, then invoking $\kwa{log_2}$ could incur any effect on $\kwa{File}$.

Knowing approximately what effects a piece of code may incur helps a developer determine whether it can be trusted. For example, consider $\kwa{log_3} = \lambda f: \kwa{File}.~e$, which is a logging function that takes a $\kwa{File}$ as an argument and then executes $e$. Suppose this function were to typecheck as $\{ \File \} \rightarrow_{\{ \kwa{File.*} \}} \Unit$ --- seeing that invoking this function could incur any effect on $\kwa{File}$, and not just its expected least authority $\kwa{File.append}$, a developer may therefore decide this implementation cannot be trusted and choose not to execute it. In this spirit, the static rules of $\opercalc$ associate well-typed programs with a type and a set of effects: the judgement $\Gamma \vdash e: \tau~\kw{with} \varepsilon$, means $e$ will reduce to a term of type $\tau$ (assuming it terminates), incurring no more effects than those in $\varepsilon$. The rules are given in Figure \ref{fig:opercalc_static_rules}.

\begin{figure}[h]

\noindent
\fbox{$\Gamma \vdash e: \tau~\kw{with} \varepsilon$}

\[
\begin{array}{c}

\infer[\textsc{($\varepsilon$-Var)}]
	{ \Gamma, x:\tau \vdash x: \tau~\kw{with} \varnothing }
	{}
	
	~~~
	
\infer[\textsc{($\varepsilon$-Resource)}]
 	{ \Gamma, r: \{ r \} \vdash r : \{ r \}~\kw{with} \varnothing }
 	{} \\[3ex]
 	
 	~~~
	\infer[\textsc{($\varepsilon$-Abs)}]
	{ \Gamma \vdash \lambda x:\tau_2 . e : \tau_2 \rightarrow_{\varepsilon_3} \tau_3~\kw{with} \varnothing }
	{ \Gamma, x: \tau_2 \vdash e: \tau_3~\kw{with} \varepsilon_3 }
	
	~~~
	
\infer[\textsc{($\varepsilon$-App)}]
	{ \Gamma \vdash e_1~e_2 : \tau_3~\kw{with} \varepsilon_1 \cup \varepsilon_2 \cup \varepsilon  }
	{ \Gamma \vdash e_1: \tau_2 \rightarrow_{\varepsilon} \tau_3~\kw{with} \varepsilon_1 & \Gamma \vdash e_2: \tau_2~\kw{with} \varepsilon_2 } \\[3ex]
	
\infer[\textsc{($\varepsilon$-OperCall)}]
	{ \Gamma \vdash e.\pi: \kw{Unit} \kw{with} \{ \bar r.\pi \} }
	{ \Gamma \vdash e: \{ \bar r \}}

\infer[\textsc{($\varepsilon$-Subsume)}]
	{ \Gamma \vdash e: \tau' ~\kw{with} \varepsilon'}
	{ \Gamma \vdash e: \tau ~\kw{with} \varepsilon & \tau <: \tau' & \varepsilon \subseteq \varepsilon'}\\[3ex]
	
\end{array}
\]


\vspace{-7pt}
\caption{Type-with-effect judgements in $\opercalc$.}
\label{fig:opercalc_static_rules}
\end{figure}



\textsc{$\varepsilon$-Var} approximates the runtime effects of a variable as $\varnothing$. \textsc{$\varepsilon$-Resource} does the same for resource literals. Though a resource captures several effects (namely, every possible operation on itself), attempting to ``reduce'' a resource will incur no effects; something must be done with the resource, such as invoke an operation. For a similar reason, \textsc{$\varepsilon$-Abs} approximates the effects of a function literal as $\varnothing$, but its ascribed arrow type is annotated with those effects captured by the function. \textsc{$\varepsilon$-App} approximates a lambda application as incurring those effects from evaluating the subexpressions and the effects incurred by executing the body of the function to which the left-hand side evaluates. The effects of the function body are taken from the function's arrow type.

An operation call on a resource literal reduces to $\unit$ by \textsc{E-OperCall3}, so \textsc{$\varepsilon$-OperCall} ascribes the type of an operation call as $\Unit$. The approximate effects of an operation call are: the effects of reducing the subexpression, and then the operation $\pi$ on every possible resource which that subexpression to which that subexpression might reduce. For example, consider $e.\pi$, where $\Gamma \vdash e: \{ \kwa{File, Socket} \}~\kw{with} \varnothing$. Then $e$ could evaluate to $\kwa{File}$, in which case the actual runtime effect is $\kwa{File}.\pi$, or it could evaluate to $\kwa{Socket}$, in which case the actual runtime effect is $\kwa{Socket.\pi}$. Determining which will happen is, in general, undecidable; the safe approximation is to treat them both as happening.

The last rule \textsc{$\varepsilon$-Subsume} produces a new judgement by widening the type or approximate effects on an existing one. The subtyping judgement are given in Figure \ref{fig:opercalc_static_rules}.


\begin{figure}[h]
\vspace{-5pt}

\fbox{$\Gamma \vdash e: \tau~\kw{with} \varepsilon$}

\[
\begin{array}{c}

\infer[\textsc{(S-Arrow)}]
	{ \tau_1 \rightarrow_{\varepsilon} \tau_2 <: \tau_1' \rightarrow_{\varepsilon'} \tau_2' }
	{ \tau_1' <: \tau_1 & \tau_2 <: \tau_2' & \varepsilon \subseteq \varepsilon' }
~~~~~~
\infer[\textsc{(S-Resource)}]
	{ \{ \bar r_1 \} <: \{ \bar r_2 \} }
	{ r \in r_1 \implies r \in r_2 }

\end{array}
\]

\vspace{-7pt}
\caption{Subtyping judgements of $\opercalc$.}
\label{fig:opercalc_static_rules}
\end{figure}

The first subtyping rule is the standard rule for arrow types, but with an extra premise that the effects on the arrow of the subtype must be contained in the effects on the arrow of the supertype. To illustrate why, consider a $\kwa{log}$ function which is allowed to open, close, and append to files. Its interface might have the type $\Unit \rightarrow_{\{\kwa{File.open, File.close, File.append}\}} \Unit$. However, an implementation of $\kwa{log}$ might open $\kwa{File}$ and $\kwa{append}$, but not $\kwa{close}$. In this case it still meets the authority stipulated by the interface, and should be considered as a subtype. The other subtyping rule is \textsc{S-Resource}, which says a subset of resources is a subtype. To justify this rule, consider $\{ \bar r_1 \} <: \{ \bar r_2 \}$. Any value with type $\{ \bar r_1 \}$ can reduce to any resource literal in $\bar r_1$, so to be compatible with an interface $\{ \bar r_2 \}$, the resource literals in $\bar r_1$ must also be in $\bar r_2$.

These rules let us determine what sort of effects might be incurred when a piece of code is executed. For example, consider $c = (\lambda f: \{ \kwa{File, Socket} \}.~\kwa{f.write})~\kwa{File}$. The judgement $\vdash c: \Unit~\kw{with} \{ \kwa{File.write, Socket.write} \}$ holds, which means executing $e$ might incur $\kwa{File.write}$ or $\kwa{Socket.write}$. A derivation for it is given in Figure \ref{fig:opercalc_tree}. To fit in one diagram, all resources and operations have been abbreviated to their first letter. A developer who only expects a file-writer to be incurring $\kwa{File.write}$ can typecheck $\kwa{fwrite}$, see that it could also be writing to $\kwa{Socket}$, and decide it should not be used. If the client code $c$ were to annotate its effects as $\kwa{ \{ \kwa{File.write} \} }$, the type system would reject $c$ as an implementation.

\begin{figure}[h]


    \begin{prooftree*}

    		\Infer0[\textsc{($\varepsilon$-Var)}]{f: \{ \kwa{F}, \kwa{S} \} \vdash f: \{ \kwa{F}, \kwa{S} \}}
    		
    		\Infer1[\textsc{($\varepsilon$-OperCall)}]{\kwa{f}: \{ \kwa{F}, \kwa{S} \} \vdash \kwa{f.w} : \Unit~\kw{with} \{ \kwa{F.w, S.w} \} }
    		
    		\Infer1[\textsc{($\varepsilon$-Abs)}]{ \lambda \kwa{f}: \{ \kwa{F}, \kwa{S} \}. \kwa{f.w} : \{ \kwa{F, S} \} \rightarrow_{\kwa{F.w, S.w}} \Unit~\kw{with} \varnothing }
    		
    
       \Infer0[\textsc{($\varepsilon$-Resource)}]{\vdash \kwa{F}: \{ \kwa{F} \}~\kw{with} \varnothing}
    
    		\Infer2[\textsc{($\varepsilon$-App)}]{ \vdash (\lambda \kwa{f}: \{ \kwa{F, S} \}. \kwa{f.write})~\kwa{F} : \Unit~\kw{with} \{ \kwa{F.w, S.w} \}  }
    		
 	\end{prooftree*}
 	
\vspace{-12pt}
\caption{Derivation tree for $\vdash c: \Unit~\kw{with} \{ \kwa{File.write, Socket.write} \}$.}
\label{fig:opercalc_tree}
\end{figure}

\subsubsection{$\opercalc$ Proofs}~\\

To show the rules of $\opercalc$ are sound requires an appropriate notion of static approximations being safe with respect to the reductions. If a static judgement like $\Gamma \vdash e: \tau~\kw{with} \varepsilon$ were correct, then successive reductions on $e$ should never produce effects not in $\varepsilon$. Adding this to our definition of soundness yields the following first definition.


\begin{theorem}[$\opercalc$ Single-step Soundness]
If $ \Gamma \vdash  e_A:  \tau_A~\kw{with} \varepsilon_A$ and $ e_A$ is not a value, then $e_A \longrightarrow e_B~|~\varepsilon$, where $ \Gamma \vdash e_B:  \tau_B~\kw{with} \varepsilon_B$ and $ \tau_B <:  \tau_A$ and $\varepsilon_B \cup \varepsilon \subseteq \varepsilon_A$, for some $e, \varepsilon, \tau_B, \varepsilon_B$.
\end{theorem}

Our approach to proving soundness is to show progress and preservation, which in turn rely on $\opercalc$ versions of canonical forms and the substitution lemma. Canonical forms is stated below. The results are not true if the rule used is \textsc{$\varepsilon$-Subsume} (because the type and approximate effects of a value can be arbitrarily widened), so we must exclude that.

\begin{lemma}[$\opercalc$ Canonical Forms]
Unless the typing rule used was \textsc{$\varepsilon$-Subsume}, the following are true:
\begin{enumerate}
	\item If $\Gamma \vdash x: \tau~\kw{with} \varepsilon$ then $\varepsilon = \varnothing$.
	\item If $ \Gamma \vdash  v:  \tau~\kw{with} \varepsilon$ then $\varepsilon = \varnothing$.
	\item If $ \Gamma \vdash v: \{ \bar r \}~\kw{with} \varepsilon$ then $v = r$ and $\{ \bar r \} = \{ r \}$.
	\item If $\Gamma \vdash v: \tau_1 \rightarrow_{\varepsilon'} \tau_2~\kw{with} \varepsilon$ then $v = \lambda x:\tau. e$.
\end{enumerate}
\end{lemma}

The first two observations state that variables and values will always type with $\varnothing$ as their approximate effects. The third states that if a value is typed to a set of resources, the set of a singleton $\{ r \}$ and the value is the resource literal $r$. The fourth states that if a value types to a function then it is a function literal. From canonical forms, the progress theorem can be proved in a routine manner.

\begin{theorem}[$\opercalc$ Progress]
If $ \Gamma \vdash  e:  \tau~\kw{with} \varepsilon$ and $ e$ is not a value or variable, then $ e \longrightarrow  e'~|~\varepsilon$, for some $e', \varepsilon$.
\end{theorem}

\begin{proof} By induction on derivations of $ \Gamma \vdash  e:  \tau~\kw{with} \varepsilon$.
\end{proof}

To show preservation we need to know that type-and-effect safety is preserved by the substitution in \textsc{E-App3}. If a variable is replaced by an arbitrary expression, then we could also be introducing arbitrary effects, violating effect-safety. However, our semantics are call-by-value, so arguments are reduced to values before being bound to their formal name in the body of a function. By canonical forms, values be typed as having no effects, so performing the substitution in \textsc{E-App3} will not introduce any effects to the approximation. The version of the substitution lemma for $\opercalc$ therefore imposes the restriction that a variable is only being substituted for a value, and not any arbitrary expression. Beyond this observation, the proof is routine.

\begin{lemma}[$\opercalc$ Substitution]
If $\Gamma, x: \tau' \vdash e: \tau~\kw{with} \varepsilon$ and $\Gamma \vdash v: \tau'~\kw{with} \varnothing$ then $\Gamma \vdash [v/x]e: \tau~\kw{with} \varepsilon$.
\end{lemma}

\begin{proof} By induction on the derivation of $\Gamma, x: \tau' \vdash e: \tau~\kw{with} \varepsilon$.
\end{proof}

With this lemma, we can prove the preservation theorem.

\begin{theorem}[$\opercalc$ Preservation]
If $\Gamma \vdash e_A: \tau_A~\kw{with} \varepsilon_A$ and $e_A \longrightarrow e_B~|~\varepsilon$, then $\tau_B <: \tau_A$ and $\varepsilon_B \cup \varepsilon \subseteq \varepsilon_A$, for some $e_B, \varepsilon, \tau_B, \varepsilon_B$.
\end{theorem}

\begin{proof}  By induction on the derivation of $\Gamma \vdash e_A: \tau_A~\kw{with} \varepsilon_A$, and then the derivation of $e_A \longrightarrow e_B~|~\varepsilon$.
\end{proof}


Our single-step soundness theorem now holds immediately by joining the progress and preservation theorems into one. Knowing that single-step reductions are sound, the soundness of multi-step reductions can be shown by inductively applying single-step soundness on their length.

\begin{theorem}[$\opercalc$ Single-step Soundness]
If $ \Gamma \vdash  e_A:  \tau_A~\kw{with} \varepsilon_A$ and $ e_A$ is not a value, then $e_A \longrightarrow e_B~|~\varepsilon$, where $ \Gamma \vdash e_B:  \tau_B~\kw{with} \varepsilon_B$ and $ \tau_B <:  \tau_A$ and $\varepsilon_B \cup \varepsilon \subseteq \varepsilon_A$, for some $e_B, \varepsilon, \tau_B, \varepsilon_B$.
\end{theorem}
\begin{proof}
If $ e_A$ is not a value then the reduction exists by the progress theorem. The rest follows by the preservation theorem.
\end{proof}

\begin{theorem}[$\opercalc$ Multi-step Soundness]
If $ \Gamma \vdash  e_A:  \tau_A~\kw{with} \varepsilon_A$ and $e_A \longrightarrow^{*} e_B~|~\varepsilon$, where $\Gamma \vdash e_B: \tau_B~\kw{with} \varepsilon_B$ and $ \tau_B <: \tau_A$ and $\varepsilon_B \cup \varepsilon \subseteq \varepsilon_A$.
\end{theorem}

\begin{proof} By induction on the length of the multi-step reduction.
\end{proof}


\section{$\epscalc$: Capability Calculus}

$\opercalc$ requires every function to be annotated. The verbosity of such effect systems has been given as a reason for why they have not seen widespread use \cite{rytz2012} --- if we relax the requirement that all code be annotated, can a type system say anything useful about the parts which are not? The structured mixing of annotated and unannotated code can alleviate the verbosity of an effect system by allowing developers to rapidly prototype in the unannotated sublanguage and incrementally add annotations as they are needed, giving a balance between convenience and safety. However, reasoning about unannotated code is difficult in general. Figure \ref{fig:unannotated_reasoning} demonstrates the issue: $\kwa{someMethod}$ takes a function $f$ as input and executes it, but the effects of $f$ depend on its implementation. Without more information, such as extra constraints on the problem, more annotations, or a more complex type system, there is no way to know what effects might be incurred by $\kwa{someMethod}$.


\begin{figure}[h]
\begin{lstlisting}
def someMethod(f: Unit $\rightarrow$ Unit):
   f()
\end{lstlisting}
\vspace{-7pt}
\caption{What effects can $\kwa{someMethod}$ incur?}
\label{fig:unannotated_reasoning}
\end{figure}

A capability-safe design can help us: because the only authority which code can exercise is that which is explicitly given to them, the only capabilities that the unannotated code can use must be passed into it. If these capabilities are being passed in from an annotated environment, then we know what effects they capture. These effects are therefore a conservative upper bound on what can happen in the unannotated code. To demonstrate, consider a developer who wants to decide whether to use the $\kwa{Logger}$ module in Figure \ref{fig:cc_motivation}. It must be instantiated with two capabilities, $\kwa{File}$ and $\kwa{Socket}$, and provides an unannotated function $\kwa{log}$.

\begin{figure}[h]
\begin{lstlisting}
resource module Logger
require File
require Socket

def log(x: Unit): Unit
   ...
\end{lstlisting}
\vspace{-7pt}
\caption{In a capability-safe setting, $\kwa{Logger}$ can only exercise authority over the $\kwa{File}$ and $\kwa{Socket}$ capabilities given to it.}
\label{fig:cc_motivation}
\end{figure}

What effects will be incurred if $\kwa{Logger.log}$ is invoked? One approach is to manually examine its source code, but this is tedious and error-prone. In many real-world situations the source code may be obfuscated or unavailable. A capability-based argument can do better: the only authority which $\kwa{Logger}$ can exercise is that which it has been explicitly given. Here, the $\kwa{Logger}$ can be given a $\kwa{File}$ and a $\kwa{Socket}$, so $\kwa{ \{ \kwa{File.*, Socket.*} \} }$ is an upper bound on the effects of $\kwa{Logger}$. Knowing $\kwa{Logger}$ could be manipulating sockets, the developer decides this implementation cannot be trusted does not use it.

The reasoning we employed only required us to examine the interface of the unannotated code for the capabilities that must be passed into it. To model this situation in $\epscalc$, we add a new $\kwa{import}$ expression that selects what authority $\varepsilon$ the unannotated code may exercise. In the above case, $\kwa{Logger}$ would be selecting $\{ \kwa{File.*}, \kwa{Socket.*} \}$. The static rules can then check if the capabilities being passed in by the surrounding annotated environment violate $\varepsilon$. If not, then $\varepsilon$ is a safe approximation of the effects of the unannotated code. This is the key result of this report: when unannotated code is nested inside annotated code, capability-safety enables us to make a safe inference about its effects by examining what capabilities are being passed in by the annotated code.

\subsubsection{$\epscalc$ Grammar}

The grammar of $\epscalc$ is split into rules for annotated code and analogous rules for unannotated code. To distinguish the two, we put a hat above annotated types, expressions, and contexts: $\hat e$, $\hat \tau$, and $\hat \Gamma$ are annotated, while $e$, $\tau$, and $\Gamma$ are unannotated. The rules for unannotated programs and their types are given in Figure \ref{fig:epscalc_unannotated_grammar}.

\begin{figure}[h]
\vspace{-5pt}

\[
\begin{array}{lll}

\begin{array}{lllr}
e & ::= & ~ & exprs: \\
	& | & x & variable \\
	& | & v & value \\
	& | & e ~ e & application \\
	& | & e.\pi & operation \\
	&&\\

v & ::= & ~ & values: \\
	& | & r & resource~literal \\
	& | & \lambda x: \tau.e & abstraction \\
	&&\\
\end{array}

\begin{array}{lllr}

\tau & ::= & ~ & types: \\
		& | & \{ \bar r \} \\
		& | & \tau \rightarrow \tau \\ 
		&&\\

\Gamma & ::= & ~ & type~ctx: \\
				& | & \varnothing \\
				& | & \Gamma, x: \tau \\
				&&\\
				
\end{array}

\end{array}
\]

\vspace{-7pt}
\caption{Unannotated programs and types in $\epscalc$.}
\label{fig:epscalc_unannotated_grammar}
\end{figure}

The rules are much the same as in $\opercalc$, but the sole type-constructor $\rightarrow$ is not annotated with a set of effects. If an expression $e$ is associated with the type $\tau_1 \rightarrow \tau_2$, it means $e$ is a function which, when given a $\tau_1$, will return a $\tau_2$. This type says nothing about what effects may or may not be incurred by $e$. Unannotated types $\tau$ are built using $\rightarrow$ and sets of resources $\{ \bar r \}$. An unannotated context $\Gamma$ maps variables to unannotated types. Rules for annotated programs and their types are given in Figure \ref{fig:epscalc_annotated_grammar}. Except for the new $\kwa{import}$ expression, the rules are the same as in $\opercalc$. Annotated types $\hat \tau$ are built using the type constructor $\rightarrow_{\varepsilon}$ and sets of resources $\{ \bar r \}$. An annotated context $\hat \Gamma$ maps variables to annotated types.

\begin{figure}[h]
\vspace{-5pt}

\[
\begin{array}{lll}

\begin{array}{lllr}

\hat e & ::= & ~ & labelled~exprs: \\
	& | & x \\
	& | & \hat v \\
	& | & \hat e ~ \hat e \\
	& | & \hat e.\pi \\
	& | & \kwa{import}(\varepsilon)~x = \hat e~\kwa{in}~e & import \\
	&&\\

\hat v & ::= & ~ & labelled~values: \\
	& | & r \\
	& | & \lambda x: \hat \tau.\hat e \\
	&&\\

\end{array}

& ~~~~~~~~&

\begin{array}{lllr}

\hat \tau & ::= & ~ & labelled ~types: \\
		& | & \{ \bar r \} \\
		& | & \hat \tau \rightarrow_{\varepsilon} \hat \tau \\
		&&\\

\hat \Gamma & ::= & ~ & labelled~type~ctx:\\
				& | & \varnothing \\
				& | & \hat \Gamma, x: \hat \tau \\
				&&\\

\end{array}

\end{array}
\]

\vspace{-7pt}
\caption{Annotated programs and types in $\epscalc$.}
\label{fig:epscalc_annotated_grammar}
\end{figure}

The new form is $\import{\varepsilon}{x}{\hat e}{e}$. $e$ is some unannotated code, encapsulated by annotated code. $\hat e$ is the capability being given to it from the surrounding annotated environment. Inside the unannotated code, it is given the name $x$. $\varepsilon$ is the maximum authority that $e$ is allowed to exercise. 
As an example, suppose an unannotated $\kwa{Logger}$, which requires $\kwa{File}$, is expected to only $\kwa{append}$ to a file, but has an implementation that writes. This would be modelled by the expression $\import{\kwa{File.append}}{x}{\kwa{File}}{\kwa{x.write}}$. For simplicity, we assume only one capability is being passed into $e$. Generalising so that multiple capabilities can be passed in is straightforward, but we stick with a single import to reduce formal clutter.

 $\kwa{import}$ is the only way to mix annotated and unannotated code, because it is the only situation in which we can say something interesting about the unannotated code. For the rest of our discussion on $\epscalc$, we will only be interested in unannotated programs if they are encapsulated by annotated code inside an $\kwa{import}$ expression.

\subsubsection{$\epscalc$ Dynamic Rules}

Different approaches might be taken to define the small-step semantics of $\epscalc$: one is to define reductions for both annotated and unannotated programs, but this clutters the formalism with irrelevant, uninteresting rules. Another is to define reductions for either of the two and translate programs into the appropriate form before execution. Because our static rules focus on what can be said about unannotated code nested inside annotated code, we take the second approach: reductions are defined on annotated forms, and unannotated forms nested inside annotated code are transformed at runtime.

Excluding $\kwa{import}$, the annotated sublanguage of $\epscalc$ is the same as $\opercalc$, so we take the reduction rules of $\opercalc$ as also being reduction rules in $\epscalc$. For brevity, they are not restated. The new rules in $\epscalc$ are for reducing $\kwa{import}$ expressions. The idea is that when a piece of unannotated code $e$ is encountered inside annotated code, the surrounding $\kwa{import}$ has its selected authority $\varepsilon$, so we can annotate $e$ with $\varepsilon$ to wrangle it into a form that can be further reduced by the rules from $\opercalc$. To this end, we define $\annot{e}{\varepsilon}$ in Figure \ref{fig:annot_defn}, which recursively annotates the parts of $e$ with $\varepsilon$. There are versions of $\kwa{annot}$ defined for expressions and types. We need to annotate contexts later, so the definition is given here. It is worth mentioning that $\kwa{annot}$ operates on a purely syntatic level --- nothing prevents us from annotating a program with something that is type unsafe, so any use of $\kwa{annot}$ must be justified.

\begin{figure}[h]
\vspace{-5pt}

$\kwa{annot} :: e \times \varepsilon \rightarrow \hat e$

\begin{itemize}
	\setlength\itemsep{-0.2em}
	\item[] $\annot{r}{\_} = r$
	\item[] $\annot{\lambda x: \tau_1 . e}{\varepsilon} = \lambda x: \annot{\tau_1}{\varepsilon} . \annot{e}{\varepsilon}$
	\item[] $\annot{e_1~e_2}{\varepsilon} = \kwa{annot}(e_1, \varepsilon)~\kwa{annot}(e_2, \varepsilon)$
	\item[] $\annot{e_1.\pi}{\varepsilon} = \annot{e_1}{\varepsilon}.\pi$
\end{itemize}
	
$\kwa{annot} :: \tau \times \varepsilon \rightarrow \hat \tau$

\begin{itemize}
	\setlength\itemsep{-0.2em}
	\item[] $\annot{\{ \bar r \}}{\_} = \{ \bar r \}$
	\item[] $\annot{\tau \rightarrow \tau}{\varepsilon} = \tau \rightarrow_{\varepsilon} \tau$.	
\end{itemize}

$\kwa{annot} :: \Gamma \times \varepsilon \rightarrow \hat \Gamma$

\begin{itemize}
	\setlength\itemsep{-0.2em}
	\item[] $\annot{\varnothing}{\_} = \varnothing$
	\item[] $\annot{\Gamma, x: \tau}{\varepsilon} = \annot{\Gamma}{\varepsilon}, x: \annot{\tau}{\varepsilon}$
\end{itemize}

\vspace{-7pt}
\caption{Definition of $\kwa{annot}$.}
\label{fig:annot_defn}
\end{figure}

Before giving the dynamic rules we must update $\kwa{substitution}$. Because our dynamic rules are defined on annotated programs, so too will $\kwa{substitution}$ be defined. Except for the new case for $\kwa{import}$ expressions given in Figure \ref{fig:epscalc_sub_defn}, the definition is the same from $\opercalc$. We still require that variables be only replaced with values, to prevent the introduction of arbitrary effects.

\begin{figure}[h]

$\kwa{substitution :: \hat e \times \hat v \times \hat v \rightarrow \hat e}$

\begin{itemize}
	\setlength\itemsep{-0.7em}
	\item[] $[\hat v/y](\import{\varepsilon}{x}{\hat e}{e}) = \import{\varepsilon}{x}{[\hat v/y]\hat e}{e}$
\end{itemize}

\vspace{-7pt}
\caption{New case for $\kwa{substitution}$ in $\epscalc$.}
\label{fig:epscalc_sub_defn}
\end{figure}

The new single-step reductions on $\kwa{import}$ expressions are given in Figure \ref{fig:opercalc_reductions}. \textsc{E-Import1} reduces the definition of the capability being imported. If the capability being imported is a value $\hat v$, then \textsc{E-Import2} annotates $e$ with its selected authority $\varepsilon$ --- this is $\annot{e}{\varepsilon}$. The name of the capability $x$ is then replaced with its definition $\hat v$ --- this is $[\hat v/x]\annot{e}{\varepsilon}$. The single-step incurs no effects. Multi-step reductions are defined the same as in $\opercalc$, so we do not restate them.

\begin{figure}[h]

\noindent
\fbox{$\hat e \longrightarrow \hat e~|~\varepsilon$}

\[
\begin{array}{c}
\infer[\textsc{(E-Import1)}]
	{\kwa{import}(\varepsilon)~x = \hat e~\kw{in} e \longrightarrow \kwa{import}(\varepsilon)~x = \hat e'~\kw{in} e~|~\varepsilon'}
	{\hat e \longrightarrow \hat e'~|~\varepsilon'}\\[4ex]

\infer[\textsc{(E-Import2)}]
	{\kwa{import}(\varepsilon)~x = \hat v~\kw{in} e \longrightarrow [\hat v/x]\kwa{annot}(e, \varepsilon)~|~\varnothing}
	{}

\end{array}
\]


\vspace{-7pt}
\caption{New single-step reductions in $\epscalc$.}
\label{fig:opercalc_reductions}
\end{figure}

~\\

\subsubsection{$\epscalc$ Static Rules}~\\

A term might be annotated or unannotated, so we need to be able to recognise when either is well-typed. We do not reason about the effects of unannotated code directly, so judgements about them take the form $\Gamma \vdash e: \tau$. The subtyping judgement for unannotated code takes the form $\tau <: \tau$. A summary of these typing and subtyping rules is given in \ref{fig:unannotated_static_rules}; each is analogous to some rule in $\opercalc$, but the parts relating to effects have been removed.

\begin{figure}[h]
\vspace{-5pt}


\fbox{$\Gamma \vdash e: \tau$}

\[
\begin{array}{c}


\infer[\textsc{(T-Var)}]
	{\Gamma, x: \tau \vdash x: \tau}
	{}
~~~~~~
\infer[\textsc{(T-Resource)}]
	{\Gamma, r: \{ r \} \vdash r : \{ r \}}
	{}

~~~~~~
\infer[\textsc{(T-Abs)}]
	{\Gamma \vdash \lambda x: \tau_1.e : \tau_1 \rightarrow \tau_2}
	{\Gamma, x: \tau_1 \vdash e: \tau_2}\\[4ex]
	
\infer[\textsc{(T-App)}]
	{\Gamma \vdash e_1~e_2: \tau_3}
	{\Gamma \vdash e_1: \tau_2 \rightarrow \tau_3 & \Gamma \vdash e_2: \tau_2}
~~~~~~
\infer[\textsc{(T-OperCall)}]
	{\Gamma \vdash e.\pi: \kwa{Unit}}
	{\Gamma \vdash e: \{ \bar r \}}

\end{array}
\]



\fbox{$\tau <: \tau$}

\[
\begin{array}{c}

\infer[\textsc{(S-Arrow)}]
	{ \tau_1 \rightarrow \tau_2 <: \tau_1' \rightarrow \tau_2' }
	{ \tau_1' <: \tau_1 & \tau_2 <: \tau_2' }
	~~~
\infer[\textsc{(S-Resources)}]
	{ \{ \bar r_1 \} <: \{ \bar r_2 \} }
	{ \{ \bar r_1 \} \subseteq \{ \bar r_2 \} }

\end{array}
\]

\vspace{-7pt}
\caption{(Sub)typing judgements for the unannotated sublanguage of $\epscalc$}
\label{fig:unannotated_static_rules}
\end{figure}



Since the annotated subset of $\epscalc$ contains $\opercalc$, all the $\opercalc$ rules apply, but now we put hats on everything to signify that a typing judgement is being made about annotated code inside an annotated context. This looks like $\hat \Gamma \vdash \hat e: \hat \tau~\kw{with} \varepsilon$. Except for notation the judgements are the same, so we shall not repeat them. The only new rule is \textsc{$\varepsilon$-Import}, given in Figure \ref{fig:import_rule}, which gives the type and approximate effects of an $\kwa{import}$ expression. This is the only way to reason about what effects might be incurred by some unannotated code. The rule is complicated, so we start with a simple version and spend the rest of the section building up to the final version of \textsc{$\varepsilon$-Import}.

\begin{figure}[h]
\vspace{-5pt}

\[
\begin{array}{c}

\infer[\textsc{($\varepsilon$-Import)}]
	{ \hat \Gamma \vdash \kwa{import}(\varepsilon)~x = \hat e~\kw{in} e: \kwa{annot}(\tau, \varepsilon)~\kw{with} \varepsilon \cup \varepsilon_1 }
{{\def\arraystretch{1.4}
  \begin{array}{c}
\kwa{effects}(\hat \tau) \cup \hofx{\annot{\tau}{\varnothing}}\subseteq \varepsilon \\
\hat \Gamma \vdash \hat e: \hat \tau~\kw{with} \varepsilon_1 ~~~~~~ \kwa{ho \hyphen safe}(\hat \tau, \varepsilon) ~~~~~~ x: \kwa{erase}(\hat \tau) \vdash e: \tau
  \end{array}}} 
 
\end{array}
\]
\vspace{-7pt}
\caption{(Sub)typing judgements for the unannotated sublanguage of $\epscalc$}
\label{fig:import_rule}
\end{figure}

To begin, typing $\import{\varepsilon}{x}{\hat v}{e}$ in a context $\hat \Gamma$ requires us to know that the imported capability $\hat e$ is well-typed, so we add the premise $\hat \Gamma \vdash \hat e: \hat \tau~\kw{with} \varepsilon_1$. Since $x = \hat e$ is an import, it can be used throughout $e$. However, we do not want $e$ to exercise ambient authority beyond that which has been explicitly selected, so whatever capabilities are used must be selected by the $\kwa{import}$ expression; therefore, we require that $e$ can be typechecked using only the binding $x: \hat \tau$. There is a problem though: $e$ is unannotated and $\hat \tau$ is annotated, and there is no rule for typechecking unannotated code in an annotated context. To get around this, we define a function $\kwa{erase}$ in Figure \ref{fig:erase_defn} which removes the annotations from a type. We then add $x: \erase{\hat \tau} \vdash e: \tau$ as a premise.

\begin{figure}[h]
\vspace{-5pt}

$\kwa{erase} :: \hat \tau \rightarrow \tau$
\begin{itemize}
	\setlength\itemsep{-0.2em}
	\item[] $\erase{\{ \bar r \}}$
	\item[] $\erase{\hat \tau_1 \rightarrow_{\varepsilon} \hat \tau_2} = \erase{\hat \tau_1} \rightarrow \erase{\hat \tau_2}$
\end{itemize}

\vspace{-7pt}
\caption{Definition of $\kwa{erase}$.}
\label{fig:erase_defn}
\end{figure}

The first version of \textsc{$\varepsilon$-Import} is given in Figure \ref{fig:import_rule_1}. Since $\import{\varepsilon}{x}{\hat v}{e} \longrightarrow [\hat v/x]\annot{e}{\varepsilon}$ by \textsc{E-Import2}, it is sensible that its ascribed type would be $\annot{\tau}{\varepsilon}$, which is the type of the unannotated code, annotated with its selected authority $\varepsilon$. The effects of the $\kwa{import}$ are $\varepsilon_1 \cup \varepsilon$ --- the former comes from reducing the imported capability, which happens before the body of the $\kwa{import}$ is annotated and executed, and the latter contains all the effects which the unannotated code is allowed to incur. 


\begin{figure}[h]

\[
\begin{array}{c}

\infer[\textsc{($\varepsilon$-Import1)}]
	{ \hat \Gamma \vdash \import{\varepsilon}{x}{\hat e}{e}: \kwa{annot}(\tau, \varepsilon)~\kw{with} \varepsilon \cup \varepsilon_1 }
	{ \hat \Gamma \vdash \hat e: \hat \tau~\kw{with} \varepsilon_1 & x: \kwa{erase}(\hat \tau) \vdash e: \tau }

\end{array}
\]
\vspace{-7pt}
\caption{A first rule for type-and-effect checking $\kwa{import}$ expressions.}
\label{fig:import_rule_1}
\end{figure}

At the moment there is no relation between $\varepsilon$ --- the effects which $e$ is allowed to incur --- and those effects captured by the imported capability $\hat e$. Consider $\hat e' = \import{\varnothing}{x}{\File}{\kwa{x.write}}$, which imports a $\File$ and writes to it, but declares its authority as $\varnothing$. According to \textsc{$\varepsilon$-Import1}, $\vdash \hat e': \Unit~\kw{with} \varnothing$, but this is clearly wrong since $\hat e'$ writes to $\kwa{File}$. An $\kwa{import}$ should only be well-typed if the capability being import only captures effects that are in the unannotated code's selected authority $\varepsilon$. To this end we define a function $\kwa{effects}$, which collects the set of effects that an annotated type captures. A first definition is given in Figure \ref{fig:fx_defn}. We can then add the premise $\kwa{effects}(\hat \tau) \subseteq \varepsilon$ to require that any imported capability must not capture authority beyond that selected in $\varepsilon$. The updated rule is given in Figure \ref{fig:import_rule_2}.

\begin{figure}[h]

$\kwa{effects} :: \hat \tau \rightarrow \varepsilon$
\begin{itemize}
	\setlength\itemsep{-0.2em}
	\item[] $\fx{\{ \bar r \}} = \{ r.\pi \mid r \in \bar r, \pi \in \Pi \}$
	\item[] $\fx{\hat \tau_1 \rightarrow_{\varepsilon} \hat \tau_2} = \fx{\hat \tau_1} \cup \varepsilon \cup \fx{\hat \tau_2}$
\end{itemize}
\vspace{-7pt}
\caption{A first definition of $\kwa{effects}$.}
\label{fig:fx_defn}
\end{figure}

\begin{figure}[h]

\[
\begin{array}{c}

\infer[\textsc{($\varepsilon$-Import2)}]
	{ \hat \Gamma \vdash \import{\varepsilon}{x}{\hat e}{e}: \kwa{annot}(\tau, \varepsilon)~\kw{with} \varepsilon \cup \varepsilon_1 }
	{ \hat \Gamma \vdash \hat e: \hat \tau~\kw{with} \varepsilon_1 & x: \kwa{erase}(\hat \tau) \vdash e: \tau & \kwa{effects}(\hat \tau) \subseteq \varepsilon}

\end{array}
\]
\vspace{-7pt}
\caption{A second rule for type-and-effect checking $\kwa{import}$ expressions.}
\label{fig:import_rule_2}
\end{figure}

The counterexample from before is now rejected by \textsc{$\varepsilon$-Import2}, but there are still issues: the annotations on one import can be broken by another import. To illustrate, consider Figure \ref{fig:rule_import2_counterexample} where two\footnote{Our formalisation only permits a single capability to be imported, but this discussion leads to a generalisation needed for the rules be safe when multiple capabilities can be imported.} capabilities are imported. This program imports a function $\kwa{go}$ which, when given a $\Unit \rightarrow_{\varnothing} \Unit$ function with no effects, will execute it. The other import is $\kwa{File}$. The unannotated code creates a $\Unit \rightarrow \Unit$ function which writes to $\kwa{File}$ and passes it to $\kwa{go}$, which subsequently incurs $\kwa{File.write}$.

\begin{figure}[h]

\begin{lstlisting}
import({File.*})
   go = $\lambda$x: Unit $\rightarrow_{\varnothing}$ Unit. x unit
   f = File
in
   go ($\lambda$y: Unit. f.write)

\end{lstlisting}

\vspace{-7pt}
\caption{Permitting multiple imports will break \textsc{$\varepsilon$-Import2}.}
\label{fig:rule_import2_counterexample}
\end{figure}

In the world of annotated code it is not possible to pass a file-writing function to $\kwa{go}$, but because the judgement $x: \erase{\hat \tau} \vdash e: \tau$ discards the annotations on $\kwa{go}$, and since the file-writing function has type $\unit \rightarrow \unit$, the unannotated world accepts it. The $\kwa{import}$ selects $\{ \kwa{File.*} \}$ as its authority, which contains $\kwa{File.write}$, so the approximation is actually safe at the top-level, but it contains code that violates the type signature of $\kwa{go}$. We want to prevent this.

If $\kwa{go}$ had the type $\Unit \rightarrow_{\{ \kwa{File.write} \}} \Unit$ the above example would be safe, but a modified version where a file-reading function is passed to $\kwa{go}$ would have the same issue. $\kwa{go}$ is only safe when it expects every effect that the unannotated code might incur; if $\kwa{go}$ had the type $\Unit \rightarrow_{\{ \kwa{File.*} \}} \Unit$, then the unannotated code cannot pass it a capability with an effect it isn't already expecting, so the annotation on $\kwa{go}$ cannot be violated. Therefore we require imported capabilities to have authority to incur the effects in $\varepsilon$.

To achieve greater control in how we say this, the definition of $\kwa{effects}$ is split into two separate functions called $\kwa{effects}$ and $\kwa{ho \hyphen effects}$. If values of $\hat \tau$ possess a capability that can be used to incur the effect $r.\pi$, then $r.\pi \in \fx{\hat \tau}$. If values of $\hat \tau$ can incur an effect $r.\pi$, but need to be given the capability by someone else in order to do that, then $r.\pi \in \hofx{\hat \tau}$.


\begin{figure}[h]

$\kwa{effects} :: \hat \tau \rightarrow \varepsilon$

\begin{itemize}
	\setlength\itemsep{-0.2em}
	\item[] $\fx{\{ \bar r \}} = \{ r.\pi \mid r \in \bar r, \pi \in \Pi \}$
	\item[] $\fx{\hat \tau_1 \rightarrow_{\varepsilon} \hat \tau_2} = \hofx{\hat \tau_1} \cup \varepsilon \cup \fx{\hat \tau_2}$
\end{itemize}

$\kwa{ho \hyphen effects} :: \hat \tau \rightarrow \varepsilon$

\begin{itemize}
	\setlength\itemsep{-0.2em}
	\item[] $\hofx{\{ \bar r \}} = \varnothing$
	\item[] $\hofx{\hat \tau_1 \rightarrow_{\varepsilon} \hat \tau_2} = \fx{\hat \tau_1} \cup \hofx{\hat \tau_2}$
\end{itemize}

%\vspace{-7pt}
\caption{Effect functions.}
\label{fig:fx_defns}
\end{figure}

$\kwa{effects}$ and $\kwa{ho \hyphen effects}$ are mutually recursive, with base cases for resource types. Any effect can be directly incurred by a resource on itself, hence $\fx{\{ \bar r \}} = \{ r.\pi \mid r \in \bar r, \pi \in \Pi \}$. A resource cannot be used to indirectly invoke some other effect, so $\hofx{\{ \bar r \}} = \varnothing$. The mutual recursion echoes the subtyping rule for functions. Recall that functions are contravariant in their input type and covariant in their output type. The mutual recursion here is similar: both functions recurse on the input-type using the other function, and recurse on the output-type using the same function.

In light of these new definitions, we still require $\fx{\hat \tau} \subseteq \varepsilon$ --- unannotated code must select any effect its capabilities can incur --- but we add a new premise $\varepsilon \subseteq \hofx{\hat \tau}$, stipulating that imported capabilities must select every effect they could be given by unannotated code. The counterexample from Figure \ref{fig:rule_import2_counterexample} now rejects, because $\hofx{\Unit \rightarrow_{\varnothing} \Unit) \rightarrow_{\varnothing} \Unit} = \varnothing$, but $\{ \kwa{File.*} \} \not\subseteq \varnothing$, but this is \textit{still} not sufficient! Consider $\varepsilon \subseteq \hofx{ \hat \tau_1 \rightarrow_{\varepsilon'} \hat \tau_2 }$. We want \textit{every} higher-order capability involved to be expecting $\varepsilon$. Expanding the definition, $\varepsilon \subseteq \fx{\hat \tau_1} \cup \hofx{\hat \tau_2}$. Let $r.\pi \in \varepsilon$ and suppose $r.\pi \in \fx{\hat \tau_1}$, but $r.\pi \notin \hofx{\hat \tau_2}$. Then $\varepsilon \subseteq \fx{\hat \tau_1} \cup \hofx{\hat \tau_2}$ is still true, but $\hat \tau_2$ is not expecting $r.\pi$. Unannotated code could then violate the annotations on $\hat \tau_2$ by causing it to invoke $r.\pi$, using the same trickery from before. The cause of the issue is that $\subseteq$ does not distribute over $\cup$. We want a relation like $\varepsilon \subseteq \fx{\hat \tau_1} \cup \hofx{\hat \tau_2}$, but which also implies $\varepsilon \subseteq \fx{\hat \tau_1}$ and $\varepsilon \subseteq \fx{\hat \tau_2}$. Figure \ref{fig:safe_defns} defines this: $\kwa{safe}$ is a distributive version of $\varepsilon \subseteq \fx{\hat \tau}$ and $\kwa{ho \hyphen safe}$ is a distributive version of $\varepsilon \subseteq \hofx{\hat \tau}$.


\begin{figure}[h]

\noindent
$\fbox{$\safe{\hat \tau}{\varepsilon}$}$

\[
\begin{array}{c}

\infer[\textsc{(Safe-Resource)}]
	{}
	{ \{ r.\pi \mid r \in \bar r, \pi \in \Pi \} \subseteq \varepsilon } 
	
\infer[\textsc{(Safe-Arrow)}]
	{\kwa{safe}(\hat \tau_1 \rightarrow_{\varepsilon'} \hat \tau_2, \varepsilon)}
	{\varepsilon \subseteq \varepsilon' & \kwa{ho \hyphen safe}(\hat \tau_1, \varepsilon) & \kwa{safe}(\hat \tau_2, \varepsilon)} \\[3ex]

\end{array}
\]

\noindent
$\fbox{$\hosafe{\hat \tau}{\varepsilon}$}$

\[
\begin{array}{c}

\infer[\textsc{(HOSafe-Resource)}]
	{ \kwa{ho \hyphen safe}( \{ \bar r \}, \varepsilon)} 
	{}

\infer[\textsc{(HOSafe-Arrow)}]
	{ \kwa{ho \hyphen safe}( \hat \tau_1 \rightarrow_{\varepsilon'} \hat \tau_2, \varepsilon ) }
	{ \kwa{safe}(\hat \tau_1, \varepsilon)  & \kwa{ho \hyphen safe}(\hat \tau_2, \varepsilon) }\\[3ex]

\end{array}
\]

\vspace{-7pt}
\caption{Safety judgements in $\epscalc$.}
\label{fig:safe_defns}
\end{figure}

Note again how the mutual recursion of $\kwa{safe}$ and $\kwa{ho \hyphen safe}$ mimics the co(ntra)variance rules for function subtyping. Some properties are also immediate: $\safe{\hat \tau}{\varepsilon}$ implies $\varepsilon \subseteq \fx{\hat \tau}$ and $\hosafe{\hat \tau}{\varepsilon}$ implies $\varepsilon \subseteq \hofx{\hat \tau}$, but the converses are not true, because the safety predicates are distributive and therefore stronger.

An amended version of \textsc{$\varepsilon$-Import} is given in Figure \ref{fig:import_rule3}. It contains a new premise $\hosafe{\hat \tau}{\varepsilon}$ which formalises the notion that every capability which could given to a value of $\hat \tau$ --- or any of its constituent pieces --- must be expecting the effects in $\varepsilon$ that it might be given in the unannotated code.

\begin{figure}[h]

\[
\begin{array}{c}

\infer[\textsc{($\varepsilon$-Import3)}]
	{ \hat \Gamma \vdash \kwa{import}(\varepsilon)~x = \hat e~\kw{in} e: \kwa{annot}(\tau, \varepsilon)~\kw{with} \varepsilon \cup \varepsilon_1 }
{{\def\arraystretch{1.4}
  \begin{array}{c}
\hat \Gamma \vdash \hat e: \hat \tau~\kw{with} \varepsilon_1
~~~~~~
\kwa{effects}(\hat \tau) \subseteq \varepsilon \\
\hosafe{\hat \tau}{\varepsilon} ~~~~~~ x: \kwa{erase}(\hat \tau) \vdash e: \tau
  \end{array}}} 
 
\end{array}
\]

\vspace{-7pt}
\caption{A third rule for type-and-effect checking $\kwa{import}$ expressions.}
\label{fig:import_rule3}
\end{figure}

The premises so far restrict what authority can be selected by unannotated code, but what about authority passed as a function argument? Consider the example $\hat e = \import{\varnothing}{x}{\unit}{\lambda f: { \File }.~\kwa{f.write}}$. The unannotated code selects no capabilities and returns a function which, when given $\kwa{File}$, incurs $\kwa{File.write}$. This satisfies the premises in \textsc{$\varepsilon$-Import3}, but its annotated type is $\{ \File \} \rightarrow_{\varnothing} \Unit$ --- not good!

Suppose the unannotated code defines a function $f$, which gets annotated with $\varepsilon$ to produce $\annot{f}{\varepsilon}$. Suppose $\annot{f}{\varepsilon}$ is invoked at a later point and incurs the effect $r.\pi$. What is the source of $r.\pi$? If $r.\pi$ was selected by the $\kwa{import}$ expression surrounding $f$, it is safe for $\annot{f}{\varepsilon}$ to incur this effect. Otherwise, $\annot{f}{\varepsilon}$ may have been passed an argument which can be used to incur $r.\pi$, in which case $r.\pi$ is a higher-order effect of $\annot{f}{\varepsilon}$. If the argument is a function, then by the soundness of $\opercalc$, it must be that $r.\pi \in \varepsilon$, or it will not typecheck. If the argument is a resource $r$ then $\annot{f}{\varepsilon}$ may exercise $r.\pi$, which our rule does not yet account for.



We want $\varepsilon$ to contain every effect captured by resources passed into $\annot{f}{\varepsilon}$ as arguments. We can do this by inspecting its (unannotated type) for resource sets. For example, if the unannotated code has the type $\kwa{ \{ File \} \rightarrow \Unit}$, then we need $\kwa{ \{ File.* \} }$ in $\varepsilon$. To do this, we add a new premise $\hofx{\annot{\tau}{\varnothing}} \subseteq \varepsilon$. $\kwa{ho \hyphen effects}$ is only defined on annotated types, so we first annotate $\tau$ with $\varnothing$. We are only inspecting the resources passed into $f$ as an argument, so the annotations on the arrow should be ignored -- annotating $\tau$ with $\varnothing$ is therefore a good choice.

We can now handle the example from before: $\import{\varnothing}{x}{\unit}{\lambda f: { \File }.~\kwa{f.write}}$. The unannotated code types via the judgement $x: \Unit \vdash \lambda f: \{ \File \}.~\kwa{f.write}: \{ \File \} \rightarrow \Unit$. Its higher-order effects are $\hofx{\annot{ \{ \File \} \rightarrow \Unit}{\varnothing}} = \{ \kwa{File.*} \}$, but $\{ \kwa{File.*} \} \not\subseteq \varnothing$, so the example safely rejects.

The final version of \textsc{$\varepsilon$-Import} is given in Figure \ref{fig:import_rule}.

\begin{figure}[h]

\[
\begin{array}{c}

\infer[\textsc{($\varepsilon$-Import)}]
	{ \hat \Gamma \vdash \kwa{import}(\varepsilon)~x = \hat e~\kw{in} e: \kwa{annot}(\tau, \varepsilon)~\kw{with} \varepsilon \cup \varepsilon_1 }
{{\def\arraystretch{1.4}
  \begin{array}{c}
\kwa{effects}(\hat \tau) \cup \hofx{\annot{\tau}{\varnothing}}\subseteq \varepsilon \\
\hat \Gamma \vdash \hat e: \hat \tau~\kw{with} \varepsilon_1 ~~~~~~ \kwa{ho \hyphen safe}(\hat \tau, \varepsilon) ~~~~~~ x: \kwa{erase}(\hat \tau) \vdash e: \tau
  \end{array}}} 
 
\end{array}
\]


\vspace{-7pt}
\caption{The final rule for typing imports.}
\label{fig:import_rule}
\end{figure}

We can now model the example from the beginning of Section 3.2., where the $\kwa{Logger}$ implementation selects the capabilities $\kwa{File}$ and $\kwa{Socket}$ and exposes an unannotated function $\kwa{log}$ with type $\Unit \rightarrow \Unit$. If we applied \textsc{$\varepsilon$-Import}, it would annotate $\kwa{log}$ so it has the type $\Unit \rightarrow_{ \{ \kwa{File.*, Socket.*} \} } \Unit$. If an annotated $\kwa{Client}$ only expects the $\kwa{File.append}$ effect, the $\opercalc$ rules will reject any attempt to give $\kwa{Logger}$ to $\kwa{Client}$ because $\kwa{ \{ File.*, Socket.* \} }$ exceeds $ \kwa{ \{File.append  \}}$. More detailed examples are given in Chapter 4.\\

\subsubsection{$\epscalc$ Soundness} ~\\

Only annotated programs can be reduced and have their effects approximated, so the statement of soundness only applies to them. The theorem statement is given below.

\begin{theorem}[$\epscalc$ Single-step Soundness]
If $\hat \Gamma \vdash \hat e_A: \hat \tau_A~\kw{with} \varepsilon_A$ and $\hat e_A$ is not a value, then $\hat e_A \longrightarrow \hat e_B~|~\varepsilon$, where $\hat \Gamma \vdash \hat e_B: \hat \tau_B~\kw{with} \varepsilon_B$ and $\hat \tau_B <: \hat \tau_A$ and $\varepsilon_B \cup \varepsilon \subseteq \varepsilon_A$, for some $\hat e_B, \varepsilon, \hat \tau_B, \varepsilon_B$.
\end{theorem}

From here onwards we adopt a different convention to avoid name clashes. The selected authority of an $\kwa{import}$ is written $\varepsilon_{s}$ (``epsilon select'') and the imported capability is written $\hat e_i$ or $\hat v_i$ (``e import'' and ``v import''), and has type $\tau_i$ and approximate effects $\varepsilon_i$.

The rules of $\opercalc$ are also rules of $\epscalc$, and have been proven sound in Section 3.1.4., so we do not repeat them here. We present the same theorems and lemmas, but only discuss and prove the cases which use new rules from $\epscalc$. If a lemma is new, we prove all its cases. We begin with canonical forms, which is unchanged. The substitution lemma gains an extra case, but the proof is routine.

\begin{lemma}[$\epscalc$ Canonical Forms]
Unless the rule used is \textsc{$\varepsilon$-Subsume}, the following are true:
\begin{enumerate}
	\setlength\itemsep{-0.2em}
	\item If $\hat \Gamma \vdash x: \hat \tau~\kw{with} \varepsilon$ then $\varepsilon = \varnothing$.
	\item If $\hat \Gamma \vdash \hat v: \hat \tau~\kw{with} \varepsilon$ then $\varepsilon = \varnothing$.
	\item If $\hat \Gamma \vdash \hat v: \{ \bar r \}~\kw{with} \varepsilon$ then $\hat v = r$ and $\{ \bar r \} = \{ r \}$.
	\item If $\hat \Gamma \vdash \hat v: \hat \tau_1 \rightarrow_{\varepsilon'} \hat \tau_2~\kw{with} \varepsilon$ then $\hat v = \lambda x:\tau. \hat e$.
\end{enumerate}
\end{lemma}

\begin{lemma}[$\epscalc$ Substitution]
If $\hat \Gamma, x: \hat \tau' \vdash \hat e: \hat \tau~\kw{with} \varepsilon$ and $\hat \Gamma \vdash \hat v: \hat \tau'~\kw{with} \varnothing$ then $\hat \Gamma \vdash [\hat v/x]\hat e: \hat \tau~\kw{with} \varepsilon$.
\end{lemma}

\begin{proof} By induction on the derivation of $\hat \Gamma, x: \hat \tau' \vdash \hat e: \hat \tau~\kw{with} \varepsilon$.\\

\textit{Case:} \textsc{$\varepsilon$-Import}. By definition, $[\hat v/y](\import{\varepsilon_s}{y}{\hat e_i}{e}) = \import{\varepsilon_s}{y}{[\hat v/x] \hat e_i}{e}$. The result follows by applying the inductive assumption to $[\hat v/x] \hat e_i$.
\end{proof}

The progress theorem also has an extra, routine case.

\begin{theorem}[$\epscalc$ Progress]
If $\hat \Gamma \vdash \hat e: \hat \tau~\kw{with} \varepsilon$ and $\hat e$ is not a value, then $\hat e \longrightarrow \hat e'~|~\varepsilon$, for some $\hat e', \varepsilon$.
\end{theorem}

\begin{proof} By induction on the derivation of $\hat \Gamma \vdash \hat e: \hat \tau~\kw{with} \varepsilon$.\\

\textit{Case:} \textsc{$\varepsilon$-Import}. Then $\hat e = \import{\varepsilon_s}{x}{\hat e_i}{e}$. If $\hat e_i$ is a non-value then $\hat e$ reduces by \textsc{E-Import1}. Otherwise $\hat e$ reduces by \textsc{E-Import2}.
\end{proof}

The preservation theorem has an extra case for when the typing rule used is \textsc{$\varepsilon$-Import}. This has two subcases, depending on whether the reduction rule used was \textsc{E-Import1} and \textsc{E-Import2}. The former is straightforward to prove, but the latter is tricky; we need several lemmas to do it. Firstly, since $\varepsilon_s$ is an upper bound on what effects can be incurred by the unannotated code, it should also be an upper bound on what effects can be incurred by the capabilities passed into the unannotated code; therefore, if we take $\hat \tau_i$ and replace its annotations with $\varepsilon_s$, we should get a more general function type $\hat \tau_i <: \annot{\erase{\hat \tau_i}}{\varepsilon}$. This result is given as the pair of lemmas below.

\begin{lemma}[$\epscalc$ Approximation 1]
If $\kwa{effects}(\hat \tau) \subseteq \varepsilon$ and $\kwa{ho \hyphen safe}(\hat \tau, \varepsilon)$ then $\hat \tau <: \kwa{annot}(\kwa{erase}(\hat \tau), \varepsilon)$.
\end{lemma}

\begin{lemma}[$\epscalc$ Approximation 2]
If $\kwa{ho \hyphen effects}(\hat \tau) \subseteq \varepsilon$ and $\safe{\hat \tau}{\varepsilon}$ then $\kwa{annot(erase}(\hat \tau), \varepsilon) <: \hat \tau$.
\end{lemma}

\begin{proof}
By simultaneous induction on derivations of $\hosafe{\hat \tau}{\varepsilon}$ and $\safe{\hat \tau}{\varepsilon}$.
\end{proof}

Recall that function types are contravariant in their input, so the subtyping and subsetting relations flip direction when considering the input type of a function. This is why there are two lemmas: one for each direction.

Now, if \textsc{E-Import2} is applied, the reduction has the form $\import{\varepsilon_{s}}{x}{\hat v_i}{e} \longrightarrow [\hat v_i/x]\annot{e}{\varepsilon_s}~|~\varnothing$. Since $x: \erase{\hat \tau} \vdash e: \tau$, it is reasonable to expect that (1) $\hat \Gamma \vdash \annot{e}{\varepsilon_s}: \annot{\tau}{\varepsilon_s}~\kw{with} \varepsilon_s$ would be true, because although $\annot{e}{\varepsilon_s}$ has annotations and $e$ does not, annotations do not change runtime semantics --- the two programs have the same structure and capture the same effects. If judgement (1) holds, then $\hat \Gamma \vdash [\hat v_i/x]\annot{e}{\varepsilon_s}: \annot{\tau}{\varepsilon_s}~\kw{with} \varepsilon_s$ would hold by the substitution lemma. That judgement (1) does hold is the subject of the following lemma.

\begin{lemma}[$\epscalc$ Annotation]
If the following are true:

\begin{enumerate}
	\item $\hat \Gamma \vdash \hat v_i : \hat \tau_i~\kw{with} \varnothing$
	\item $\Gamma, y: \kwa{erase}(\hat \tau_i) \vdash e: \tau$
	\item $\kwa{effects}(\hat \tau_i) \cup \hofx{\annot{\tau}{\varnothing}} \cup \fx{\annot{\Gamma}{\varnothing}} \subseteq \varepsilon_{s}$
	\item $\kwa{ho \hyphen safe}(\hat \tau_i, \varepsilon_s)$
\end{enumerate}

\noindent
Then $\hat \Gamma, \kwa{annot}(\Gamma, \varepsilon_s), y: \hat \tau_i \vdash \kwa{annot}(e, \varepsilon_s) : \kwa{annot}(\tau, \varepsilon_s)~\kw{with} \varepsilon_s$.
\end{lemma}


The premises of the lemma are very specific to the premises of \textsc{$\varepsilon$-Import}, but generalised to accommodate a proof by induction: $e$ is allowed to typecheck with bindings in $\Gamma$, so long as $\Gamma$ does not introduce any resources whose authority is not already in $\varepsilon_s$. We need $\Gamma$ to keep track of effects introduced by function arguments. For example, typechecking $\kwa{f.write}$ requires a binding for $f$, but $\lambda f: \{\File\}.~\kwa{f.write}$ does not. Proving the lemma requires us to inductively step into the bodies of functions, at which point we need to keep track of what has been bound at that point --- to do this, we permit $e$ to typecheck in a larger environment $\Gamma$. We stipulate $\fx{\annot{\Gamma}{\varnothing}} \subseteq \varepsilon_s$ so that any effects captured by $\Gamma$ are not ambient. Note that when $\Gamma = \varnothing$ we have exactly the premises of \textsc{$\varepsilon$-Import}. When we apply the annotation lemma in the proof of preservation, we choose $\Gamma = \varnothing$.

The proof of the annotation lemma is quite long, but a sketch for each case is given below.

\begin{proof}
By induction on derivations of $\Gamma, y: \kwa{erase}(\hat \tau_i) \vdash e: \tau$.\\

\textit{Case:} \textsc{T-Var}. Then $e = x$. If $x \neq y$ use \textsc{$\varepsilon$-Var} and \textsc{$\varepsilon$-Subsume}. Otherwise $x = y$. Then $y: \erase{\hat \tau_i} \vdash x: \tau$ implies that $\hat \tau_i = \tau$. Apply the approximation lemma and simplify to obtain $\hat \tau_i <: \annot{\tau_i}{\varepsilon_s}$, and then use \textsc{$\varepsilon$-Subsume} to get the result.\\

\textit{Case:} \textsc{T-Resource}. Use \textsc{$\varepsilon$-Resource} and \textsc{$\varepsilon$-Subsume}.\\

\textit{Case:} \textsc{T-Abs}. Use inversion to get a judgement for the body of the function $\Gamma, y: \erase{\hat \tau_i}, x: \tau_2 \vdash e_{body}: \tau_3~\kw{with} \varepsilon_s$. Apply the inductive hypothesis to $e_{body}$ with $\Gamma, x: \tau_2$ as the context in which $e_{body}$ typechecks, noting the premises for the inductive application are satisfied because $\hofx{\annot{\tau}{\varnothing}} \subseteq \varepsilon_s$ implies $\kwa{effects}(\annot{\tau_2}{\varnothing} \subseteq \varepsilon_s$. Then use \textsc{$\varepsilon$-Abs} and \textsc{$\varepsilon$-Subsume}.	\\

\textsc{Case:} \textsc{T-App}. Apply the inductive assumption to the subexpressions, then use \textsc{$\varepsilon$-App} and simplify.\\

\textsc{Case:} \textsc{T-OperCall}. Apply the inductive hypothesis to the receiver and use \textsc{$\varepsilon$-OperCall}. This gives the approximate effects $\varepsilon_s \cup \{ \bar r.\pi \}$. Consider where the binding for $\{ \bar r \}$ is in $\hat \Gamma, \annot{\Gamma}{\varepsilon_s}, y: \hat \tau$ and conclude that $\{ \bar r.\pi \} \subseteq \varepsilon_s$.\\

\end{proof}

\noindent


Armed with the annotation lemma, we can now prove the preservation theorem.


\begin{theorem}[$\epscalc$ Preservation]
If $\hat \Gamma \vdash \hat e_A: \hat \tau_A~\kw{with} \varepsilon_A$ and $\hat e_A \longrightarrow \hat e_B~|~\varepsilon$, then $\hat \Gamma \vdash \hat e_B: \hat \tau_B~\kw{with} \varepsilon_B$, where $\hat e_B <: \hat e_A$ and $\varepsilon \cup \varepsilon_B \subseteq \varepsilon_A$, for some $\hat e_B, \varepsilon, \hat \tau_B, \varepsilon_B$.
\end{theorem}

\begin{proof} By induction on $\hat \Gamma \vdash \hat e_A: \hat \tau_A~\kw{with} \varepsilon_A$, and then on $\hat e_A \longrightarrow \hat e_B~|~\varepsilon$. \\

\textit{Case:} \textsc{$\varepsilon$-Import}. Then $e_A = \import{\varepsilon}{x}{\hat e}{e}$. If the reduction rule used was \textsc{E-Import1} then the result follows by applying the inductive hypothesis to $\hat e$.

Otherwise $\hat e$ is a value and the reduction used was \textsc{E-Import2}. The following are true:
\begin{enumerate}
	\item $e_A = \kwa{import}(\varepsilon)~x = \hat v~\kw{in} e$
	\item $\hat \Gamma \vdash e_A: \kwa{annot}(\tau, \varepsilon)~\kw{with} \varepsilon \cup \varepsilon_1$
	\item $\kwa{import}(\varepsilon)~x = \hat v~\kw{in} e \longrightarrow [\hat v/x]\kwa{annot}(e, \varepsilon)~|~\varnothing$
	\item $\hat \Gamma \vdash \hat v: \hat \tau~\kw{with} \varnothing$
	\item $\varepsilon = \kwa{effects}(\hat \tau)$
	\item $\kwa{ho \hyphen safe}(\hat \tau, \varepsilon)$
	\item $x: \kwa{erase}(\hat \tau) \vdash e: \tau$
\end{enumerate}

\noindent
Apply the annotation lemma with $\Gamma = \varnothing$ to get $\hat \Gamma, x: \hat \tau \vdash \kwa{annot}(e, \varepsilon): \kwa{annot}(\tau, \varepsilon)~\kw{with} \varepsilon$. From assumption (4) we know $\hat \Gamma \vdash \hat v: \hat \tau~\kw{with} \varnothing$, so the substitution lemma may be applied, giving $\hat \Gamma \vdash [\hat v/x]\kwa{annot}(e, \varepsilon): \kwa{annot}(\tau, \varepsilon)~\kw{with} \varepsilon$. By canonical forms, $\varepsilon_1 = \varepsilon = \varnothing$. Then $\varepsilon_B = \varepsilon = \varepsilon_A \cup \varepsilon$. By examination, $\tau_A = \tau_B = \kwa{annot}(\tau, \varepsilon)$.
\end{proof}

From progress and preservation we can prove the single-step and multi-step soundness theorems for $\epscalc$. The proofs are identical to the ones in $\opercalc$.

\begin{theorem}[$\epscalc$ Single-step Soundness]
If $\hat \Gamma \vdash \hat e_A: \hat \tau_A~\kw{with} \varepsilon_A$ and $\hat e_A$ is not a value, then $\hat e_A \longrightarrow \hat e_B~|~\varepsilon$, where $\hat \Gamma \vdash \hat e_B: \hat \tau_B~\kw{with} \varepsilon_B$ and $\hat \tau_B <: \hat \tau_A$ and $\varepsilon_B \cup \varepsilon \subseteq \varepsilon_A$, for some $\hat e_B$, $\varepsilon$, $\hat \tau_B$, and $\varepsilon_B$.
\end{theorem}

\begin{theorem}[$\epscalc$ Multi-step Soundness]
If $\hat \Gamma \vdash \hat e_A: \hat \tau_A~\kw{with} \varepsilon_A$ and $\hat e_A \longrightarrow^{*} e_B~|~\varepsilon$, then $\hat \Gamma \vdash \hat e_B: \hat \tau_B~\kw{with} \varepsilon_B$, where $\hat \tau_B <: \hat \tau_A$ and $\varepsilon_B \cup \varepsilon \subseteq \varepsilon_A$, for some $\hat \tau_B$, $\varepsilon_B$.
\end{theorem}








