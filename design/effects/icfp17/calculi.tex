
\section{Calculi}

In this section we introduce a pair of languages: $\opercalc$ (operation calculus) and $\epscalc$ (capability calculus). $\opercalc$ extends the simply-typed lambda calculus with a notion of primitive capabilities and their operations. Every function is annotated with the effects it may incur. The static rules associate a type and a set of effects to programs; the resulting theory is sound with respect to both. We then generalise $\opercalc$ to obtain $\epscalc$, which allows unannotated code to be nested inside annotated code using a new $\kwa{import}$ construct in a capability-safe manner. A safe inference can be made about what effects the unannotated code might incur by inspecting the capabilities are passed into it.

The motivating examples in this section are written in a \textit{Wyvern}-like language. A more thorough discussion of Wyvern and how its programs can be translated into the calculi is given in section 4.

\subsection{$\opercalc$: Operation Calculus}

Primitive capabilities are passed into a program by the system environment and allow their bearer to perform some operations on a particular resource in the system environment. For example, a $\kwa{File}$ might provide read/write operations on a particular file in the file system. For convenience, we often conflate primitive capabilities with the resources they manipulate, referring to both as resources. An effect in $\opercalc$ is a particular operation invoked on some resource; for example, $\kwa{File.write}$. The pieces of an $\opercalc$ program are (conservatively) annotated with the effects they may incur at runtime. Annotations might be given in accordance with the principle of least authority to specify the maximum authority a component may exercise. When this authority is being exceeded, an effect system like that of $\opercalc$ will reject the program, signalling that the implementation is unsafe. For example, consider the pair of modules in Figure \ref{fig:opercalc_motivating}: the $\kwa{Logger}$ possesses a $\File$ capability and exposes a single function $\kwa{log}$. The $\kwa{Client}$ has a single function $\kwa{run}$ which, when passed a $\kwa{Logger}$, will invoke $\kwa{Logger.log}$.

\begin{figure}[h]
\vspace{-5pt}

\begin{lstlisting}
resource module Logger
require File

def log(): Unit with {File.append} =
    File.read
\end{lstlisting}

\begin{lstlisting}
module Client

def run(l: Logger): Unit with {File.append} =
    l.log()
\end{lstlisting}

\vspace{-7pt}
\caption{The implementation of $\kwa{Logger.log}$ exceeds its specified authority.}
\label{fig:opercalc_motivating}
\end{figure}

$\kwa{Client.run}$ and $\kwa{Logger.log}$ are both annotated with $\{ \kwa{File.append} \}$, but the (potentially malicious) implementation of $\kwa{Logger.log}$ incurs the $\kwa{File.read}$ effects. By the end of this section, we will have developed rules for $\opercalc$ that can determine such mismatches between specification and implementation in annotated code. The definition of soundness is also extended to consider whether the static rules safely approximate the runtime effects of a piece of code.

\subsubsection{$\opercalc$ Grammar}~\\

A grammar for $\opercalc$ programs is given in Figure \ref{fig:opercalc_grammar}.

\begin{figure}[h]
\vspace{-5pt}

\[
\begin{array}{lll}

\begin{array}{lllr}

e & ::= & ~ & exprs: \\
	& | & x & variable \\
	& | & v & value \\
	& | & e ~ e & application \\
	& | & e.\pi & operation~call \\
	&&\\

\end{array}

\begin{array}{lllr}

v & ::= & ~ & values: \\ 
	& | & r & resource~literal \\
	& | & \lambda x: \tau.e & abstraction \\
	&&\\

\end{array}

\end{array}
\]

\vspace{-7pt}
\caption{Grammar for $\opercalc$ programs.}
\label{fig:opercalc_grammar}
\end{figure}

A resource literal $r$ is a variable drawn from a fixed set $R$. Resources model those primitive capabilities into the program from the system environment. $\kwa{File}$ and $\kwa{Socket}$ are examples of resource literals. An operation call $e.\pi$ is the invocation of an operation $\pi$ on $e$. For example, invoking the $\kwa{open}$ operation on the $\kwa{File}$ resource would be $\kwa{File.open}$. Operations are drawn from a fixed set $\Pi$. Neither resources nor operations can be created or destroyed at runtime; they simply exist for the duration of the program.

An effect is a pair $(r, \pi) \in R \times \Pi$. Sets of effects are denoted $\varepsilon$. As shorthand, we write $r.\pi$ instead of $(r, \pi)$. Effects should be distinguished from operation calls: an operation call is the invocation of a particular operation on a particular resource in a program, while an effect is a mathematical object describing this behaviour. The notation $r.*$ is short-hand for the set $\{ r.\pi \mid \pi \in \Pi \}$, which contains every effect on $r$. Sometimes we abuse notation by conflating the effect $r.\pi$ with the singleton $\{ r.\pi \}$. We may also write things like $\{ r_1.*, r_2.* \}$, which should be understood as the set of all operations on $r_1$ and $r_2$.\\


\subsubsection{$\opercalc$ Dynamic Rules}~\\

When an operation call is reduced a runtime effect is said to have taken place. Reflecting this, a single-step judgement takes the form $e \longrightarrow e'~|~\varepsilon$, meaning a single computational step can be made to $e$ producing $e'$ and incurring the runtime effects $\varepsilon$ in the process; in the case of single-step reductions, $\varepsilon$ is at most a singleton.

During reduction an operation call may be evaluated. When this happens a runtime effect is said to have taken place. Reflecting this, the form of the single-step reduction judgement is now $e \longrightarrow e~|~\varepsilon$, which means that $e$ reduces to $e'$, incurring the set of effects $\varepsilon$ in the process. In the case of single-step reduction, $\varepsilon$ is at most a single effect. Judgements for single-step reductions are given in Figure \ref{fig:opercalc_singlestep}. The particular style of semantics we have chosen is small-step and call-by-value.

\begin{figure}[h]

\noindent
\fbox{$e \longrightarrow e~|~\varepsilon$}

\[
\begin{array}{c}

\infer[\textsc{(E-App1)}]
	{e_1 e_2 \longrightarrow e_1'~ e_2~|~\varepsilon}
	{e_1 \longrightarrow e_1'~|~\varepsilon}
	~~~~~~
\infer[\textsc{(E-App2)}]
	{v_1 ~ e_2 \longrightarrow v_1 ~ e_2'~|~\varepsilon} 
	{e_2 \longrightarrow e_2'~|~\varepsilon}
~~~~~~
\infer[\textsc{(E-App3)}]
	{ (\lambda x: \tau. e) v_2 \longrightarrow [ v_2/x] e~|~\varnothing }
	{}\\[4ex]
	
\infer[\textsc{(E-OperCall1)}]
	{ e.\pi \longrightarrow  e'.\pi~|~\varepsilon }
	{ e \rightarrow  e'~|~\varepsilon}
		
	~~~~~~
	
\infer[\textsc{(E-OperCall2)}]
	{r.\pi \longrightarrow \kwa{unit}~|~\{ r.\pi \} }
	{}
	 \\[4ex]
	 
\end{array}
\]


\vspace{-7pt}
\caption{Single-step reductions in $\opercalc$.}
\label{fig:opercalc_singlestep}
\end{figure}

The first three rules are analogous to reductions in the lambda calculus. \textsc{E-App1} and \textsc{E-App2} incur the effects of reducing their subexpressions. Because \textsc{E-App3} is simply performing a substitution, it incurs no effects. The first new rule is \textsc{E-OperCall1}, which reduces the receiver of an operation call; the effects incurred are the effects incurred by reducing the receiver. When an operation $\pi$ is invoked on a resource literal $r$, \textsc{E-OperCall2} will reduce it to $\unit$, incurring $\{ r.\pi \}$ as a result. For example, $\kwa{File.write} \longrightarrow \unit~|~\{ \kwa{File.write} \}$ by \textsc{E-OperCall2}.

$\unit$ is a derived form, which has the property of being the only value of its type (also called $\Unit$); because of this, it is used to represent the absence of information. $\opercalc$ does not model the semantics of particular operation calls, so $\unit$ is a sensible dummy-value for them to return. A formal treatment of $\unit$ is given in section 4.

A multi-step reduction can be defined as a sequence of zero\footnote{We permit multi-step reductions of length zero to be consistent with Pierce, who defines multi-step reduction as a reflexive relation \cite[p. 39]{pierce02}.} or more single-step reductions. The resulting set of runtime effects is the union of all the runtime effects from the intermediate single-steps. Judgements for multi-step reductions are given in Figure \ref{fig:opercalc_multistep_defn}.

\begin{figure}[h]

\noindent
\fbox{$ e \longrightarrow^{*}  e~|~\varepsilon$}

\[
\begin{array}{c}

\infer[\textsc{(E-MultiStep1)}]
	{ e \rightarrow^{*}  e~|~\varnothing}
	{}
~~~
\infer[\textsc{(E-MultiStep2)}]
	{ e \rightarrow^{*}  e'~|~\varepsilon}
	{ e \rightarrow  e'~|~\varepsilon}
~~~	
\infer[\textsc{(E-MultiStep3)}]
	{ e \rightarrow^{*}  e''~|~\varepsilon_1 \cup \varepsilon_2}
	{ e \rightarrow^{*}  e'~|~\varepsilon_1 &  e' \rightarrow^{*}  e''~|~\varepsilon_2}
\end{array}
\]

\vspace{-7pt}
\caption{Multi-step reductions in $\opercalc$.}
\label{fig:opercalc_multistep_defn}
\end{figure}

\textsc{E-MultiStep1} says that an expression can ``reduce'' to itself with no runtime effects. \textsc{E-MultiStep2} says that any single-step reduction is also a multi-step reduction. \textsc{E-MultiStep3} says that if $e \longrightarrow e'~|~\varepsilon_1$ and $e' \longrightarrow e''~|~\varepsilon_2$ are sequences of reductions, then so is $e \longrightarrow e''~|~\varepsilon_1 \cup \varepsilon_2$. \\

\subsubsection{$\opercalc$ Static Rules}~\\

A grammar for types and type contexts is given in Figure \ref{fig:opercalc_types}. The base types of $\opercalc$ are sets of resources, denoted $\{ \bar r\}$. If an expression $e$ is associated with type $\{ \bar r \}$, it means $e$ will reduce to one of the literals in $\bar r$ (assuming $e$ terminates). There is a single type constructor $\rightarrow_{\varepsilon}$, where $\varepsilon$ is a concrete set of effects. $\tau_1 \rightarrow_{\varepsilon} \tau_2$ is the type of a function which takes a $\tau_1$ as input, returns a $\tau_2$ as output, and whose body incurs no more than those effects in $\varepsilon$. $\varepsilon$ is a conservative bound: if an effect $r.\pi \in \varepsilon$, it is not guaranteed to happen at runtime, but if $r.\pi \notin \varepsilon$, it cannot happen at runtime. A typing context $\Gamma$ maps variables to types. 

\begin{figure}[h]
\vspace{-5pt}

\[
\begin{array}{lll}

\begin{array}{lllr}

\tau & ::= & ~ & types: \\
		& | & \{ \bar r \} \\
		& | & \tau \rightarrow_{\varepsilon} \tau \\ 
		&&\\
\end{array}

\begin{array}{lllr}

\Gamma & ::= & ~ & type~ctx: \\
				& | & \varnothing \\
				& | & \Gamma, x: \tau \\
				&&\\
\end{array}

\end{array}
\]

\vspace{-7pt}
\caption{Grammar for types in $\opercalc$.}
\label{fig:opercalc_types}
\end{figure}

This syntactic definition treats typing contexts as sequences of variable-type pairings, but they should be treated in the usual way. Resource-sets are also syntactically defined as sequences, but should be interpreted as sets: $\{ \kwa{File, Socket} \}$ and $\{ \kwa{Socket, File} \}$ are the same type. Lastly, the empty set of resources $\varnothing$ is a valid type, but has no inhabitants.

To illustrate the types of some functions, if $\kwa{log_1}$ has the type $\{ \kwa{File} \} \rightarrow_{\kwa{File.append}} \Unit$, then invoking $\kwa{log_1}$ will either incur $\kwa{File.append}$ or no effects. If $\kwa{log_2}$ has the type $\{ \kwa{File} \} \rightarrow_{\kwa{File.*}} \Unit$, then invoking $\kwa{log_2}$ could incur any effect on $\kwa{File}$.

Knowing approximately what effects a piece of code may incur helps a developer determine whether it can be trusted. For example, consider $\kwa{log_3} = \lambda f: \kwa{File}.~e$, which is a logging function that takes a $\kwa{File}$ as an argument and then executes $e$. Suppose this function were to typecheck as $\{ \File \} \rightarrow_{\{ \kwa{File.*} \}} \Unit$ --- seeing that invoking this function could incur any effect on $\kwa{File}$, and not just its expected least authority $\kwa{File.append}$, a developer may therefore decide this implementation cannot be trusted and choose not to execute it. In this spirit, the static rules of $\opercalc$ associate well-typed programs with a type and a set of effects: the judgement $\Gamma \vdash e: \tau~\kw{with} \varepsilon$, means $e$ will reduce to a term of type $\tau$ (assuming it terminates), incurring no more effects than those in $\varepsilon$. The rules are given in Figure \ref{fig:opercalc_static_rules}.

\begin{figure}[h]

\noindent
\fbox{$\Gamma \vdash e: \tau~\kw{with} \varepsilon$}

\[
\begin{array}{c}

\infer[\textsc{($\varepsilon$-Var)}]
	{ \Gamma, x:\tau \vdash x: \tau~\kw{with} \varnothing }
	{}
	
	~~~
	
\infer[\textsc{($\varepsilon$-Resource)}]
 	{ \Gamma, r: \{ r \} \vdash r : \{ r \}~\kw{with} \varnothing }
 	{} \\[3ex]
 	
 	~~~
	\infer[\textsc{($\varepsilon$-Abs)}]
	{ \Gamma \vdash \lambda x:\tau_2 . e : \tau_2 \rightarrow_{\varepsilon_3} \tau_3~\kw{with} \varnothing }
	{ \Gamma, x: \tau_2 \vdash e: \tau_3~\kw{with} \varepsilon_3 }
	
	~~~
	
\infer[\textsc{($\varepsilon$-App)}]
	{ \Gamma \vdash e_1~e_2 : \tau_3~\kw{with} \varepsilon_1 \cup \varepsilon_2 \cup \varepsilon  }
	{ \Gamma \vdash e_1: \tau_2 \rightarrow_{\varepsilon} \tau_3~\kw{with} \varepsilon_1 & \Gamma \vdash e_2: \tau_2~\kw{with} \varepsilon_2 } \\[3ex]
	
\infer[\textsc{($\varepsilon$-OperCall)}]
	{ \Gamma \vdash e.\pi: \kw{Unit} \kw{with} \{ \bar r.\pi \} }
	{ \Gamma \vdash e: \{ \bar r \}}

\infer[\textsc{($\varepsilon$-Subsume)}]
	{ \Gamma \vdash e: \tau' ~\kw{with} \varepsilon'}
	{ \Gamma \vdash e: \tau ~\kw{with} \varepsilon & \tau <: \tau' & \varepsilon \subseteq \varepsilon'}\\[3ex]
	
\end{array}
\]


\vspace{-7pt}
\caption{Type-with-effect judgements in $\opercalc$.}
\label{fig:opercalc_static_rules}
\end{figure}



\textsc{$\varepsilon$-Var} approximates the runtime effects of a variable as $\varnothing$. \textsc{$\varepsilon$-Resource} does the same for resource literals. Though a resource captures several effects (namely, every possible operation on itself), attempting to ``reduce'' a resource will incur no effects; something must be done with the resource, such as invoke an operation. For a similar reason, \textsc{$\varepsilon$-Abs} approximates the effects of a function literal as $\varnothing$, but its ascribed arrow type is annotated with those effects captured by the function. \textsc{$\varepsilon$-App} approximates a lambda application as incurring those effects from evaluating the subexpressions and the effects incurred by executing the body of the function to which the left-hand side evaluates. The effects of the function body are taken from the function's arrow type.

An operation call on a resource literal reduces to $\unit$ by \textsc{E-OperCall3}, so \textsc{$\varepsilon$-OperCall} ascribes the type of an operation call as $\Unit$. The approximate effects of an operation call are: the effects of reducing the subexpression, and then the operation $\pi$ on every possible resource which that subexpression to which that subexpression might reduce. For example, consider $e.\pi$, where $\Gamma \vdash e: \{ \kwa{File, Socket} \}~\kw{with} \varnothing$. Then $e$ could evaluate to $\kwa{File}$, in which case the actual runtime effect is $\kwa{File}.\pi$, or it could evaluate to $\kwa{Socket}$, in which case the actual runtime effect is $\kwa{Socket.\pi}$. Determining which will happen is, in general, undecidable; the safe approximation is to treat them both as happening.

The last rule \textsc{$\varepsilon$-Subsume} produces a new judgement by widening the type or approximate effects on an existing one. The subtyping judgement are given in Figure \ref{fig:opercalc_static_rules}.


\begin{figure}[h]
\vspace{-5pt}

\fbox{$\Gamma \vdash e: \tau~\kw{with} \varepsilon$}

\[
\begin{array}{c}

\infer[\textsc{(S-Arrow)}]
	{ \tau_1 \rightarrow_{\varepsilon} \tau_2 <: \tau_1' \rightarrow_{\varepsilon'} \tau_2' }
	{ \tau_1' <: \tau_1 & \tau_2 <: \tau_2' & \varepsilon \subseteq \varepsilon' }
~~~~~~
\infer[\textsc{(S-Resource)}]
	{ \{ \bar r_1 \} <: \{ \bar r_2 \} }
	{ r \in r_1 \implies r \in r_2 }

\end{array}
\]

\vspace{-7pt}
\caption{Subtyping judgements of $\opercalc$.}
\label{fig:opercalc_static_rules}
\end{figure}

The first subtyping rule is the standard rule for arrow types, but with an extra premise that the effects on the arrow of the subtype must be contained in the effects on the arrow of the supertype. To illustrate why, consider a $\kwa{log}$ function which is allowed to open, close, and append to files. Its interface might have the type $\Unit \rightarrow_{\{\kwa{File.open, File.close, File.append}\}} \Unit$. However, an implementation of $\kwa{log}$ might open $\kwa{File}$ and $\kwa{append}$, but not $\kwa{close}$. In this case it still meets the authority stipulated by the interface, and should be considered as a subtype. The other subtyping rule is \textsc{S-Resource}, which says a subset of resources is a subtype. To justify this rule, consider $\{ \bar r_1 \} <: \{ \bar r_2 \}$. Any value with type $\{ \bar r_1 \}$ can reduce to any resource literal in $\bar r_1$, so to be compatible with an interface $\{ \bar r_2 \}$, the resource literals in $\bar r_1$ must also be in $\bar r_2$.

These rules let us determine what sort of effects might be incurred when a piece of code is executed. For example, consider $c = (\lambda f: \{ \kwa{File, Socket} \}.~\kwa{f.write})~\kwa{File}$. The judgement $\vdash c: \Unit~\kw{with} \{ \kwa{File.write, Socket.write} \}$ holds, which means executing $e$ might incur $\kwa{File.write}$ or $\kwa{Socket.write}$. A derivation for it is given in Figure \ref{fig:opercalc_tree}. To fit in one diagram, all resources and operations have been abbreviated to their first letter. A developer who only expects a file-writer to be incurring $\kwa{File.write}$ can typecheck $\kwa{fwrite}$, see that it could also be writing to $\kwa{Socket}$, and decide it should not be used. If the client code $c$ were to annotate its effects as $\kwa{ \{ \kwa{File.write} \} }$, the type system would reject $c$ as an implementation.

\begin{figure}[h]


    \begin{prooftree*}

    		\Infer0[\textsc{($\varepsilon$-Var)}]{f: \{ \kwa{F}, \kwa{S} \} \vdash f: \{ \kwa{F}, \kwa{S} \}}
    		
    		\Infer1[\textsc{($\varepsilon$-OperCall)}]{\kwa{f}: \{ \kwa{F}, \kwa{S} \} \vdash \kwa{f.w} : \Unit~\kw{with} \{ \kwa{F.w, S.w} \} }
    		
    		\Infer1[\textsc{($\varepsilon$-Abs)}]{ \lambda \kwa{f}: \{ \kwa{F}, \kwa{S} \}. \kwa{f.w} : \{ \kwa{F, S} \} \rightarrow_{\kwa{F.w, S.w}} \Unit~\kw{with} \varnothing }
    		
    
       \Infer0[\textsc{($\varepsilon$-Resource)}]{\vdash \kwa{F}: \{ \kwa{F} \}~\kw{with} \varnothing}
    
    		\Infer2[\textsc{($\varepsilon$-App)}]{ \vdash (\lambda \kwa{f}: \{ \kwa{F, S} \}. \kwa{f.write})~\kwa{F} : \Unit~\kw{with} \{ \kwa{F.w, S.w} \}  }
    		
 	\end{prooftree*}
 	
\vspace{-12pt}
\caption{Derivation tree for $\vdash c: \Unit~\kw{with} \{ \kwa{File.write, Socket.write} \}$.}
\label{fig:opercalc_tree}
\end{figure}

\subsubsection{$\opercalc$ Proofs}~\\

To show the rules of $\opercalc$ are sound requires an appropriate notion of static approximations being safe with respect to the reductions. If a static judgement like $\Gamma \vdash e: \tau~\kw{with} \varepsilon$ were correct, then successive reductions on $e$ should never produce effects not in $\varepsilon$. Adding this to our definition of soundness yields the following first definition.


\begin{theorem}[$\opercalc$ Single-step Soundness]
If $ \Gamma \vdash  e_A:  \tau_A~\kw{with} \varepsilon_A$ and $ e_A$ is not a value, then $e_A \longrightarrow e_B~|~\varepsilon$, where $ \Gamma \vdash e_B:  \tau_B~\kw{with} \varepsilon_B$ and $ \tau_B <:  \tau_A$ and $\varepsilon_B \cup \varepsilon \subseteq \varepsilon_A$, for some $e, \varepsilon, \tau_B, \varepsilon_B$.
\end{theorem}

Our approach to proving soundness is to show progress and preservation, which in turn rely on $\opercalc$ versions of canonical forms and the substitution lemma. Canonical forms is stated below. The results are not true if the rule used is \textsc{$\varepsilon$-Subsume} (because the type and approximate effects of a value can be arbitrarily widened), so we must exclude that.

\begin{lemma}[$\opercalc$ Canonical Forms]
Unless the typing rule used was \textsc{$\varepsilon$-Subsume}, the following are true:
\begin{enumerate}
	\item If $\Gamma \vdash x: \tau~\kw{with} \varepsilon$ then $\varepsilon = \varnothing$.
	\item If $ \Gamma \vdash  v:  \tau~\kw{with} \varepsilon$ then $\varepsilon = \varnothing$.
	\item If $ \Gamma \vdash v: \{ \bar r \}~\kw{with} \varepsilon$ then $v = r$ and $\{ \bar r \} = \{ r \}$.
	\item If $\Gamma \vdash v: \tau_1 \rightarrow_{\varepsilon'} \tau_2~\kw{with} \varepsilon$ then $v = \lambda x:\tau. e$.
\end{enumerate}
\end{lemma}

The first two observations state that variables and values will always type with $\varnothing$ as their approximate effects. The third states that if a value is typed to a set of resources, the set of a singleton $\{ r \}$ and the value is the resource literal $r$. The fourth states that if a value types to a function then it is a function literal. From canonical forms, the progress theorem can be proved in a routine manner.

\begin{theorem}[$\opercalc$ Progress]
If $ \Gamma \vdash  e:  \tau~\kw{with} \varepsilon$ and $ e$ is not a value or variable, then $ e \longrightarrow  e'~|~\varepsilon$, for some $e', \varepsilon$.
\end{theorem}

\begin{proof} By induction on derivations of $ \Gamma \vdash  e:  \tau~\kw{with} \varepsilon$.
\end{proof}

To show preservation we need to know that type-and-effect safety is preserved by the substitution in \textsc{E-App3}. If a variable is replaced by an arbitrary expression, then we could also be introducing arbitrary effects, violating effect-safety. However, our semantics are call-by-value, so arguments are reduced to values before being bound to their formal name in the body of a function. By canonical forms, values be typed as having no effects, so performing the substitution in \textsc{E-App3} will not introduce any effects to the approximation. The version of the substitution lemma for $\opercalc$ therefore imposes the restriction that a variable is only being substituted for a value, and not any arbitrary expression. Beyond this observation, the proof is routine.

\begin{lemma}[$\opercalc$ Substitution]
If $\Gamma, x: \tau' \vdash e: \tau~\kw{with} \varepsilon$ and $\Gamma \vdash v: \tau'~\kw{with} \varnothing$ then $\Gamma \vdash [v/x]e: \tau~\kw{with} \varepsilon$.
\end{lemma}

\begin{proof} By induction on the derivation of $\Gamma, x: \tau' \vdash e: \tau~\kw{with} \varepsilon$.
\end{proof}

With this lemma, we can prove the preservation theorem.

\begin{theorem}[$\opercalc$ Preservation]
If $\Gamma \vdash e_A: \tau_A~\kw{with} \varepsilon_A$ and $e_A \longrightarrow e_B~|~\varepsilon$, then $\tau_B <: \tau_A$ and $\varepsilon_B \cup \varepsilon \subseteq \varepsilon_A$, for some $e_B, \varepsilon, \tau_B, \varepsilon_B$.
\end{theorem}

\begin{proof}  By induction on the derivation of $\Gamma \vdash e_A: \tau_A~\kw{with} \varepsilon_A$, and then the derivation of $e_A \longrightarrow e_B~|~\varepsilon$.
\end{proof}


Our single-step soundness theorem now holds immediately by joining the progress and preservation theorems into one. Knowing that single-step reductions are sound, the soundness of multi-step reductions can be shown by inductively applying single-step soundness on their length.

\begin{theorem}[$\opercalc$ Single-step Soundness]
If $ \Gamma \vdash  e_A:  \tau_A~\kw{with} \varepsilon_A$ and $ e_A$ is not a value, then $e_A \longrightarrow e_B~|~\varepsilon$, where $ \Gamma \vdash e_B:  \tau_B~\kw{with} \varepsilon_B$ and $ \tau_B <:  \tau_A$ and $\varepsilon_B \cup \varepsilon \subseteq \varepsilon_A$, for some $e_B, \varepsilon, \tau_B, \varepsilon_B$.
\end{theorem}
\begin{proof}
If $ e_A$ is not a value then the reduction exists by the progress theorem. The rest follows by the preservation theorem.
\end{proof}

\begin{theorem}[$\opercalc$ Multi-step Soundness]
If $ \Gamma \vdash  e_A:  \tau_A~\kw{with} \varepsilon_A$ and $e_A \longrightarrow^{*} e_B~|~\varepsilon$, where $\Gamma \vdash e_B: \tau_B~\kw{with} \varepsilon_B$ and $ \tau_B <: \tau_A$ and $\varepsilon_B \cup \varepsilon \subseteq \varepsilon_A$.
\end{theorem}

\begin{proof} By induction on the length of the multi-step reduction.
\end{proof}








