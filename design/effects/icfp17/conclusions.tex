\section{Conclusions}

We introduced $\opercalc$, a lambda calculus with primitive capabilities and their effects. $\opercalc$ programs are fully annotated with their effects. Relaxing this requirement, we obtained $\epscalc$, which allows unannotated code to be nested inside annotated code with a new $\kwa{import}$ construct. The capability-safe design of $\epscalc$ allows us to safely infer the effects of unannotated code by inspecting what capabilities are passed into it by its annotated surroundings. Such an approach allows code to be incrementally annotated, giving developers a balance between safety and convenience and alleviating the verbosity that has discouraged widespread adoption of effect systems \cite{rytz12}.

\subsection{Related Work}

Capabilities were introduced by Dennis and Van Horn \cite{dennis66} to control which processes in an operating system had permission to access certain parts of memory, perhaps via an \textit{access control list}. These early ideas are considerably different to the object capability model exemplified in the work of Mark Miller \cite{miller06}, which constrains how permissions may proliferate. Maffeis et. al. formalised the notion of a capability-safe language and showed that a subset of Caja (a Javascript implementation) is capability-safe \cite{maffeis10}. Other capability-safe languages include Wyvern \cite{nistor13} and Newspeak \cite{bracha10}. Miller's model has been applied to more heavyweight systems: Drossopoulou et. al. combined Hoare logic with capabilities to formalise the notion of trust \cite{drossopoulou07}.

The original effect system by Lucassen and Gifford was used to determine what expressions could safely execute in parallel \cite{lucassen88}. Subsequent applications include determining what functions a program might invoke \cite{tang94} and what regions in memory might be accessed or updated during execution \cite{talpin94}. In these systems, ``effects'' are performed upon ``regions''; in ours, ``operations'' are performed upon ``resources'''. $\epscalc$ also distinguishes between unannotated and annotated code: only the latter will type-and-effect-check. Another capability-based effect system is the one by Devriese et. al \cite{devriese16}, who use effect polymorphism and possible world semantics to express behavioural invariants on data structures. $\epscalc$ is not as expressive, since it only topographically analyses how capabilities can be passed around a program, but the resulting formalism and theory is much more lightweight.

\subsection{Future Work}

Our effects model only the use of capabilities which manipulate system resources. This definition could be generalised to track other sorts of effects, such as stateful updates. Resources and operations are fixed throughout runtime; it would be interesting to consider the theory when they can be created and destroyed at runtime.

The current theory contains no effect polymorphism, whereby a function's type is parameterised by a set of effects. The only way for such a function to typecheck in $\epscalc$ would be to approximate it as having every effect, in which case all precision has been lost. A polymorphic effect system which considers such a function as having an effect parameterised type could give more meaningful approximations.

Many believe in the value of the object capability model, but we do not fully understand its formal benefits. We hope to extend the ideas in this paper to the point where they might be used in capability-safe languages to help authority-safe design and development. Implementing these ideas in a general-purpose, capability-safe language would do much towards that end.

%Many believe in the real and practical value of the object capability model, but we do not fully understand its formal benefits. 