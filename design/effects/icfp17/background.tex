
\section{Background}

\subsection{Effect Systems}

One extension to classical type systems is to incorporate a theory of \textit{effects}. Judgements in a \textit{type-and-effect} system associate both a type and a set of effects with well-behaved programs. Effects describe intensional information about the way in which a program executes \cite{nielson99}.

TODO


\subsection{The Capability Model}

A \textit{capability} is a unique, unforgeable reference, granting its bearer permission to perform some operation \cite{dennis66}. If a piece of code possesses a capability $C$, it is said to have \textit{authority} over it. In the capability model, authority can only proliferate in the following ways \cite{miller06}:

\begin{enumerate}
	\item By the initial set of capabilities passed into the program (initial conditions).
	\item If a function or object is instantiated by its parent, the parent gains a capability for its child (parenthood).
	\item If a function or object is instantiated by a parent, the parent may endow its child with any capabilities it possesses (endowment).
	\item A capability may be transferred via method-calls or function applications (introduction).
\end{enumerate}

The proliferation rules are summarised as: ``only connectivity begets connectivity.'' Any authority in a program either exists from the beginning from those initial capabilities passed in by the system environment, or derive from previous access. A primitive capability grants operations over \textit{resources} in the system environment. For example, a $\kwa{File}$ might grant operations on a particular file in the file system. We will often conflate primitive capabilities with the system resources they grant operations upon, referring to both as resources. An example of a non-primitive capability might be a $\kwa{Logger}$ which exercises authority over a $\kwa{File}$ and presents a $\kwa{log}$ function which appends to it. If an effect is interpreted as some operation performed upon a system resource, then capabilities encapsulate the source of effects; the only way to incur an effect is to possess a capability for it.

If a component uses a capability which it has not been explicitly given, it is exercising \textit{ambient authority}. Figure \ref{java_ambient_authority} demonstrates ambient authority in Java: a malicious implementation of $\kwa{List.add}$ attempts to overwrite the user's $\kwa{.bashrc}$ file. $\kwa{MyList}$ gains a capability for this operation by importing $\kwa{java.io.File}$ and instantiating new instances of a capability for the user's $\kwa{.bashrc}$ file. Nobody has explicitly given it a capability for the $\kwa{.bashrc}$ file; it simply creating one for itself. Another way to exercise ambient authority is through global state: if a capability is stored inside a global variable then any component can use it, regardless of whether it had been given to them. Ambient authority is a challenge to the principle of least authority because it makes it impossible to determine from a module's signature what authority is being exercised. From the perspective of $\kwa{Main}$, knowing that $\kwa{MyList.add}$ has a capability for the user's $\kwa{.bashrc}$ file requires one to inspect the source code of $\kwa{.bashrc}$. In a large code-base, this is tedious and error-prone. If the source code is obfuscated, it is also frustrating. If the developer does not have access to the source code, it is impossible! A language in which authority is explicit and only proliferates according to the capability model is called \textit{capability-safe}. To be capability-safe, a language must not allow unrestricted imports or global state. The result is that every component must select and be instantiated with the authority it needs to function. The implementation of $\kwa{MyList}$ has been rewritten in Figure \ref{java_cap_safe} so it exercises authority over $\kwa{File}$ in an explicit manner.

\begin{figure}

\begin{lstlisting}
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;

class MyList<T> extends ArrayList<T> {	
	@Override
	public boolean add(T elem) {
		try {
			File file = new File("$\$$HOME/.bashrc");
			file.createNewFile();
		} catch (IOException e) {}
		return super.add(elem);
	}	
}
\end{lstlisting}

\begin{lstlisting}
import java.util.List;

class Main {
	public static void main(String[] args) {
		List<String> list = new MyList<String>();
		list.add(``doIt'');
	}
}
\end{lstlisting}

\vspace{-12pt}
\caption{$\kwa{Main}$ exercises ambient authority over a $\kwa{File}$ capability.}
\label{java_ambient_authority}
\end{figure}

Capability-safe languages usually have first-class modules, meaning objects and modules are treated in a uniform manner: modules must be instantiated and passed around the system. Instantiating a module with the capabilities it requires means that the developer trusts the module with this authority. Because modules are treated the same as objects, they are also bound by the constraints on ambient authority and proliferation, so capability-safety is preserved across module boundaries. This treatment of modules allows us to gain the benefits of reusable code we achieve with imports in Java, but without the ambient authority. First-class modules are not exclusive to capability-safe languages: Scala has first class modules \cite{odersky16}, but is not capability-safe. Some capability-safe languages with first-class modules include Newspeak \citep{bracha10} and Wyvern \citep{kurilova16, nistor13}.


\begin{figure}[t]

\begin{lstlisting}
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;

class MyList<T> extends ArrayList<T> {
	
	private File f;
	
	public MyList(File f) {
		this.f = f;
	}
	
	@Override
	public boolean add(T elem) {
		try {
			f.createNewFile();
		} catch (IOException e) {}
		return super.add(elem);
	}
	
}
\end{lstlisting}

\vspace{-12pt}
\caption{$\kwa{MyList}$ now exercises explicit authority over the $\kwa{File}$.}
\label{java_cap_Safe}
\end{figure}
