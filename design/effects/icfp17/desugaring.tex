\section{Desugaring}

Our aim in this section is to develop the techniques for our calculi to express practical examples. To do this we introduce two derived forms, $\unit$ and $\kwa{let}$, make some simplifying assumptions, and explain how Wyvern-like programs can be expressed in $\epscalc$.

\subsection{Unit}

The $\unit$ literal is defined as $\unit \defn \lambda x: \varnothing.~x$. It is the same in both annotated and unannotated code. In annotated code, it has the type $\Unit \defn \varnothing \rightarrow_{\varnothing} \varnothing$, while in unannotated code it has the type $\Unit \defn \varnothing \rightarrow \varnothing$. These are technically two separate types, but we will not distinguish between them. Note that $\unit$ is a value, and because $\varnothing$ is uninhabited (there is no empty resource literal), $\unit$ cannot be applied to anything. Furthermore, $\vdash \unit: \Unit~\kw{with} \varnothing$ by \textsc{$\varepsilon$-Abs}, and $\vdash \unit: \Unit$ by \textsc{T-Abs}. This leads to the derived rules in Figure \ref{fig:unit_rules}.

\begin{figure}[h]


\fbox{$\Gamma \vdash e: \tau$} 
\fbox{$\hat \Gamma \vdash \hat e: \hat \tau~\kw{with} \varepsilon$}


\[
\begin{array}{c}

\infer[\textsc{(T-Unit)}]
	{\Gamma \vdash \unit : \Unit}
	{} ~~~~

\infer[(\textsc{$\varepsilon$-Unit})]
	{\hat \Gamma \vdash \unit : \Unit~\kw{with} \varnothing}
	{}

\end{array}
\]

\caption{Derived $\kwa{Unit}$ rules.}
\label{fig:unit_rules}
\end{figure}

Since $\unit$ represents the absence of information, we use $\Unit$ when a function takes no input or returns no value. Figure \ref{fig:unit_sugaring} shows the definition of a Wyvern function which takes no argument and returns nothing, and its corresponding representation in $\epscalc$.

\begin{figure}[h]

\begin{lstlisting}
def method():Unit
   unit
\end{lstlisting}

\begin{lstlisting}
$\lambda$x:Unit. unit
\end{lstlisting}

\caption{Desugaring of functions which take no arguments or return nothing.}
\label{fig:unit_sugaring}
\end{figure}

~

\subsection{Let}

\noindent
The expression $\letxpr{x}{\hat e_1}{\hat e_2}$ reduces $\hat e_1$ to a value $\hat v_1$, binds it to the name $x$ in $\hat e_2$, and then executes $[\hat v_1/x]\hat e_2$. If $\hat \Gamma \vdash \hat e_1: \hat \tau_1~\kw{with} \varepsilon_1$, then $\letxpr{x}{\hat e_1}{\hat e_2} \defn (\lambda x: \hat \tau_1 . \hat e_2) \hat e_1$\footnote{You can also define an unannotated version of $\kwa{let}$, but we only need the annotated version}. If $\hat e_1$ is a non-value, we can reduce the $\kwa{let}$ by \textsc{E-App2}. If $\hat e_1$ is a value, we may apply \textsc{E-App3}, which binds $\hat e_1$ to $x$ in $\hat e_2$. $\kwa{let}$ expressions can be typed using \textsc{$\varepsilon$-App}. The new rules in \ref{fig:let_rules} capture these derivations.

\begin{figure}[h]

\fbox{$\Gamma \vdash e: \tau$}
\fbox{$\hat \Gamma \vdash \hat e: \hat \tau~\kw{with} \varepsilon$}
\fbox{$\hat e \rightarrow \hat e ~|~ \varepsilon$}

\[
\begin{array}{c}

	~~~
	
	\infer[\textsc{(T-Let)}]
	{\Gamma \vdash \letxpr{x}{e_1}{e_2}: \tau_2}
	{\Gamma \vdash e_1: \tau_1 & \Gamma, x: \tau_1 \vdash e_2: \tau_2}

\infer[\textsc{($\varepsilon$-Let)}]
	{\hat \Gamma \vdash \letxpr{x}{\hat e_1}{\hat e_2} : \hat \tau_2~\kw{with} \varepsilon_1 \cup \varepsilon_2}
	{\hat \Gamma \vdash \hat e_1 : \hat \tau_1~\kw{with} \varepsilon_1 & \hat \Gamma, x: \hat \tau_1 \vdash \hat e_2: \hat \tau_2~\kw{with} \varepsilon_2} \\[2ex]
	
\infer[\textsc{(E-Let1)}]
	{\letxpr{x}{\hat e_1}{\hat e_2} \longrightarrow \letxpr{x}{\hat e_1'}{\hat e_2}~|~\varepsilon_1}
	{\hat e_1 \longrightarrow \hat e_1'~|~\varepsilon_1} 
	
\infer[\textsc{(E-Let2)}]
	{\letxpr{x}{\hat v}{\hat e} \longrightarrow [\hat v/x]\hat e~|~\varnothing}
	{} 

\end{array}
\]

\caption{Derived $\kwa{let}$ rules.}
\label{fig:let_rules}
\end{figure}


\subsection{Modules and Objects}

Wyvern's modules are first-class, desugaring into objects --- invoking a module's function is no different from invoking an object's method. There are two kinds of modules: pure and resourceful. For our purposes, a pure module is one with no (transitive) authority over any resources, while a resource module has (transitive) authority over some resource. A pure module may still be given a capability, for example by requesting it in a function signature, but it may not possess or capture the capability for longer than the duration of the method call. \ref{fig:wyv_modules} shows an example of two modules, one pure and one resourceful, each declared in a separate file. Pure modules are declared with the $\kwa{module}$ keyword, while resource modules are declared with $\kwa{resource~module}$.

\begin{figure}[h]

\begin{lstlisting}
module PureMod

def tick(f: {File}):Unit with {File.append}
   f.append

\end{lstlisting}

\begin{lstlisting}
resource module ResourceMod
require File

def tick():Unit with {File.append}
   File.append
\end{lstlisting}

\caption{Definition of two modules, one pure and the other resourceful.}
\label{fig:wyv_modules}
\end{figure}

Resource modules, like objects, must be instantiated. When they are instantiated they must be given the capabilities they require. In Figure \ref{fig:wyv_modules}, $\kwa{ResourceMod}$ requests the use of a $\kwa{File}$ capability. Figure \ref{fig:wyv_module_instantiation} demonstrates how the two modules above would be instantiated and used. To prevent infinite regress the $\kwa{File}$ must, at some point, be introduced into the program. This happens in a special main module. When the program begins execution, the $\kwa{File}$ capability is passed into the program from the system environment. $\kwa{Main}$ then instantiates all the other modules in the program with their capabilities.

If a module is annotated, its function signatures will have effect annoations. For example, in Figure \ref{fig:wyv_modules}, $\kwa{PureMod.tick}$ has the $\kwa{File.append}$ annotation, meaning it should typecheck as $\kwa{ \{ File \} \rightarrow_{\{\kwa{File.append}\}} \Unit }$. 


\begin{figure}[h]

\begin{lstlisting}
resource module Main
require File
instantiate PureMod
instantiate ResourceMod(File)

PureMod.tick(File)
\end{lstlisting}

\caption{The $\kwa{Main}$ module which instantiates $\kwa{PureMod}$ and $\kwa{ResourceMod}$ and then invokes $\kwa{PureMod.tick}$.}
\label{fig:wyv_module_instantiation}
\end{figure}

Several simplifications make our desugaring possible. The only objects we use in the Wyvern examples are modules which only contain one function and the capabilities they require; they have no mutable fields. There are no self-referencing modules or recursive function definitions. Modules will not reference each other cyclically. This enables us to model each module as a function. Applying this function will be equivalent to applying the single function defined by the module. A collection of modules is desugared into $\epscalc$ as follows. First, a sequence of let-bindings are used to name constructor functions which, when given the capabilities requested by a module, will return an instance of the module. If the module does not require any capabilities it will take $\Unit$ as its argument. The constructor for $\kwa{M}$ is called $\kwa{MakeM}$. A function is then defined which represents the body of code in the $\kwa{Main}$ module. When invoked, this function will instantiate all the modules by invoking their constructors, and then execute the code in main. Finally, this function is invoked with the primitive capabilities passed into $\kwa{Main}$.

To demonstrate, Figure \ref{fig:wyv_tutorial_desugaring} shows how the examples above desugar. Lines 1-3 define the constructor for $\kwa{PureMod}$. Since $\kwa{PureMod}$ requires no capabilities, the constructor takes $\Unit$ as an argument on line 2. Lines 6-8 define the constructor for $\kwa{ResourceMod}$. It requires a $\kwa{File}$ capability, so the constructor takes $\kwa{\{File\}}$ as its input type on line 7. The constructor for $\kwa{Main}$ is defined on lines 11-16, which instantiates the other modules and then runs the code inside $\kwa{Main}$. Line 17 starts everything off by invoking $\kwa{Main}$ with the initial set of capabilities, which in this case is just $\kwa{File}$.

\begin{figure}[h]

\begin{lstlisting}
let MakePureMod =
   $\lambda$x:Unit.
      $\lambda$f:{File}. f.append
in

let MakeResourceMod =
   $\lambda$f:{File}.
      $\lambda$x:Unit. f.append
in

let MakeMain =
   $\lambda$f:{File}.
      $\lambda$x: Unit.
         let PureMod = (MakePureMod unit) in
         let ResourceMod = (MakeResourceMod f) in
         (ResourceMod unit)

(MakeMain File) unit
\end{lstlisting}

\caption{Desugaring of $\kwa{PureMod}$ and $\kwa{ResourceMod}$ into $\epscalc$.}
\label{fig:wyv_tutorial_desugaring}
\end{figure}

When an unannotated module is translated into $\epscalc$, the desugared contents will be encapsulated with an $\kwa{import}$ expression. The selected authority on the $\kwa{import}$ expression will be that we expect of the unannotated code according to the principle of least authority in the particular example under consideration. For example, if the client only expects the unannotated code to have the $\kwa{File.append}$ effect, its corresponding $\kwa{import}$ expression will select $\kwa{\{File.append\}}$.
