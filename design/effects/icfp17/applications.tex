
\section{Applications}

In this chapter we show how $\epscalc$ can be used to model several practical examples. This will take the form of writing a program in a high-level, capability-safe language, translating it to an equivalent $\epscalc$ program, and demonstrating how the rules of $\epscalc$ can be applied to reason about the use of effects. The high-level examples are written in a \textit{Wyvern}-like language. We begin by discussing how the translation from Wyvern to $\epscalc$ will work. This also serves as a gentle introduction to Wyvern syntax. A variety of scenarios are then explored.


\subsection{Translations and Encodings}

Our aim is to develop some notation to help us translate Wyvern programs into $\epscalc$. Our approach will be to encode these additional rules and forms into the base language of $\epscalc$; essentially, to give common patterns a short-hand, so they can be easily named and recalled. This is called \textit{sugaring}. When these derived forms are collapsed into their underlying representation, it is called \textit{desugaring}. \\

\subsubsection{Unit}~\\

The $\unit$ literal is defined as $\unit \defn \lambda x: \varnothing.~x$. It is the same in both annotated and unannotated code. In annotated code, it has the type $\Unit \defn \varnothing \rightarrow_{\varnothing} \varnothing$, while in unannotated code it has the type $\Unit \defn \varnothing \rightarrow \varnothing$. While these are technically two separate types, we will not distinguish between them. Note that $\unit$ is a value, and because $\varnothing$ is uninhabited (there is no empty resource literal), $\unit$ cannot be applied to anything. Furthermore, $\vdash \unit: \Unit~\kw{with} \varnothing$ by \textsc{$\varepsilon$-Abs}, and $\vdash \unit: \Unit$ by \textsc{T-Abs}. This leads to the derived rules in \ref{fig:unit_rules}.

\begin{figure}[h]


\fbox{$\Gamma \vdash e: \tau$} 
\fbox{$\hat \Gamma \vdash \hat e: \hat \tau~\kw{with} \varepsilon$}


\[
\begin{array}{c}

\infer[\textsc{(T-Unit)}]
	{\Gamma \vdash \unit : \Unit}
	{} ~~~~

\infer[(\textsc{$\varepsilon$-Unit})]
	{\hat \Gamma \vdash \unit : \Unit~\kw{with} \varnothing}
	{}

\end{array}
\]

\caption{Derived $\kwa{Unit}$ rules.}
\label{fig:unit_rules}
\end{figure}

Since $\unit$ represents the absence of information, we use $\Unit$ when a function takes no input or returns no value. Figure \ref{fig:unit_sugaring} shows the definition of a Wyvern function which takes no argument and returns nothing, and its corresponding representation in $\epscalc$.

\begin{figure}[h]

\begin{lstlisting}
def method():Unit
   unit
\end{lstlisting}

\begin{lstlisting}
$\lambda$x:Unit. unit
\end{lstlisting}

\caption{Desugaring of functions which take no arguments or return nothing.}
\label{fig:unit_sugaring}
\end{figure}

~

\subsubsection{Let}~\\

\noindent
The expression $\letxpr{x}{\hat e_1}{\hat e_2}$ reduces $\hat e_1$ to a value $\hat v_1$, binds it to the name $x$ in $\hat e_2$, and then executes $[\hat v_1/x]\hat e_2$. If $\hat \Gamma \vdash \hat e_1: \hat \tau_1~\kw{with} \varepsilon_1$, then $\letxpr{x}{\hat e_1}{\hat e_2} \defn (\lambda x: \hat \tau_1 . \hat e_2) \hat e_1$\footnote{You can also define an unannotated version of $\kwa{let}$, but we only need the annotated version}. If $\hat e_1$ is a non-value, we can reduce the $\kwa{let}$ by \textsc{E-App2}. If $\hat e_1$ is a value, we may apply \textsc{E-App3}, which binds $\hat e_1$ to $x$ in $\hat e_2$. $\kwa{let}$ expressions can be typed using \textsc{$\varepsilon$-App}. The new rules in \ref{fig:let_rules} capture these derivations.

\begin{figure}[h]

\fbox{$\Gamma \vdash e: \tau$}
\fbox{$\hat \Gamma \vdash \hat e: \hat \tau~\kw{with} \varepsilon$}
\fbox{$\hat e \rightarrow \hat e ~|~ \varepsilon$}

\[
\begin{array}{c}

	~~~
	
	\infer[\textsc{(T-Let)}]
	{\Gamma \vdash \letxpr{x}{e_1}{e_2}: \tau_2}
	{\Gamma \vdash e_1: \tau_1 & \Gamma, x: \tau_1 \vdash e_2: \tau_2}

\infer[\textsc{($\varepsilon$-Let)}]
	{\hat \Gamma \vdash \letxpr{x}{\hat e_1}{\hat e_2} : \hat \tau_2~\kw{with} \varepsilon_1 \cup \varepsilon_2}
	{\hat \Gamma \vdash \hat e_1 : \hat \tau_1~\kw{with} \varepsilon_1 & \hat \Gamma, x: \hat \tau_1 \vdash \hat e_2: \hat \tau_2~\kw{with} \varepsilon_2} \\[2ex]
	
\infer[\textsc{(E-Let1)}]
	{\letxpr{x}{\hat e_1}{\hat e_2} \longrightarrow \letxpr{x}{\hat e_1'}{\hat e_2}~|~\varepsilon_1}
	{\hat e_1 \longrightarrow \hat e_1'~|~\varepsilon_1} 
	
\infer[\textsc{(E-Let2)}]
	{\letxpr{x}{\hat v}{\hat e} \longrightarrow [\hat v/x]\hat e~|~\varnothing}
	{} 

\end{array}
\]

\caption{Derived $\kwa{let}$ rules.}
\label{fig:let_rules}
\end{figure}


\subsubsection{Modules and Objects}~\\

Wyvern's modules are first-class and desugar into objects; invoking a method inside a module is no different from invoking an object's method. There are two kinds of modules: pure and resourceful. For our purposes, a pure module is one with no (transitive) authority over any resources, while a resource module has (transitive) authority over some resource. A pure module may still be given a capability, for example by requesting it in a function signature, but it may not possess or capture the capability for longer than the duration of the method call. \ref{fig:wyv_modules} shows an example of two modules, one pure and one resourceful, each declared in a separate file. Pure modules are declared with the $\kwa{module}$ keyword, while resource modules are declared with $\kwa{resource~module}$.

\begin{figure}[h]

\begin{lstlisting}
module PureMod

def tick(f: {File}):Unit with {File.append}
   f.append

\end{lstlisting}

\begin{lstlisting}
resource module ResourceMod
require File

def tick():Unit with {File.append}
   File.append
\end{lstlisting}

\caption{Definition of two modules, one pure and the other resourceful.}
\label{fig:wyv_modules}
\end{figure}

Resource modules, like objects, must be instantiated. When they are instantiated they must be given the capabilities they require. In Figure \ref{fig:wyv_modules}, $\kwa{ResourceMod}$ requests the use of a $\kwa{File}$ capability. Figure \ref{fig:wyv_module_instantiation} demonstrates how the two modules above would be instantiated and used. To prevent infinite regress the $\kwa{File}$ must, at some point, be introduced into the program. This happens in a special main module. When the program begins execution, the $\kwa{File}$ capability is passed into the program from the system environment. $\kwa{Main}$ then instantiates all the other modules in the program with their capabilities.

If a module is annotated, its function signatures will have effect annoations. For example, in Figure \ref{fig:wyv_modules}, $\kwa{PureMod.tick}$ has the $\kwa{File.append}$ annotation, meaning it should typecheck as $\kwa{ \{ File \} \rightarrow_{\{\kwa{File.append}\}} \Unit }$. 


\begin{figure}[h]

\begin{lstlisting}
resource module Main
require File
instantiate PureMod
instantiate ResourceMod(File)

PureMod.tick(File)
\end{lstlisting}

\caption{The $\kwa{Main}$ module which instantiates $\kwa{PureMod}$ and $\kwa{ResourceMod}$ and then invokes $\kwa{PureMod.tick}$.}
\label{fig:wyv_module_instantiation}
\end{figure}

Our desugaring is enabled by several simplifications. The only objects we use in the Wyvern programs are modules which only ever contain one function and the capabilities they require; they have no mutable fields. There are no self-referencing modules or recursive function definitions. Modules will not reference each other cyclically. This enables us to model each module as a function. Applying this function will be equivalent to applying the single function defined by the module. A collection of modules is desugared into $\epscalc$ as follows. First, a sequence of let-bindings are used to name constructor functions which, when given the capabilities requested by a module, will return an instance of the module. If the module does not require any capabilities it will take $\Unit$ as its argument. The constructor function for $\kwa{M}$ is called $\kwa{MakeM}$. A function is then defined which represents the body of code in the $\kwa{Main}$ module. When invoked, this function will instantiate all the modules by invoking their constructor functions, and then execute the body of code in main. Finally, this function is invoked with the primitive capabilities passed into $\kwa{Main}$.

To demonstrate, Figure \ref{fig:wyv_tutorial_desugaring} shows how the examples above desugar. Lines 1-3 define the constructor for $\kwa{PureMod}$. Since $\kwa{PureMod}$ requires no capabilities, the constructor takes $\Unit$ as an argument on line 2. Lines 6-8 define the constructor for $\kwa{ResourceMod}$; it requires a $\kwa{File}$ capability, so the constructor takes $\kwa{\{File\}}$ as its input type on line 7. The entry point to the program is defined on lines 11-16, which invokes the constructors and then runs the body of the $\kwa{main}$ method. Line 17 starts everything off by invoking $\kwa{Main}$ with the initial set of capabilities, which in this case is just $\kwa{File}$.

\begin{figure}[h]

\begin{lstlisting}
let MakePureMod =
   $\lambda$x:Unit.
      $\lambda$f:{File}. f.append
in

let MakeResourceMod =
   $\lambda$f:{File}.
      $\lambda$x:Unit. f.append
in

let MakeMain =
   $\lambda$f:{File}.
      $\lambda$x: Unit.
         let PureMod = (MakePureMod unit) in
         let ResourceMod = (MakeResourceMod f) in
         (ResourceMod unit)

(MakeMain File) unit
\end{lstlisting}

\caption{Desugaring of $\kwa{PureMod}$ and $\kwa{ResourceMod}$ into $\epscalc$.}
\label{fig:wyv_tutorial_desugaring}
\end{figure}

When an unannotated module is translated into $\epscalc$, the desugared contents will be encapsulated with an $\kwa{import}$ expression. The selected authority on the $\kwa{import}$ expression will be that we expect of the unannotated code according to the principle of least authority in the particular example under consideration. For example, if the client only expects the unannotated code to have the $\kwa{File.append}$ effect and executes some unannotated code $e$, the corresponding $\kwa{import}$ expression will select $\kwa{\{File.append\}}$.


\subsection{Examples}

We now present several examples to show the capability-based design of $\epscalc$ can assist in reasoning about the effects and behaviour of a program. Each example exhibits some unsafe behaviour or demonstrates a particular development story. For each example we present high-level Wyvern code, translate it into $\epscalc$ using the techniques from the previous section, and then sketch an explanation as to why $\epscalc$ will accept or reject the program.\\









































\subsubsection{Unannotated Client}~\\

There is a single primitive capability $\kwa{File}$. A $\kwa{Logger}$ module possessing this capability exposes a single function $\kwa{log}$ which incurs $\kwa{File.write}$ when executed. The $\kwa{Client}$ module possesses the $\kwa{Logger}$ module and exposes a single function $\kwa{run}$ which invokes $\kwa{Logger.log}$, incurring $\kwa{File.write}$. While $\kwa{Logger}$ has been annotated, $\kwa{Client}$ has not --- if $\kwa{Client.run}$ is executed, what effects could occur? Code for this example is given below. 

\begin{lstlisting}
resource module Logger
require File

def log(): Unit with {File.append} =
    File.append(``message logged'')
\end{lstlisting}

\begin{lstlisting}
module Client
require Logger

def run(): Unit =
   Logger.log()
\end{lstlisting}

\begin{lstlisting}
resource module Main
require File
instantiate Logger(File)
instantiate Client(Logger)

Client.run()
\end{lstlisting}

The desugared version is given below. It first creates two functions, $\kwa{MakeLogger}$ and $\kwa{MakeClient}$, which instantiate the $\kwa{Logger}$ and $\kwa{Client}$ modules. Lines 1-3 define $\kwa{MakeLogger}$. When given a $\kwa{File}$, it returns a function representing $\kwa{Logger.log}$. Lines 5-8 define $\kwa{MakeClient}$. When given a $\kwa{Logger}$, it returns a function representing $\kwa{Client.run}$. Lines 10-15 define $\kwa{MakeMain}$ which returns a function which, when executed, instantiates all other modules and invokes the code in the body of $\kwa{Main}$. Program execution begins on line $17$, where $\kwa{Main}$ is given the initial capabilities --- which, in this case, is just $\kwa{File}$.

\begin{lstlisting}
let MakeLogger =
   ($\lambda$f: File.
      $\lambda$x: Unit. f.append) in
          
let MakeClient =
   ($\lambda$logger: Logger.
      import(File.append) logger = logger in
         $\lambda$x: Unit. logger unit) in
          
let MakeMain =
   ($\lambda$f: File.
      $\lambda$x: Unit.
         let LoggerModule = MakeLogger f in
         let ClientModule = MakeClient LoggerModule in
         ClientModule unit) in

(MakeMain File) unit
\end{lstlisting}

The interesting part  is on line $7$ where the unannotated code selects $\kwa{File.append}$ as its authority. This is exactly the effects of the logger, i.e. $\kwa{effects}(\Unit \rightarrow_{\kwa{File.append}} \Unit) = \{ \kwa{File.append} \}$. The code also satisfies the higher-order safety predicates, and the body of the $\kwa{import}$ expression typechecks in the empty context. Therefore, the unannotated code typechecks by \textsc{$\varepsilon$-Import} with approximate effects $\kwa{\{ \kwa{File.append} \}}$.\\









































\subsubsection{Unannotated Library}~\\

The next example inverts the roles of the last scenario: now, the annotated $\kwa{Client}$ wants to use the unannotated $\kwa{Logger}$. $\kwa{Logger}$ captures $\kwa{File}$ and exposes a single function $\kwa{log}$ which incurs the $\kwa{File.append}$ effect. $\kwa{Client}$ has a function $\kwa{run}$ which executes $\kwa{Logger.log}$, incurring its effects. $\kwa{Client.run}$ is annotated with $\varnothing$.

\begin{lstlisting}
resource module Logger
require File

def log(): Unit =
    File.append(``message logged'')
\end{lstlisting}

\begin{lstlisting}
resource module Client
require Logger

def run(): Unit with {File.append} =
   Logger.log()
\end{lstlisting}

\begin{lstlisting}
resource module Main
require File
instantiate Logger(File)
instantiate Client(Logger)

Client.run()
\end{lstlisting}

A desugaring is given below. On lines 3-4, the unannotated code is modelled using an $\kwa{import}$ expression which selects $\kwa{File.append}$ as its authority. The implementation of $\kwa{Logger}$ actually abides by this selected authority, but it has the authority to perform any operation on $\kwa{File.append}$ and, in general, could be doing any effect. \textsc{$\varepsilon$-Import} will reject this example, because the imported capability $f = \kwa{File}$ has the type $\{ \File \}$ and $\fx{\{ \File \}} = \{ \kwa{File}.* \} \not\subseteq \{ \kwa{ File.append } \}$.

\begin{lstlisting}
let MakeLogger =
   ($\lambda$f: File.
      import(File.append) f = f in
         $\lambda$x: Unit. f.append) in

let MakeClient =
	($\lambda$logger: Logger.
	   $\lambda$x: Unit. logger unit) in

let MakeMain =
   ($\lambda$f: File.
      let LoggerModule = MakeLogger f in
      let ClientModule = MakeClient LoggerModule in
      ClientModule unit) in

(MakeMain File) unit
\end{lstlisting}

The only way for this to typecheck would be to annotate $\kwa{Client.run}$ as having every effect on $\File$. This demonstrates how the effect-system of $\epscalc$ approximates unannotated code: it simply considers it as having every effect which could be incurred on those resources in scope, which here is $\kwa{File}.*$.\\





\subsubsection{Higher-Order Effects}~\\

In this scenario, $\kwa{Main}$ instantiates the $\kwa{Plugin}$ module, which itself instantiates the $\kwa{Malicious}$ module. $\kwa{Plugin}$ exposes a single function $\kwa{run}$ that should incur no effects. However, the implementation tries to read from $\kwa{File}$ by wrapping the operation inside a function and passing it to $\kwa{Malicious}$, which invokes $\kwa{File.read}$ in a higher-order way.

\begin{lstlisting}
module Malicious

def log(f: Unit $\rightarrow$ Unit):Unit
   f()
\end{lstlisting}

\begin{lstlisting}
module Plugin
instantiate Malicious

def run(f: {File}): Unit with $\varnothing$
   Malicious.log($\lambda$x:Unit. f.read)
\end{lstlisting}

\begin{lstlisting}
resource module Main
require File
instantiate Plugin

Plugin.run(File)
\end{lstlisting}

This examples shows how higher-order effects can obfuscate potential security risks. On line 3 of $\kwa{Malicious}$, the argument to $\kwa{log}$ has type $\Unit \rightarrow \Unit$. The body of $\kwa{log}$ types with the \textsc{T-}rules, which do not approximate effects. It is not clear from inspecting the unannotated code that a $\kwa{File.read}$ will be incurred. To realise this requires one to examine the source code of both $\kwa{Plugin}$ and $\kwa{Malicious}$.

A desugared version is given below. On lines 5-6, the $\kwa{Malicious}$ code selects its authority as $\varnothing$, to be consistent with the annotation on $\kwa{Plugin.run}$. This example is rejected by \textsc{$\varepsilon$-Import}. When the unannotated code is annotated with $\varnothing$, it has type $\{ \File \} \rightarrow_{\varnothing} \Unit$. The higher-order effects of this type are $\kwa{File.*}$, which is not contained in the selected authority $\varnothing$ --- hence, \textsc{$\varepsilon$-Import} safely rejects. To get this example to typecheck, the $\kwa{import}$ expression would have to select $\kwa{File.*}$ as its authority. 

\begin{lstlisting}
let MakePlugin =
	($\lambda$x: Unit.
	   let MakeMalicious =
	      ($\lambda$x: Unit.
	         import($\varnothing$) y=unit in
	            $\lambda$f: {File}. f.append) in
      let LoggerModule = MakeLogger unit in
      $\lambda$f: {File}. LoggerModule f) in

let MakeMain =
   ($\lambda$f: {File}.
      $\lambda$x: Unit.
         let ClientModule = MakeClient unit in
         ClientModule f) in

(MakeMain File) unit
\end{lstlisting}





























\subsubsection{Resource Leak}~\\

This is another example of trying to obfuscate an unsafe effect by invoking it in a higher-order manner. The setup is the same, except the function which $\kwa{Plugin}$ passes to $\kwa{Malicious}$ now returns $\kwa{File}$ when invoked. $\kwa{Malicious}$ uses this function to obtain $\kwa{File}$, and then directly invokes $\kwa{read}$ upon it.

\begin{lstlisting}
module Malicious

def log(f: Unit $\rightarrow$ File):Unit
   f().read
\end{lstlisting}

\begin{lstlisting}
module Plugin
instantiate Malicious

def run(f: {File}): Unit with $\varnothing$
   Malicious.log($\lambda$x:Unit. f)
\end{lstlisting}

\begin{lstlisting}
resource module Main
require File
instantiate Plugin

Plugin.run(File)
\end{lstlisting}

The desugaring is given below. The unannotated code in $\kwa{Malicious}$ is given on lines 5-6. The selected authority is $\varnothing$, to be consistent with the annotation on $\kwa{Plugin}$. Nothing is being imported, so the $\kwa{import}$ binds a name $\kwa{y}$ to $\unit$. This example is rejected by \textsc{$\varepsilon$-Import} because the premise $\varepsilon = \fx{\hat \tau} \cup \hofx{\annot{\tau}{\varepsilon}}$ is not satisfied. In this case, $\varepsilon = \varnothing$ and $\tau = \kwa{ (Unit \rightarrow \{ File \}) \rightarrow Unit }$. Then $\annot{\tau}{\varepsilon} = \kwa{ (Unit \rightarrow_{\varnothing} \{ File \}) \rightarrow_{\varnothing} Unit }$ and $\hofx{\annot{\tau}{\varepsilon}} = \{ \kwa{File.*} \}$. Thus, the premise cannot be satisfied and the example safely rejects.


\begin{lstlisting}
let MakePlugin =
	($\lambda$x: Unit.
	   let MakeMalicious =
	      ($\lambda$x: Unit.
	         import($\varnothing$) y=unit in
	            $\lambda$f: Unit $\rightarrow$ {File}. f().read) in
      let LoggerModule = MakeLogger unit in
      $\lambda$f: {File}. LoggerModule f) in

let MakeMain =
   ($\lambda$f: {File}.
      $\lambda$x: Unit.
         let ClientModule = MakeClient unit in
         ClientModule f) in

(MakeMain File) unit
\end{lstlisting}






