\documentclass{llncs}

\usepackage{listings}
\usepackage{proof}
\usepackage{amssymb}
\usepackage[margin=.9in]{geometry}
\usepackage{amsmath}
\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage{enumitem}
\usepackage{filecontents}
\usepackage{calc}
\usepackage[linewidth=0.5pt]{mdframed}
\allowdisplaybreaks

\usepackage{fancyhdr}
\renewcommand{\headrulewidth}{0pt}
\pagestyle{fancy}
 \fancyhf{}
\rhead{\thepage}

\lstset{tabsize=3, basicstyle=\ttfamily\small, commentstyle=\itshape\rmfamily, numbers=left, numberstyle=\tiny, language=java,moredelim=[il][\sffamily]{?},mathescape=true,showspaces=false,showstringspaces=false,columns=fullflexible,xleftmargin=5pt,escapeinside={(@}{@)}, morekeywords=[1]{objtype,module,import,let,in,fn,var,type,rec,fold,unfold,letrec,alloc,ref,application,policy,external,component,connects,to,meth,val,where,return,group,by,within,count,connect,with,attr,html,head,title,style,body,div,keyword,unit,def}}
\lstloadlanguages{Java,VBScript,XML,HTML}


\newcommand{\keywadj}[1]{\mathtt{#1}}
\newcommand{\keyw}[1]{\keywadj{#1}~}
\newcommand{\reftt}{\mathtt{ref}~}
\newcommand{\Reftt}{\mathtt{Ref}~}
\newcommand{\inttt}{\mathtt{int}~}
\newcommand{\Inttt}{\mathtt{Int}~}
\newcommand{\stepsto}{\leadsto}
\newcommand{\todo}[1]{\textbf{[#1]}}
\newcommand{\intuition}[1]{#1}
%\newcommand{\intuition}[1]{}

\newlist{pcases}{enumerate}{1}
\setlist[pcases]{
  label=\textit{Case}\protect\thiscase\textit{:}~,
  ref=\arabic*,
  align=left,
  labelsep=0pt,
  leftmargin=0pt,
  labelwidth=0pt,
  parsep=0pt
}
\newcommand{\pcase}[1][]{
  \if\relax\detokenize{#1}\relax
    \def\thiscase{}
  \else
    \def\thiscase{~#1}
  \fi
  \item
}

% definition of a configuration
\newcommand{\config}[1] { \langle #1 \rangle }

\begin{document}

\today

\section{Grammar (References)}

\[
\begin{array}{lll}
\begin{array}{lllr}
	e & ::= & x & expressions \\
  		& | & r \\
  		& | & \keywadj{new}~x \Rightarrow \overline{\sigma = e} \\
  		& | & e.m(e)\\
  		& | & e.\pi(e)\\
		& | & l & (runtime form) \\
		&&\\
		
	v & ::= & r & values \\
		& | & l \\
		&&\\

	d & ::= & \keyw{def} m(x:\tau):\tau & unlabeled~decls.\\		&&\\
		
	\sigma & ::= & d~\keyw{with}\varepsilon  & labeled~ decls.\\
		&&\\
\end{array}
& ~~~~~~
&

\begin{array}{lllr}

	\tau & ::= & \{ \bar \sigma \}  & types \\
		& | & \{ \bar r \} \\
		&&\\

	\Gamma & :: = & \varnothing & contexts\\
		& | & \Gamma,~x : \tau\\
		&&\\

	\mu & :: = & \varnothing & store\\
		& | & \mu,~l \mapsto \{ x \Rightarrow \overline{\sigma = e}\} \\
		& | & \mu,~l \mapsto \{ x \Rightarrow \bar r \} \\
&&\\

\end{array}
\end{array}
\]


\begin{itemize}
	\item $l$-terms are memory addresses.
	\item The contents of $\mu$ have the form $l \mapsto \{ x \Rightarrow \overline{\sigma = e}\}$, which means the memory address $l$ points to an object with the type $\{ \bar \sigma \}$. $x$ is the 'this' variable.
	\item For an expression $e$, $[e_1/x_1, ..., e_n/x_n]e$ is a new expression with the structure of $e$, where every free occurrence of $x_i$ is replaced with $e_i$.
	\item $\varnothing$ refers to the empty set. The empty type, consisting of zero method declarations, is denoted $\keywadj{Unit}$.
	\item A configuration is a pair $\mu~|~ e$.
	\item $\mu~|~e \longrightarrow \mu'~|~e'$ if, after one reduction step on $e$ in heap $\mu$, the program ends in heap $\mu'$ and ready to execute $e'$.
	\item To execute a program $e$ is to perform reduction steps starting from the configuration $\config{\varnothing, e}$.
	\item $\mu_1~|~e_1 \longrightarrow_* \mu_2~|~e_2$ if the configuration $\mu_2~|~e_2$ can be reached from the configuration $\mu_1~|~e_1$ by the application of one or more reduction rules.
	\item If $\mu_1~|~e_1 \longrightarrow_* \mu_2~|~v$, for some value $v$, then we say that $\mu_1~|~e_1$ terminates.
\end{itemize}

\newpage

\section{Dynamic Semantics (References)}

This first section introduces a basic dynamic semantics with no notion of a runtime effect.
\\

\fbox{$\mu~|~e \longrightarrow \mu~|~e$}

\[
\begin{array}{lll}
\begin{array}{lllr}
	\infer[\textsc{(E-MethCall1)}]
		{\mu~|~e_1.m(e_2) \longrightarrow \mu'~|~e_1'.m(e_2)}
		{\mu~|~e_1 \longrightarrow \mu~;~e_1'}
		
		~~~~~~
		
	\infer[\textsc{(E-MethCall2)}]
		{\mu~|~l.m(e_2) \longrightarrow \mu'~|~l.m(e_2')}
		{\mu~|~e_2 \longrightarrow \mu'~|~e_2'}\\[5ex]
		
	\infer[\textsc{(E-MethCall3)}]
		{\mu~|~l.m(v)
			\longrightarrow
		 \mu~|~e'[l/x, v/y]}
  		{l \mapsto \{ x \Rightarrow \overline{\sigma = e} \} \in \mu & \keywadj{def~m}(y: \tau_1) : \tau_2~\keyw{with} \varepsilon = e' \in \overline {\sigma = e}} \\[5ex]

			
	\infer[\textsc{(E-OperCall1)}]
		{\mu~;~e_1.\pi(e_2)
			\longrightarrow
		 \mu'~;~e_1'.\pi(e_2)}
		{\mu~|~e_1 \longrightarrow \mu'~|~e_1'}
~~~~~~
			\infer[\textsc{(E-OperCall2)}]
		{\mu~|~r.\pi(e_2)
			\longrightarrow
		 \mu'~|~r.\pi(e_2')}
		{\mu~|~e_2 \longrightarrow \mu'~|~e_2'} \\[5ex]
			
			\infer[\textsc{(E-OperCall3)}]
		{\mu~|~r.\pi(v)
			\longrightarrow
		 \mu'~|~\keywadj{Unit}}
		{r \in R & \pi \in \Pi} \\[5ex]
			
	\infer[\textsc{(E-New$_\sigma$)}]
		{\mu~|~\keywadj{new~x} \Rightarrow \overline{\sigma = e}
			\longrightarrow
		 \mu, l \mapsto \keywadj{new~x} \Rightarrow \overline{\sigma = e}~|~l }
		{l \notin dom(\mu)} \\[5ex]
		
\end{array}
\end{array}
\]

\section{Dynamic Semantics (References + Effects)}

We amend the definition of configuration. A configuration is a triple $\mu~|~e~|~\varepsilon$, where $\varepsilon$ represents the accumulated set of effects (i.e. pairs from $R \times \Pi$) from the program execution so far. A program $e$ has the effect $(r, \pi)$ if $\varnothing~|~e~|~\varnothing~\longrightarrow_*~\mu~|~e'~|~\varepsilon$, where $(r, \pi) \in \varepsilon$. 
\\

\fbox{$\mu~|~e~|~\varepsilon \longrightarrow \mu~|~e~|~\varepsilon$}

\[
\begin{array}{lll}
\begin{array}{lllr}
	\infer[\textsc{(E-MethCall1)}]
		{\mu~|~e_1.m(e_2)~|~\varepsilon \longrightarrow \mu'~|~e_1'.m(e_2)~|~\varepsilon'}
		{\mu~|~e_1~|~\varepsilon \longrightarrow \mu~|~e_1'~|~\varepsilon'}
		
		~~~~~~
		
	\infer[\textsc{(E-MethCall2)}]
		{\mu~|~l.m(e_2)~|~\varepsilon \longrightarrow \mu'~|~l.m(e_2')~|~\varepsilon'}
		{\mu~|~e_2~|~\varepsilon \longrightarrow \mu'~|~e_2'~|~\varepsilon'}\\[5ex]
		
	\infer[\textsc{(E-MethCall3)}]
		{\mu~|~l.m(v)~|~\varepsilon
			\longrightarrow
		  \mu~|~e'[l/x, v/y]~|~\varepsilon}
  		{l \mapsto \{ x \Rightarrow \overline{\sigma = e} \} \in \mu & \keywadj{def~m}(y: \tau_1) : \tau_2~\keyw{with} \varepsilon_2 = e' \in \overline {\sigma = e}} \\[5ex]

	\infer[\textsc{(E-OperCall1)}]
		{\mu~|~e_1.\pi(e_2)~|~\varepsilon
			\longrightarrow
		 \mu'~|~e_1'.\pi(e_2)~|~\varepsilon'}
		{\mu~|~e_1~|~\varepsilon \longrightarrow \mu'~|~e_1'~|~\varepsilon'}
~~~~~~
			\infer[\textsc{(E-OperCall2)}]
		{\mu~|~r.\pi(e_2)~|~\varepsilon
			\longrightarrow
		 \mu'~|~r.\pi(e_2')~|~\varepsilon'}
		{\mu~|~e_2~|~\varepsilon \longrightarrow \mu'~|~e_2'~|~\varepsilon'} \\[5ex]
			
			\infer[\textsc{(E-OperCall3)}]
		{\mu~|~r.\pi(v)~|~\varepsilon
			\longrightarrow
		 \mu'~|~\keywadj{Unit}~|~\varepsilon \cup \{(r,m)\}   }
		{r \in R & \pi \in \Pi} \\[5ex]
			
	\infer[\textsc{(E-New$_\sigma$)}]
		{\mu~|~\keywadj{new~x} \Rightarrow \overline{\sigma = e}~|~\varepsilon
			\longrightarrow
		 \mu, l \mapsto \keywadj{new~x} \Rightarrow \overline{\sigma = e}~|~l~|~\varepsilon}
		{l \notin dom(\mu)} \\[5ex]
		
\end{array}
\end{array}
\]


\newpage

\section{Dynamic Semantics (No References)}

\paragraph{}
This section gives a dynamic semantics with no references or effects. There are no configurations; reduction is applied to expressions.

\[
\begin{array}{lll}
\begin{array}{lllr}
	e & ::= & x & expressions \\
  		& | & e.m(e)\\
  		& | & e.\pi(e)\\
		& | & v \\
		&&\\
		
	v & ::= & r & values \\
  		& | & \keywadj{new}~x \Rightarrow \overline{\sigma = e} \\
		&&\\

	d & ::= & \keyw{def} m(x:\tau):\tau & unlabeled~decls.\\		&&\\
		
	\sigma & ::= & d~\keyw{with}\varepsilon  & labeled~ decls.\\
		&&\\
\end{array}
& ~~~~~~
&

\begin{array}{lllr}

	\tau & ::= & \{ \bar \sigma \}  & types \\
		& | & \{ \bar r \} \\
		&&\\

	\Gamma & :: = & \varnothing & contexts\\
		& | & \Gamma,~x : \tau\\
		&&\\

&&\\

\end{array}
\end{array}
\]
\fbox{$e \longrightarrow e$}

\[
\begin{array}{lll}
\begin{array}{lllr}
	\infer[\textsc{(E-MethCall1)}]
		{e_1.m(e_2) \longrightarrow e_1'.m(e_2)}
		{e_1 \longrightarrow e_1'}
		
		~~~~~~
		
	\infer[\textsc{(E-MethCall2)}]
		{v_1.m(e_2) \longrightarrow v_1.m(e_2')}
		{v_1 = \keywadj{new}~x \Rightarrow \overline{\sigma = e} & e_2 \longrightarrow e_2'}\\[5ex]
		
	\infer[\textsc{(E-MethCall3)}]
		{v_1.m(v_2)
			\longrightarrow
		 [v_1/x, v_2/y]e'}
  		{v_1 = \keywadj{new}~x \Rightarrow \overline{\sigma = e} & \keywadj{def~m}(y: \tau_1) : \tau_2~\keyw{with} \varepsilon = e' \in \overline {\sigma = e}} \\[5ex]

			
	\infer[\textsc{(E-OperCall1)}]
		{e_1.\pi(e_2)
			\longrightarrow
		 e_1'.\pi(e_2)}
		{e_1 \longrightarrow e_1'}
~~~~~~
			\infer[\textsc{(E-OperCall2)}]
		{r.\pi(e_2)
			\longrightarrow
		 r.\pi(e_2')}
		{e_2 \longrightarrow e_2'} \\[5ex]
			
			\infer[\textsc{(E-OperCall3)}]
		{r.\pi(v)
			\longrightarrow
		 \keywadj{Unit}}
		{r \in R & \pi \in \Pi} \\[5ex]
			
		
\end{array}
\end{array}
\]


\section{Dynamic Semantics (Effects + No References)}

\fbox{$e~|~\varepsilon \longrightarrow e~|~\varepsilon$}

\[
\begin{array}{lll}
\begin{array}{lllr}
	\infer[\textsc{(E-MethCall1)}]
		{e_1.m(e_2)~|~\varepsilon \longrightarrow e_1'.m(e_2)~|~\varepsilon'}
		{e_1~|~\varepsilon \longrightarrow e_1'~|~\varepsilon'}
		
		~~~~~~
		
	\infer[\textsc{(E-MethCall2)}]
		{v_1.m(e_2)~|~\varepsilon \longrightarrow v_1.m(e_2')~|~\varepsilon'}
		{v_1 = \keywadj{new}~x \Rightarrow \overline{\sigma = e} & e_2~|~\varepsilon \longrightarrow e_2'~|~\varepsilon'}\\[5ex]
		
	\infer[\textsc{(E-MethCall3)}]
		{v_1.m(v_2)~|~\varepsilon
			\longrightarrow
		 [v_1/x, v_2/y]e'~|~\varepsilon}
  		{v_1 = \keywadj{new}~x \Rightarrow \overline{\sigma = e} & \keywadj{def~m}(y: \tau_1) : \tau_2~\keyw{with} \varepsilon = e' \in \overline {\sigma = e}} \\[5ex]

			
	\infer[\textsc{(E-OperCall1)}]
		{e_1.\pi(e_2)~|~\varepsilon
			\longrightarrow
		 e_1'.\pi(e_2)~|~\varepsilon'}
		{e_1~|~\varepsilon \longrightarrow e_1'~|~\varepsilon'}
~~~~~~
			\infer[\textsc{(E-OperCall2)}]
		{r.\pi(e_2)~|~\varepsilon
			\longrightarrow
		 r.\pi(e_2')~|~\varepsilon'}
		{e_2~|~\varepsilon \longrightarrow e_2'~|~\varepsilon'} \\[5ex]
			
			\infer[\textsc{(E-OperCall3)}]
		{r.\pi(v)~|~\varepsilon
			\longrightarrow
		 \keywadj{Unit}~|~\varepsilon \cup \{(r, \pi)\}}
		{r \in R & \pi \in \Pi} \\[5ex]
			
		
\end{array}
\end{array}
\]


\newpage

\end{document}
