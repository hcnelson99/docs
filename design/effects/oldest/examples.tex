\documentclass{llncs}

\usepackage{listings}
\usepackage{proof}
\usepackage{amssymb}
\usepackage[margin=.9in]{geometry}
\usepackage{amsmath}
\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage{enumitem}
\usepackage{filecontents}
\usepackage{calc}
\usepackage[linewidth=0.5pt]{mdframed}
\usepackage{changepage}
\allowdisplaybreaks

\usepackage{fancyhdr}
\renewcommand{\headrulewidth}{0pt}
\pagestyle{fancy}
 \fancyhf{}
\rhead{\thepage}

\lstset{tabsize=3, basicstyle=\ttfamily\small, commentstyle=\itshape\rmfamily, numbers=left, numberstyle=\tiny, language=java,moredelim=[il][\sffamily]{?},mathescape=true,showspaces=false,showstringspaces=false,columns=fullflexible,xleftmargin=5pt,escapeinside={(@}{@)}, morekeywords=[1]{objtype,module,import,let,in,fn,var,type,rec,fold,unfold,letrec,alloc,ref,application,policy,external,component,connects,to,meth,val,where,return,group,by,within,count,connect,with,attr,html,head,title,style,body,div,keyword,unit,def}}
\lstloadlanguages{Java,VBScript,XML,HTML}

\newcommand{\kwa}[1]{\mathtt{#1}}
\newcommand{\kw}[1]{\kwa{#1}~}
\newcommand{\reftt}{\mathtt{ref}~}
\newcommand{\Reftt}{\mathtt{Ref}~}
\newcommand{\inttt}{\mathtt{int}~}
\newcommand{\Inttt}{\mathtt{Int}~}
\newcommand{\stepsto}{\leadsto}
\newcommand{\todo}[1]{\textbf{[#1]}}
\newcommand{\intuition}[1]{#1}
\newcommand{\hyphen}{\hbox{-}}

%\newcommand{\intuition}[1]{}

\newlist{pcases}{enumerate}{1}
\setlist[pcases]{
  label=\fbox{\textit{Case}}\protect\thiscase\textit{:}~,
  ref=\arabic*,
  align=left,
  labelsep=0pt,
  leftmargin=0pt,
  labelwidth=0pt,
  parsep=0pt
}
\newcommand{\pcase}[1][]{

  \if\relax\detokenize{#1}\relax
    \def\thiscase{}
  \else
    \def\thiscase{~\fbox{#1:}}
  \fi
  \item
}

\newcommand{\thm}[3]{
	\begin{large}
		\bf{#1}
	\end{large} \\\\
	\fbox{Statement.} ~ #2
	\fbox{Proof.}~ #3 \qed
}

\newcommand{\proofcase}[2]{
	\begin{adjustwidth}{1.5em}{0pt}
		\fbox{Case.}~~#1. \\ ~#2
	\end{adjustwidth}
}

\newcommand{\subcase}[1] {
	\begin{adjustwidth}{2.2em}{0pt}
		\underline{Subcase.} #1
	\end{adjustwidth}
}

\newcommand{\stmt}[1] {

\begin{adjustwidth}{2.5em}{0pt}
	#1
\end{adjustwidth}

}
\newcommand{\type}[2]{
	#1~\keyw{with} #2
}

\newcommand{\newd}[0]{
	\keywadj{new}_d~x \Rightarrow \overline{d = e}
}

\newcommand{\newsig}[0]{
	\keywadj{new}_\sigma~x \Rightarrow \overline{\sigma = e}
}


\begin{document}

\section{Well-Behaved and Annotated Logger}

This program instantiates a well-behaved logger and uses it to append some text to a file. In this example the only resource is $\kwa{FileIO}$ and the only operation is $\kwa{append}$. Our initial $\kwa{\Gamma}$ should contain $\kwa{FileIO : \{ FileIO \}}$.

\begin{lstlisting}
let logger = new
	def log(x : Str) : Unit with FileIO.append
			FileIO.log(x)
	
in logger.log(``hello, world!'')
\end{lstlisting}

\noindent
This program desugars as below. Let's note a few things about it:
	\begin{itemize}
		\item We assume there is some notion of a $\kwa{Str}$ and that any $\Gamma$ can type a string literal to $\kwa{Str~with~\varnothing}$.
		\item Because our system does not model arguments to operations, the desugared version calls $\kwa{FileIO.append}$ instead of $\kwa{FileIO.append(``hello, world!'')}$
		\item A function called $\kwa{m}$ that takes $\kwa{t_1}$ as input and outputs something of type $\kwa{t_2}$ is said to have the type $\kwa{m : t_1 \rightarrow t_2}$.
	\end{itemize}

\begin{lstlisting}
new$_\sigma$ x $\Rightarrow$ {
	def m(y : { log : Str -> Unit with FileIO.append }) : Unit with FileIO.append = y.log(``hello, world!'')
}.m(new$_\sigma$ x $\Rightarrow$ { def log(x : Str) : Unit with FileIO.append = FileIO.append })

\end{lstlisting}

\noindent
To typecheck we match the form of the program to the conclusion of \textsc{$\varepsilon$-MethCall}. To apply that rule we must first type the sub-expressions. 


\noindent
\subsection*{Typing Outermost Receiver}

\noindent
The expression being typed is: \\
$\kwa{new_\sigma~x \Rightarrow \{}$ \\
$\kwa{~~~def~m(y : \{ log : Str \rightarrow Unit~with~FileIO.append \}) : Unit ~with~FileIO.append~=}$\\
$\kwa{~~~~~~y.log(``hello, world!'')}$\\
$\kwa{ \} }$\\

\noindent
This is an object so we want to apply \textsc{$\varepsilon$-NewObj}. To do that we need to show $\sigma_i = e_i~\kw{OK}$ by using \textsc{$\varepsilon$-ValidImpl$_\sigma$}. In this case there's only one method, $\kwa{m}$.\\

\noindent
If we take the environment $\kwa{\Gamma, y : \{ log : .... \})}$ then $y$ has a $\kwa{log}$ method which takes a $\kwa{Str}$ as an argument. $\kwa{\Gamma \vdash ``hello, world!'' : Str~with~\varnothing}$ by assumption. The declared return type of $\kwa{log}$ is $\kwa{Unit}$ and its set of effets of $\kwa{FileIO.append}$. So now using \textsc{$\varepsilon$-MethCall}, we know $\kwa{\Gamma \vdash y.log(``hello, world!'') : Unit~with~\varnothing \cup \varnothing \cup FileIO.append}$. \\

\noindent
Now that we have typed the body of the method $\kwa{m}$ i.e. $\kwa{\Gamma \vdash y.log(``hello, world!'') : Unit~with~FileIO.append}$, we can see this aligns with the declared type/effects of $\kwa{m}$. By an application of \textsc{$\varepsilon$-ValidImpl$_\sigma$}, we conclude $\kwa{\Gamma \vdash def~m .... = y.log(``hello, world!'')~OK}$. This is the only method in the object so $\kwa{\Gamma \vdash \overline{\sigma = e}~OK}$. \\

\noindent
Finally by applying \textsc{$\varepsilon$-NewObj} we may conclude:\\ $\kwa{\Gamma \vdash new_\sigma x~\Rightarrow \{ def~m ... = y.log(``hello, world!'') \} : \{ m : \{ log : ... \} \rightarrow Unit \}~\kw{with} \varnothing  }$

\noindent
\subsection*{Typing Outermost Argument}

The expression being typed is:
$\kwa{ new_\sigma~x \Rightarrow \{ def~log(x : str) : Unit~with~FileIO.append = FileIO.append \}}$\\

\noindent
This is an object so we want to apply \textsc{$\varepsilon$-NewObj}. To do that we need to show $\sigma_i = e_i~\kwa{OK}$ by using \textsc{$\varepsilon$-ValidImpl$_\sigma$}. In this case there's only one method $\kwa{log}$. \\

\noindent
The body of $\kwa{log}$ is $\kwa{FileIO.append}$. The receiver is $\kwa{FileIO}$ which is a resource in $\Gamma$, so $\kwa{\Gamma \vdash FileIO : \{ FileIO \}}$. By using \textsc{$\varepsilon$-OperCall} we can type the body $\kwa{\Gamma \vdash FileIO.append : Unit~\kw{with} FileIO.append}$. \\

\noindent
The declared type of $\kwa{log}$ is $\kwa{log : Str \rightarrow Unit~with~ FileIO.append}$. We can see the return type and effect-set matches the return-type and effect-set of the body. Therefore $\kwa{\Gamma \vdash \sigma = e~OK}$ for this method. This is the only method, so $\kwa{\Gamma \vdash \overline{\sigma = e}~OK}$.\\

\noindent
Finally by applying \textsc{$\varepsilon$-NewObj} we may conclude:\\
$\kwa{\Gamma \vdash new_\sigma~x \Rightarrow \{ def~log.... = FileIO.append \} : \{ log : Str \rightarrow Unit~with~FileIO.append \} ~with~\varnothing}$

\subsection*{Typing Outermost Method Call}

Since we've typed the receiver and the argument, we can see that the receiver has a method called $\kwa{m}$. $\kwa{m}$ has a formal parameter type $\kwa{\{ log : Str \rightarrow Unit~with~FileIO.append \}}$, which is the same as our actual argument.\\

\noindent
Let $\kwa{e}$ refer to the whole program. By an application of \textsc{$\varepsilon$-MethCall} we may conclude: \\
$\kwa{\Gamma \vdash e : Unit~with~\varnothing \cup \varnothing \cup FileIO.append}$


\end{document}