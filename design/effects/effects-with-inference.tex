\documentclass{llncs}

\usepackage{listings}
\usepackage{proof}
\usepackage{amssymb}
\usepackage[margin=.9in]{geometry}
\usepackage{amsmath}
\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage{enumitem}
\usepackage{filecontents}
\usepackage{calc}
\usepackage[linewidth=0.5pt]{mdframed}
\usepackage{changepage}
\allowdisplaybreaks

\usepackage{fancyhdr}
\renewcommand{\headrulewidth}{0pt}
\pagestyle{fancy}
 \fancyhf{}
\rhead{\thepage}

\lstset{tabsize=3, basicstyle=\ttfamily\small, commentstyle=\itshape\rmfamily, numbers=left, numberstyle=\tiny, language=java,moredelim=[il][\sffamily]{?},mathescape=true,showspaces=false,showstringspaces=false,columns=fullflexible,xleftmargin=5pt,escapeinside={(@}{@)}, morekeywords=[1]{objtype,module,import,let,in,fn,var,type,rec,fold,unfold,letrec,alloc,ref,application,policy,external,component,connects,to,meth,val,where,return,group,by,within,count,connect,with,attr,html,head,title,style,body,div,keyword,unit,def}}
\lstloadlanguages{Java,VBScript,XML,HTML}

\newcommand{\keywadj}[1]{\mathtt{#1}}
\newcommand{\keyw}[1]{\keywadj{#1}~}
\newcommand{\reftt}{\mathtt{ref}~}
\newcommand{\Reftt}{\mathtt{Ref}~}
\newcommand{\inttt}{\mathtt{int}~}
\newcommand{\Inttt}{\mathtt{Int}~}
\newcommand{\stepsto}{\leadsto}
\newcommand{\todo}[1]{\textbf{[#1]}}
\newcommand{\intuition}[1]{#1}
\newcommand{\hyphen}{\hbox{-}}

%\newcommand{\intuition}[1]{}

\newlist{pcases}{enumerate}{1}
\setlist[pcases]{
  label=\fbox{\textit{Case}}\protect\thiscase\textit{:}~,
  ref=\arabic*,
  align=left,
  labelsep=0pt,
  leftmargin=0pt,
  labelwidth=0pt,
  parsep=0pt
}
\newcommand{\pcase}[1][]{

  \if\relax\detokenize{#1}\relax
    \def\thiscase{}
  \else
    \def\thiscase{~\fbox{#1:}}
  \fi
  \item
}

\newcommand{\thm}[3]{
	\begin{large}
		\bf{#1}
	\end{large} \\\\
	\fbox{Statement.} ~ #2
	\fbox{Proof.}~ #3 \qed
}

\newcommand{\proofcase}[2]{
	\begin{adjustwidth}{1.5em}{0pt}
		\fbox{Case.}~~#1. \\ ~#2
	\end{adjustwidth}
}

\newcommand{\subcase}[1] {
	\begin{adjustwidth}{2.2em}{0pt}
		\underline{Subcase.} #1
	\end{adjustwidth}
}

\newcommand{\stmt}[1] {

\begin{adjustwidth}{2.5em}{0pt}
	#1
\end{adjustwidth}

}
\newcommand{\type}[2]{
	#1~\keyw{with} #2
}

\newcommand{\newd}[0]{
	\keywadj{new}_d~x \Rightarrow \overline{d = e}
}

\newcommand{\newsig}[0]{
	\keywadj{new}_\sigma~x \Rightarrow \overline{\sigma = e}
}


\begin{document}


\section{Grammar}

\[
\begin{array}{lll}

\begin{array}{lllr}

e & ::= & x & expressions \\
  		& | & r \\
		& | & \keywadj{new}_\sigma~x \Rightarrow \overline{\sigma = e} \\
 		& | & \keywadj{new}_d~x \Rightarrow \overline{d = e} \\
 		& | & e.m(e)\\
 		& | & e.\pi\\
		&&\\

\tau & ::= & \{ \bar \sigma \} & types \\
		& | & \{ \bar r \} \\
		& | & \{ \bar d \} \\
		& | & \{ \bar d ~\keyw{captures} \varepsilon \} \\
		&&\\
		
\sigma & ::= & d~\keyw{with}\varepsilon  & labeled~ decls.\\
		&&\\

d & ::= & \keyw{def} m(x:\tau):\tau & unlabeled~decls.\\
		&&\\

\end{array}
& ~~~~~~
&
\end{array}
\]

\noindent \textbf{Notes:}
\begin{itemize}
	\item $\sigma$ denotes a declaration with effect labels; $d$ a declaration without effect labels.
	\item $\keywadj{new}_\sigma$ is for creating annotated objects; $\keywadj{new}_d$ for unannotated objects.
	\item $\{ \bar \sigma \}$ is the type of an annotated object. $\{ \bar d \}$ is the type of an unannotated object.
	\item $\{ \bar d ~\keyw{captures} \varepsilon \}$ is a special kind of type that doesn't appear in source programs but may be assigned by the new rules in this section. Intuitively, $\varepsilon$ is an upper-bound on the effects captured by $\{ \bar d \}$.
\end{itemize}

\section{Semantics}

\subsection{Static Semantics}

\noindent
$\fbox{$\Gamma \vdash e : \tau$}$

\[
\begin{array}{c}
\infer[\textsc{(T-Var)}]
	{\Gamma,~x : \tau \vdash x : \tau}
	{}
~~~~~~~~~~
\infer[\textsc{(T-Resource)}]
	{\Gamma,~r : \{ \bar r \} \vdash r : \{ \bar r \}}
	{} \\[5ex]
~~~~~~~~~~
\infer[\textsc{(T-OperCall)}]
	{\Gamma \vdash e_1.\pi : \keywadj{Unit}}
	{\Gamma \vdash e_1 : \{ \bar r \}} \\[5ex]
~~~~~~~~~~
\infer[\textsc{(T-MethCall$_\sigma$)}]
	{\Gamma \vdash e_1.m(e_2) : \tau_3}
	{\Gamma \vdash e_1 : \{ \bar \sigma \} & \keyw{def} m(y : \tau_2) : \tau_3~\keyw{with} \varepsilon_3 \in \{ \bar \sigma \} &  \Gamma \vdash e_2 : \tau_2 }\\[5ex]
~~~~~~~~~~
\infer[\textsc{(T-MethCall$_d$)}]
	{\Gamma \vdash e_1.m(e_2) : \tau_3}
	{\Gamma \vdash e_1 : \{ \bar d\} & \keyw{def} m(y : \tau_2) : \tau_3 \in \{ \bar d \} &  \Gamma \vdash e_2 : \tau_2 }\\[5ex]
~~~~~~~~~~

~~~~~~~~~~
\infer[\textsc{(T-New$_\sigma$)}]
	{\Gamma \vdash~\keywadj{new}_\sigma~x \Rightarrow \overline{\sigma = e} : \{ \bar \sigma \}}
	{\Gamma \vdash \sigma_i = e_i~\keywadj{OK}}
~~~~~~~~~~
\infer[\textsc{(T-New$_d$)}]
	{\Gamma \vdash~\keywadj{new}_d~x \Rightarrow \overline{d = e} : \{ \bar d \}}
	{\Gamma \vdash d_i = e_i~\keywadj{OK}}\\[5ex]
\end{array}
\]

\noindent
$\fbox{$\Gamma \vdash d = e~\keyw{OK}$}$
\[
\begin{array}{c}
\infer[\textsc{($\varepsilon$-ValidImpl$_d$)}]
	{\Gamma \vdash d = e~\keywadj{OK}}
	{d = \keyw{def} m(y : \tau_2) : \tau_3 & \Gamma, y : \tau_2 \vdash e : \tau_3}
	\\[5ex]
\end{array}
\]

\noindent
$\fbox{$\Gamma \vdash \sigma = e~\keyw{OK}$}$

\[
\begin{array}{c}
\infer[\textsc{($\varepsilon$-ValidImpl$_\sigma$)}]
	{\Gamma \vdash \sigma = e~\keywadj{OK}}
	{\Gamma,~y:\tau_2 \vdash e: \tau_3~\keyw{with} \varepsilon_3 & \sigma = \keyw{def} m(y:\tau_2):\tau_3~\keyw{with} \varepsilon_3} \\[5ex]
\end{array}
\]


\noindent
\fbox{$\Gamma \vdash e : \tau~\keyw{with} \varepsilon$}

\[
\begin{array}{c}
	\infer[\textsc{($\varepsilon$-Var)}]
  {\Gamma,~x:\tau \vdash x: \type{\tau}{\varnothing} }
  {} 
~~~~~~~~~~
\infer[\textsc{($\varepsilon$-Resource)}]
  {\Gamma,~r :\{\bar r\} \vdash r: \type{   \{ \bar r \}  }{\varnothing}}
  {} \\[5ex]

\infer[\textsc{($\varepsilon$-NewObj)}]
	{\Gamma \vdash \newsig : \{ \bar \sigma \}~\keyw{with} \varnothing}
	{\Gamma,~x : \{ \bar \sigma \} \vdash \overline{\sigma = e}~\keywadj{OK}} ~~~~~~

\infer[\textsc{($\varepsilon$-OperCall)}]
	{\Gamma \vdash e_1.\pi : \keyw{Unit} \keyw{with} \{ \bar r.\pi \} \cup \varepsilon_1}
	{\Gamma \vdash e_1 : \{ \bar r \}~ \keyw{with} \varepsilon_1} \\[5ex]
	
\infer[\textsc{($\varepsilon$-MethCall)}]
	{\Gamma \vdash e_1.m_i(e_2):\tau_3~\keyw{with} \varepsilon_1 \cup \varepsilon_2 \cup \varepsilon_3}
	{\Gamma \vdash e_1 : \{ \bar \sigma \}~\keyw{with} \varepsilon_1 & \Gamma \vdash e_2 : \tau_2~\keyw{with} \varepsilon_2 & \sigma_i = \keyw{def} m_i(y:\tau_2):\tau_3~\keyw{with} \varepsilon_3} \\[5ex]
	
\infer[\textsc{(C-NewObj)}]
	{\Gamma \vdash~\keywadj{new}_d~x \Rightarrow \overline{d = e} : \{  \bar d~\keyw{captures} \varepsilon_c \} ~\keyw{with} \varnothing }
	{\varepsilon_c = \keywadj{effects}(\Gamma') & \Gamma' \subseteq \Gamma & \Gamma', x : \{ \bar d~\keyw {captures} \varepsilon_c \} \vdash \overline{d = e}~\keyw{OK}} \\[5ex]
	
\infer[\textsc{(C-MethCall)}]
	{\Gamma \vdash e_1.m_i(e_2) : \tau_3~ \keyw{with} \varepsilon_1 \cup \varepsilon_2 \cup \keywadj{effects}(\tau_2) \cup \varepsilon_c}
	{\Gamma \vdash e_1 : \{ \bar d~\keyw{captures} \varepsilon_c \}~\keyw{with} \varepsilon_1 & \Gamma \vdash e_2:\tau_2~\keyw{with} \varepsilon_2&d_i =~\keyw{def} m_i(y:\tau_2):\tau_3 } \\[5ex]

\infer[\textsc{(C-Inference)}]
	{\Gamma \vdash e : \tau ~\keyw{with} \keywadj{effects}(\Gamma') }
	{\Gamma' \subseteq \Gamma & \Gamma' \vdash e : \tau } \\[5ex]
\end{array}
\]

\noindent \textbf{Notes:}

\begin{itemize}
	\item This system includes all the rules from the fully-annotated system.
	\item The \textsc{T} rules do standard typing of objects, without any effect analysis. Their sole purpose is so $\varepsilon$-ValidImpl$_d$ can be applied. \textbf{We are assuming the T-rules on their own are sound}.
	\item In \textsc{C-NewObj}, $\Gamma'$ is intended to be some subcontext of the current $\Gamma$. The object is labelled as capturing the effects in $\Gamma'$ (exact definition in the next section).
	\item In $\textsc{C-NewObj}$ we must add $\keywadj{effects}(\tau_2)$ to the static effects of the object, because the method body will have access to the resources captured by $\tau_2$ (the type of the argument passed into the method).
	\item A good choice of $\Gamma'$ would be $\Gamma$ restricted to the free variables in the object definition.
	\item The purpose of \textsc{C-Inference} is to ascribe static effects to unannotated portions of code (for instance, the body of an unlabeled method).
	\item As a useful convention we'll often use $\varepsilon_c$ to denote the output of the $\keywadj{effects}$ function.
\end{itemize}

\subsection{$\keywadj{effects}$ Function}

\noindent
The $\keywadj{effects}$ function returns the set of effects captured in a particular context.

\begin{itemize}
	\item $\keywadj{effects}(\varnothing) = \varnothing$
	\item $\keywadj{effects}(\Gamma, x : \tau) = \keywadj{effects}(\Gamma) \cup \keywadj{effects}(\tau)$
	\item $\keywadj{effects}(\{\bar r\}) = \{ (r, \pi) \mid r \in \bar r, \pi \in \Pi \}$
	\item $\keywadj{effects}(\{\bar \sigma\}) = \bigcup_{\sigma \in \bar \sigma}~\keywadj{effects}(\sigma)$
	\item $\keywadj{effects}(\{\bar d\}) = \bigcup_{d \in \bar d}~\keywadj{effects}(d)$
	\item $\keywadj{effects}(d~\keyw{with} \varepsilon) = \varepsilon \cup \keywadj{effects}(d)$
	\item $\keywadj{effects}(\keywadj{def~m}(x : \tau_1) : \tau_2) = \keywadj{effects}(\tau_2)$
	\item $\keywadj{effects}(\{\bar d ~\keyw{captures} \varepsilon_c\}) = \varepsilon_c$
\end{itemize}

\noindent \textbf{Notes:}
\begin{itemize}
	\item Since a method can return a capability for a resource $r$ we need to figure out what the return type of a method captures. This requires a recursive crawl through the definitions and types inside it.
	\item In the last case we don't want to recurse to sub-declarations because the effects have already been captured previously (this is $\varepsilon_c$) by a potentially different context.
\end{itemize}

\subsection{Dynamic Semantics}

~\\
\noindent
\fbox{$e \longrightarrow e~|~\varepsilon$}

\[
\begin{array}{c}

	\infer[\textsc{(E-MethCall1)}]
		{e_1.m(e_2) \longrightarrow e_1'.m(e_2)~|~\varepsilon}
		{e_1 \longrightarrow e_1'~|~\varepsilon} \\[5ex]

	\infer[\textsc{(E-MethCall2$_{\sigma}$)}]
		{v_1.m(e_2) \longrightarrow v_1.m(e_2')~|~\varepsilon}
		{v_1 = \newsig & e_2 \longrightarrow e_2'~|~\varepsilon} ~~~~~~
		
	\infer[\textsc{(E-MethCall2$_d$)}]
		{v_1.m(e_2) \longrightarrow v_1.m(e_2')~|~\varepsilon}
		{v_1 = \newd & e_2 \longrightarrow e_2'~|~\varepsilon}\\[5ex]
				
	\infer[\textsc{(E-MethCall3$_{\sigma}$)}]
		{v_1.m(v_2)
			\longrightarrow
		 [v_1/x, v_2/y]e~|~\varnothing}
  		{v_1 = \newsig & \keywadj{def~m}(y: \tau_1) : \tau_2~\keyw{with} \varepsilon = e \in \overline {\sigma = e}} \\[5ex]

	\infer[\textsc{(E-MethCall3$_d$)}]
		{v_1.m(v_2)
			\longrightarrow
		 [v_1/x, v_2/y]e~|~\varnothing}
  		{v_1 = \newd & \keywadj{def~m}(y: \tau_1) : \tau_2 = e \in \overline {d = e}} \\[5ex]

	\infer[\textsc{(E-OperCall1)}]
		{e_1.\pi
			\longrightarrow
		 e_1'.\pi~|~\varepsilon}
		{e_1 \longrightarrow e_1'~|~\varepsilon}
~~~~~~

			\infer[\textsc{(E-OperCall2)}]
		{r.\pi
			\longrightarrow
		 \keywadj{unit}~|~\{r.\pi\}}
		{} \\[5ex]
			
\end{array}
\]
\noindent
\fbox{$e \longrightarrow_* e~|~\varepsilon$}

\[
\begin{array}{c}

	\infer[\textsc{(E-MultiStep1)}]
	{e \longrightarrow_* e~|~\varnothing}
	{} ~~~~~~~~
	
	\infer[\textsc{(E-MultiStep2)}]
	{e \longrightarrow_* e'~|~\varepsilon}
	{e \longrightarrow e'~|~\varepsilon} \\[5ex]

	\infer[\textsc{(E-MultiStep3)}]
	{e \longrightarrow_* e''~|~\varepsilon_1 \cup \varepsilon_2}
	{e \longrightarrow_* e'~|~\varepsilon_1 & e' \longrightarrow_* e''~|~\varepsilon_2}

\end{array}
\]

\noindent \textbf{Notes:}
\begin{itemize}
	\item \textsc{E-MethCall2$_d$} and \textsc{E-MethCall2$_\sigma$} are really doing the same thing, but one applies to labeled objects (the $\sigma$ version) and the other on unlabeled objects. Same goes for \textsc{E-MethCall3$_\sigma$} and \textsc{E-MethCall3$_d$}.
	\item \textsc{E-MethCall1} can be used for both labeled and unlabeled objects.
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Substitution Function}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\noindent
We extend our Substitution function from the previous system in a straightforward way by adding a new case for unlabeled objects.

\begin{itemize}
	\item $[e'/z]z = e'$
	\item $[e'/z]y = y$, if $y \neq z$
	\item $[e'/z]r = r$
	\item $[e'/z](e_1.m(e_2)) = ([e'/z]e_1).m([e'/z]e_2)$
	\item $[e'/z](e_1.\pi) = ([e'/z]e_1).\pi$
	\item $[e'/z](\newd) = \keywadj{new}_\sigma~x \Rightarrow \overline{ \sigma = [e'/z]e }$, if $z \neq x$ and $z \notin \keywadj{freevars}(e_i)$
	\item $[e'/z](\newsig) = \keywadj{new}_\sigma~x \Rightarrow \overline{ \sigma = [e'/z]e }$, if $z \neq x$ and $z \notin \keywadj{freevars}(e_i)$
\end{itemize}



\section{Proofs}
~


\thm{Lemma 3.1. (Canonical Forms)}
{Suppose $e$ is a value. The following are true:
	\begin{itemize}
	\item If $\Gamma \vdash e : \type{ \{ \bar r \} }{\varepsilon} $, then $e = r$ for some resource $r$.
	\item If $\Gamma \vdash e : \type{ \{ \bar \sigma \}}{\varepsilon}$, then $e = \newsig$.
	\item If $\Gamma \vdash e : \{ \bar d~\keyw{captures} \varepsilon_c \}~ \keyw{with} \varepsilon$, then $e = \keywadj{new}_{d}~x \Rightarrow \overline{ d = e }$.
	\end{itemize}
Furthermore, $\varepsilon = \varnothing$ in each case. \\\\
}
{ These typing judgements each appear exactly once in the conclusion of different rules. The result follows by inversion of \textsc{$\varepsilon$-Resource}, \textsc{$\varepsilon$-NewObj}, and \textsc{C-NewObj} respectively. \\
}

\thm{Lemma 3.2. (Substitution Lemma)}
{If $\Gamma, z : \tau' \vdash e : \tau~\keyw{with} \varepsilon$, and $\Gamma \vdash e' : \tau'~\keyw{with} \varepsilon'$, then $\Gamma \vdash [e'/z]e : \tau~\keyw{with} \varepsilon$. \\\\
\fbox{Intuition} If you substitute $z$ for something of the same type, the type of the whole expression stays the same after substitution.
\\\\}
{We've already proven the lemma by structural induction on the $\varepsilon$ rules. The new case is defined on a form not in the grammar for the fully-annotated system. So all that remains is to induct on derivations of $\Gamma \vdash e : \type{\tau}{\varepsilon}$ using the new $\textsc{C}$ rules.\\

	\proofcase{\textsc{C-MethCall}}{
Then $e = e_1.m(e_2)$ and $[e'/z]e = ([e'/z]e_1).m([e'/z]e_2)$ . By inductive assumption we know that $e_1$ and $[e'/z]e_1$ have the same types, and that $e_2$ and $[e'/z]e_2$ have the same types. Since $e$ and $[e'/z]e$ have the same syntactic struture, and their corresponding subexpressions have the same types, then $\Gamma$ can use \textsc{C-MethCall} to type $[e'/z]e$ the same as $e$.\\
}

	\proofcase{\textsc{C-Inference}}{
Then $\Gamma \vdash e : \tau~\keyw{with} \keywadj{effects}(\Gamma')$, where $\Gamma' \subseteq \Gamma$. By inversion $\Gamma' \vdash e : \tau$. Applying the inductive hypothesis (and our assumption that the \textsc{T} rules are sonud) $\Gamma' \vdash [e'/z]e : \tau$. Since $\Gamma' \subseteq \Gamma'$ we have $\Gamma' \vdash [e'/z]e : \tau~\keyw{with} \keyw{effects}(\Gamma')$ under \textsc{C-Inference}. Because $\Gamma' \subseteq \Gamma$ then $\Gamma \vdash [e'/z]e : \tau~\keyw{with} \keyw{effects}(\Gamma')$.\\


}

	\proofcase{\textsc{C-NewObj}}{
		Then $e = \newd$. $z$ appears in some method body $e_i$. By inversion we know $\Gamma, x : \{ \bar \sigma \} \vdash \overline {d = e}~\keywadj{OK}$. The only rule with this conclusion is \textsc{$\varepsilon$-ValidImpl$_d$}; by inversion on that we know for each $i$ that:
		 \begin{itemize}
		 	\item $d_i = \keyw{def} m_i(y : \tau_1) : \tau_2~\keyw{with} \varepsilon$
		 	\item $\Gamma, y : \tau_1 \vdash e_i : \tau_2~\keyw{with} \varepsilon$
		\end{itemize}

\noindent
If $z$ appears in the body of $e_i$ then $\Gamma, z : \tau \vdash d_i = e_i~\keywadj{OK}$ by inductive assumption. Then we can use \textsc{$\varepsilon$-ValidImpl$_d$} to conclude $\overline{d = [e'/z]e}~\keywadj{OK}$. This tells us that the types and static effects of all the methods are unchanged under substitution. By choosing the same $\Gamma' \subseteq \Gamma$ used in the original application of \textsc{C-NewObj}, we can apply \textsc{C-NewObj} to the expression after substitution. The types and static effects the methods are the same, and the same $\Gamma'$ has been chosen, so $[e'/z]e$ will be ascribed the same type as $e$.
}
}

\thm{Lemma 3.3. (Monotonicity of $\keywadj{effects}$)}
{If $\Gamma_1 \subseteq \Gamma_2$ then $\keywadj{effects}(\Gamma_1) \subseteq \keywadj{effects}(\Gamma_2)$ \\\\}
{Because $\keywadj{effects}(\Gamma_1)$ is the union of $\keywadj{effects}(\tau)$, for every $(x, \tau) \in \Gamma_1 \subseteq \Gamma_2$. Then $\keywadj{effects}(\Gamma_1) \subseteq \keywadj{effects}(\Gamma_2)$.\\\\}

\thm{Lemma 3.4. (Use Principle)}
{If $\Gamma \vdash e_A : \tau_A~\keyw{with} \varepsilon_A$, and $e_A \longrightarrow_* e_A'~|~\varepsilon$, then $\forall r.\pi \in \varepsilon \mid (r, \{ r \}) \in \Gamma$. Furthermore, $\varepsilon \subseteq \keywadj{effects}(\Gamma)$.\\\\}
{The only reduction that can add effects to $\varepsilon$ is $r.\pi$. So at some point, an expression of the form $r.\pi$ must have been evaluated. In the source program it must have had the form $e.\pi$. Since the entire program typechecked under $\Gamma$, $e$ must have been typed to $\{ r \}$ at some point. Since resources cannot be dynamically created, $(r, \{ r \}) \in \Gamma$. Since every resource with an operation called upon it is $\Gamma$, $\varepsilon \subseteq \keywadj{effects}(\Gamma)$ follows by the definition of $\keywadj{effects}$ for the case of a resource. \\

\noindent
\fbox{Intuition.} If you typecheck $e$ with $\Gamma$, if an effect can happen on $r$ when executing $e$ then $r$ must be in $\Gamma$.
\\\\}

\thm{Lemma 3.5. (Tightening Lemma)}
{If $\Gamma \vdash e : \type{\tau}{\varepsilon}$ then $\Gamma \cap \keywadj{freevars}(e) \vdash e : \type{\tau}{\varepsilon}$. \\\\
}{The typing judgements operate on the form of $e$, so don't consider any variables external to $e$.\\
}

\noindent
\fbox{Note.} We'll use $\keywadj{freevars}(e) \cap \Gamma$ to mean $\Gamma$, where the pair $(x,\tau)$ is thrown out if $x \notin \keywadj{freevars}(e)$. \\

\noindent
\fbox{Intuition.} If you can typecheck $e$ in $\Gamma$, you can throw out the parts in $\Gamma$ not relevant to $e$ and still typecheck it.\\\\

\begin{large}
\bf{Definition 3.6. ($\keywadj{label}$)}
\end{large}

Given a program containing unlabeled parts we can safely label those parts. This process is well-defined if $\Gamma \vdash e:  \tau$; then we say the labeling of $e$ is $\keywadj{label}(\Gamma, e) = \hat e$.

\begin{itemize}
	\item $\keywadj{label}(\Gamma, r)$ = r
	\item $\keywadj{label}(\Gamma, x)$ = x
	\item $\keywadj{label}(\Gamma, e_1.m(e_2)) = \keywadj{label}(e_1).m(\Gamma, \keywadj{label}(e_2))$
	\item $\keywadj{label}(\Gamma, e_1.\pi(e_2)) = \keywadj{label}(e_1).\pi(\keywadj{label}(e_2))$
	\item $\keywadj{label}(\Gamma, \keyw{new_\sigma} x \Rightarrow \overline{\sigma = e}) = \keywadj{new}_\sigma x \Rightarrow \keywadj{label \hyphen helper}(\Gamma, \overline{\sigma = e})$
	\item $\keywadj{label}(\keyw{new_d} x \Rightarrow \overline{d = e}) = \keyw{new_\sigma} x \Rightarrow \keywadj{label \hyphen helper}(\Gamma, \overline{d = e})$
	\item $\keywadj{label \hyphen helper}(\sigma = e) = \sigma = \keywadj{label}(\Gamma, e)$
	\item $\keywadj{label \hyphen helper}(\keywadj{def}~m(y : \tau_2) : \tau_3 = e) = \keywadj{def}~m(y : \tau_2) : \tau_3~\keyw{with} \keywadj{effects}(\Gamma \cap \keywadj{freevars}(e)) = \keywadj{label}(\Gamma, e)$
\end{itemize}

\noindent \textbf{Notes:}
\begin{itemize}
\item Beware of confusing notation: there are two types of equality in the above definitions. One is the equality which defines $\keywadj{label}$, and the other is the equality $\sigma = e$ of declarations in the programming language.
\item The program after labeling will be fully-labeled and contain terms entirely from the grammar for fully-labeled programs. Hence we can appeal to the soundness of that system.
\item $\keywadj{label}$ is defined on expressions; $\keywadj{label \hyphen helper}$ on declarations. This is just for clarity; everywhere other than this section we'll only use $\keywadj{label}$.
\item Initially it seems like $\keywadj{label}$ on a $\keywadj{new_\sigma}$ object should just be the identity function; but the body of the methods of such an object may instantiate unlabeled objects and/or call methods on unlabeled objects, so we must recursively label those.
\item From here on out we will use $\hat e$ to refer to a fully-labeled program. We may sometimes say $\keywadj{labels}(e) = \hat e$, and from then on refer to the labeled version of $e$ as $\hat e$. We'll use $\hat \tau$ and $\hat \varepsilon$ to refer to its type and static effects.
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\noindent
\thm{Lemma 3.7. (Linearity of $\keywadj{label}$ over $\keywadj{substitution}$)}
{$\keywadj{label}([e'/z]e) = [\keywadj{label}(e')/z](\keywadj{label}(e))$\\\\}
{Induction on expression $e$.}.

\noindent
\thm{Lemma 3.8. (Runtime Invariance Under $\keywadj{label}$)}
{If the following are true:
	\begin{itemize}
	\item $\Gamma \vdash e_A : \type{\tau_A}{\varepsilon_A}$
	\item $e_A \longrightarrow e_B~|~\varepsilon$
	\item $\hat e_A = \keywadj{label}(e_A, \Gamma)$
	\end{itemize}
Then $\hat e_A \longrightarrow \hat e_B~|~\varepsilon$ and $\hat e_B = \keywadj{label}(e_B, \Gamma)$.\\\\
}
{Induct on the form of $e_A$ and then on the reduction rule $e_A \longrightarrow e_B~|~\varepsilon$.\\

\proofcase{$e=r$, $e=x$, $e=\newsig$, $e=\newd$}{
	Then $e$ is a value and the theorem statement holds automatically.\\
}

\proofcase{$e=e_1.\pi$}{
The only typing rule which applies is \textsc{$\varepsilon$-OperCall}, which tells us:
	\begin{itemize}
		\item $\Gamma \vdash e_1 : \type{ \{ r \} }{\varepsilon_1}$
		\item $\Gamma \vdash e_1.\pi : \type{\keywadj{Unit}}{\varepsilon_1 \cup \{ r.\pi \}}$
	\end{itemize}
\noindent
There are two possible reductions. \\

\subcase{\textsc{E-OperCall1}. We also know $e_1 \longrightarrow e_1'~|~\varepsilon$, and $e_1.\pi \longrightarrow e_1'.\pi~|~\varepsilon$. By inductive assumption, $\hat e_1 \longrightarrow \hat e_1'~|~\varepsilon$, and $\hat e_1' = \keywadj{label}(e_1', \Gamma)$. Applying definitions, $\hat e_A = \keywadj{label}(e_1.\pi, \Gamma) = (\keywadj{label}(e_1, \Gamma)).\pi = \hat e_1.\pi$. Because $\hat e_1 \longrightarrow \hat e_1'~|~\varepsilon$, we may apply the reduction \textsc{E-OperCall1} to obtain $\hat e_1.\pi \longrightarrow \hat e_1'.\pi~|~\varepsilon$. Lastly, $\hat e_B = \keywadj{label}(e_1'.\pi, \Gamma) = (\keywadj{label}(e_1', \Gamma)).\pi$, which we know to be $\hat e_1'.\pi$ by inductive assumption.\\
}

\subcase{\textsc{E-OperCall2}. We also know $e_1 = r$ and $r.\pi \longrightarrow \keywadj{Unit}~|~\{ r.\pi \}$. Applying definitions, $\hat e_A = \keywadj{label}(r.\pi) = (\keywadj{label}(r)).\pi = r.\pi = e_A$. The theorem holds immediately.\\

}
}
	
\proofcase{$e=e_1.m_i(e_2)$}{
\noindent
There are five possible reductions. \\

\subcase{ \textsc{E-MethCall1}. We also know $e_1 \longrightarrow e_1'~|~\varepsilon$ and $e_1.m_i(e_2) \longrightarrow e_1'.m_i(e_2)~|~\varepsilon$. By inductive assumption, $\hat e_1 \longrightarrow \hat e_1'~|~\varepsilon$, and $\keywadj{label}(e_1', \Gamma) = \hat e_1'$. Applying definitions $\hat e_A = \keywadj{label}(e_1.m_i(e_2), \Gamma) = (\keywadj{label}(e_1), \Gamma).m_i(\keywadj{label}(e_2), \Gamma) = \hat e_1.m_i(\hat e_2)$. Because $\hat e_1 \longrightarrow \hat e_1'~|~\varepsilon$, we may apply the reduction \textsc{E-MethCall1} to obtain $\hat e_1.m_i(\hat e_2) \longrightarrow \hat e_1'.m_i(\hat e_2)~|~\varepsilon$. Lastly, $\hat e_B = \keywadj{label}(e_1'.m_i(\hat e_2), \Gamma) = \\ (\keywadj{label}(e_1'), \Gamma).m_i(\keywadj{label}(e_2), \Gamma)$, which we know to be $\hat e_1'.m_i(\hat e_2) = \hat e_B$ by assumptions.\\

}

\subcase{ \textsc{E-MethCall2$_\sigma$}. We also know $e_1 = v_1 = \newsig$, and $e_2 \longrightarrow e_2'~|~\varepsilon$ and $v_1.m_i(e_2) \longrightarrow v_1.m_i(e_2')~|~\varepsilon$. By inductive assumption, $\hat e_2 \longrightarrow \hat e_2'~|~\varepsilon$, and $\keywadj{label}(e_2', \Gamma) = \hat e_2'$. Applying definitions, $\hat e_A = \keywadj{label}(v_1.m_i(e_2), \Gamma) = (\keywadj{label}(v_1, \Gamma)).m_i(\keywadj{label}(e_2, \Gamma)) = \hat v_1.m_i(\hat e_2)$. Because $\hat e_2 \longrightarrow \hat e_2'~|~\varepsilon$, we may apply the reduction \textsc{E-MethCall$_\sigma$} to obtain $\hat v_1.m_i(\hat e_2) \longrightarrow \hat v_1.m_i(\hat e_2')$. Lastly, $\hat e_B = \keywadj{label(v_1.m_i(e_2')} = (\keywadj{label}(v_1)).m_i(\keywadj{label}(e_2'))$, which we know to be $\hat v_1.m_i(\hat e_2')$ by assumptions. \\
}

\subcase{ \textsc{E-MethCall2$_d$}. Identical to the above subcase, but $e_1 = v_1 = \newd$, and we apply the reduction rule \textsc{E-MethCall$_d$} instead. 
\\}


\subcase{ \textsc{E-MethCall3$_\sigma$}. We also know the following:
\begin{itemize}
	\item $e_1 = v_1 = \newsig$
	\item $e_2 = v_2$
	\item $\keywadj{def~} m_i(y : \tau_2) : \type{\tau_3}{\varepsilon_3} = e_{body} \in \{ \bar \sigma \}$
	\item $v_1.m_i(v_2) \longrightarrow [v_1/x, v_2/y]e_{body}~|~\varnothing$.
\end{itemize}

}


}
	
	

\proofcase{\textsc{$\varepsilon$-OperCall}}{
	Then we know the following:
	\begin{itemize}
		\item $e_A = e_1.\pi$
		\item $\Gamma \vdash e_1 : \type{\{ r \}}{\varepsilon_1}$
		\item $\Gamma \vdash e_1.\pi : \type{\keywadj{Unit}}{\{ r.\pi \} \cup \varepsilon_1}$
	\end{itemize}
\noindent
There are two reductions which apply. \\

	\subcase{ \textsc{E-OperCall1.} Then you also know $e_1 \longrightarrow e_1'~|~\varepsilon$ and $e_1.\pi \longrightarrow e_1'.\pi~|~\varepsilon$. Applying definitions, $\hat e_A = \keywadj{label}(e_1.\pi) = (\keywadj{label}(e_1)).\pi = \hat e_1.\pi$. Applying inductive assumption, $\hat e_1 \longrightarrow \hat e_1'~|~\varepsilon$, where $\hat e_1' = \keywadj{label}(e_1')$. Because of this we may apply \textsc{E-OperCall1}, giving $\hat e_1.\pi \longrightarrow \hat e_1'.\pi$. Lastly, $\keywadj{label}(e_1'.\pi) = (\keywadj{label}(e_1')).\pi = \hat e_1'.\pi$. \\
	}
	
	\subcase{ \textsc{E-OperCall2.} Then you also know $e_1 = r$ and $r.\pi \longrightarrow \keywadj{Unit}~|~\{ r.\pi \}$. Applying definitions, $\hat e_A = \keywadj{label}(r.\pi) = (\keywadj{label}(r)).\pi = r.\pi = e_A$. The result follows immediately.\\
	}

}





\proofcase{\textsc{$\varepsilon$-MethCall}}{
	Then we know the following:
	\begin{itemize}
		\item $e_A = e_1.m_i(e_2)$
		\item $\Gamma \vdash e_1 : \type{\{ \bar \sigma \}}{\varepsilon_1}$
		\item $\Gamma \vdash e_2 : \type{\tau_2}{\varepsilon_2}$
		\item $\sigma_i = \keywadj{def}~m_i(y : \tau_2) : \type{\tau_3}{\varepsilon_3}$
		\item $\Gamma \vdash e_1.m_i(e_2) : \type{\tau_3}{\varepsilon_1 \cup \varepsilon_2 \cup \varepsilon_3}$
	\end{itemize}
\noindent
There are three reductions which apply. \\

\subcase{ \textsc{E-MethCall1} Then we also know $e_1 \longrightarrow e_1'~|~\varepsilon$ and $e_1.m(e_2) \longrightarrow e_1'.m(e_2)~|~\varepsilon$.
}

}
}





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\thm{Theorem 3.9. (Extension Theorem)}
{If $\Gamma \vdash e : \tau$ and $e \longrightarrow e'~|~\varepsilon$ and $\hat e = \keywadj{label}(\Gamma, e)$, then $\Gamma \vdash \hat e : \type{\hat \tau}{\hat \varepsilon}$, where $\tau = \hat \tau$ and $\varepsilon \subseteq \hat \varepsilon$. \\

\noindent
\fbox{Intuition.}~~~If $\Gamma$ can type $e$ without an effect, there is a way to label $e$ with a static effect set $\hat \varepsilon$ which contains the possible runtime effects of $e$ (so it is an upper-bound), and no more than what is contained in the environment $\Gamma$. (\textbf{Also, $\keywadj{effects}(\Gamma)$ is an upper bound but we omit this from the proof to keep it as simple as possible.})
\\\\}
{Proceed by induction on $\Gamma \vdash e : \tau$ and then on the reduction $e \longrightarrow e'~|~\varepsilon$.\\

\proofcase{\textsc{T-Var}, \textsc{T-Resource}, \textsc{T-New$_\sigma$}, \textsc{T-New$_d$}}{
Then $e$ is a value and no reduction can be applied to it. Theorem statement holds immediately.\\
}


\proofcase{\textsc{T-OperCall}}{
Then the following are known:
\begin{itemize}
	\item $e = e_1.\pi$
	\item $\Gamma \vdash e_1 : \{ \bar r \}$
	\item $\Gamma \vdash e_1.\pi : \keywadj{Unit}$
\end{itemize}
There are two reduction rules which could be applied to $e_1.\pi$.\\

	\subcase{\textsc{E-OperCall1}.
		Then we know $e_1.\pi \longrightarrow e_1'.\pi~|~\varepsilon$, and $e_1 \rightarrow e_1'~|~\varepsilon$. Because $\Gamma \vdash e_1 : \{ \bar r \}$ by assumption of the typing rule, we may apply the inductive assumption. Then $\Gamma \vdash \hat e_1 : \type{\{ \bar r \}}{\hat \varepsilon_1$, where $\varepsilon \subseteq \hat \varepsilon_1$ and $\hat e_1 = \keywadj{label}(\Gamma, e_1)$.\\

\noindent
By definition $\hat e = \keywadj{label}(\Gamma, e) = \keywadj{label}(\Gamma, e_1.\pi) = (\keywadj{label}(\Gamma, e_1)).\pi = \hat e_1.\pi$. We just established $\Gamma \vdash \hat e_1 : \type{\{ \bar r \}}{\hat \varepsilon}$, so fulfill the requirements of \textsc{$\varepsilon$-OperCall} and can type $\hat e = \hat e_1.\pi$ with the judgement $\Gamma \vdash \hat e_1.\pi : \type{\keywadj{Unit}}{\{ r.\pi \} \cup \hat \varepsilon_1}$. \\

\noindent
$\varepsilon \subseteq \hat \varepsilon_1$ is an inductive assumption; so $\varepsilon \subseteq \hat \varepsilon_1 \cup \{ r.\pi \} = \hat \varepsilon$. Also, $\hat \tau = \keywadj{Unit} = \tau$.\\
		}
	}
	
	\subcase{\textsc{E-OperCall2}.
		Then we know $e = r.\pi$ and $r.\pi \longrightarrow \keywadj{Unit}~|~\{ r.\pi \}$. By definition $\hat e = \keywadj{label}(\Gamma, e) = (\keywadj{label}(\Gamma, r)).\pi = r.\pi = e$, so $\hat e = e$. Then $\hat \tau = \tau$ automatically. We need only show $\varepsilon = r.\pi \in \hat \varepsilon$.\\
		
\noindent
By \textsc{$\varepsilon$-Resource}, $\Gamma \vdash r : \type{ \{ r \} }{\varnothing}$ and by \textsc{$\varepsilon$-OperCall}, $\Gamma \vdash r.\pi : \type{\keywadj{Unit}}{\{ r.\pi \}}$. Since $\hat e = r.\pi$, then $\hat \varepsilon = r.\pi = \varepsilon$.\\
	}
}

\proofcase{\textsc{T-MethCall$_\sigma$}}{
Then the following are known:
\begin{itemize}
	\item $e = e_1.m_i(e_2)$
	\item $\Gamma \vdash e_1 : \{ \bar \sigma \}$
	\item $\Gamma \vdash e_2 : \tau_2$
	\item $\Gamma \vdash e_1.m_i(e_2) : \tau_3$
	\item $\keywadj{def}~m_i(y:\tau_2) : \type{\tau_3}{\varepsilon_3} \in \{ \bar \sigma \}$
\end{itemize}
There are three reduction rules which could be applied to $e_1.m_i(e_2)$.

	\subcase{\textsc{E-OperCall1}.
	Then we know $e_1 \longrightarrow e_1'~|~\varepsilon$ and $e_1.m_i(e_2) \longrightarrow e_1'.m_i(e_2)~|~\varepsilon$. Because $\Gamma \vdash e_1 : \{ \bar \sigma \}$ by assumption of the typing rule, we may apply the inductive assumption. Then $\Gamma \vdash \hat e_1 : \type{ \{ \bar \sigma \} }{\hat \varepsilon_1}$, where $\varepsilon \subseteq \hat \varepsilon_1$ and $\hat e_1 = \keywadj{label}(\Gamma, e_1)$.\\
	
\noindent
By definition, $\hat e = \keywadj{label}(e_1.m_i(e_2)) = (\keywadj{label}(e_1)).m_i(\keywadj{label}(e_2)) = \hat e_1.m_i(\hat e_2)$. We just established $\Gamma \vdash \hat e_1 : \type{ \{ \bar \sigma \} }{\hat \varepsilon_1}$.

\noindent
If $e_2$ is a value then $\hat e_2 = \keywadj{label}(e_2) = e_2$. 

 \textbf{Can we type $\hat e_2$ though?}
	
	}
}

\proofcase{\textsc{T-MethCall$_d$}}{
Hey
}
}


\thm{Theorem 3.10. (Refinement Theorem)}
{If $\Gamma \vdash e : \tau~\keyw{with} \varepsilon$ and $\keywadj{label}(e) = \hat e$, then $\Gamma \vdash \hat e : \hat \tau~\keyw{with} \hat \varepsilon$, where $\hat \varepsilon \subseteq \varepsilon$ and $\tau = \hat \tau$.\\

\noindent
\fbox{Intuition.}~~~Labels can only make the static effects more precise; never less precise.
\\\\
}
{By induction on the judgement $\Gamma \vdash e : \type{\tau}{\varepsilon}$.\\

\proofcase{\textsc{$\varepsilon$-Resource}, \textsc{$\varepsilon$-Var}}{
	If $e$ is a resource or a variable then $e = \hat e$ so the statement is automatically fulfilled.\\
}

\proofcase{\textsc{$\varepsilon$-OperCall}} {
Then $e = e_1.\pi$ and we know:
\begin{itemize}
	\item $\Gamma \vdash e : \type{\keywadj{Unit}}{ \{ r.\pi \} \cup \varepsilon_1 }$
	\item $\Gamma \vdash e_1 : \type{ \{ \bar r \} }{\varepsilon_1}$
\end{itemize}
Applying definitions, $\hat e = \keywadj{label}(e_1.\pi) = (\keywadj{label}(e_1)).\pi = \hat e_1.\pi$. By inductive assumption, $\Gamma \vdash \hat e_1 : \type{ \{ \bar r \} }{\hat \varepsilon_1}$, where $\hat \varepsilon_1 \subseteq \varepsilon_1$. Then $\Gamma \vdash \hat e : \type{\keywadj{Unit}}{ \{ r.\pi \} \cup \hat \varepsilon_1 }$ by \textsc{$\varepsilon$-OperCall}. Importantly, $\{ r.\pi \} \cup \hat \varepsilon_1 \subseteq \{ r.\pi \} \cup \varepsilon_1$ as claimed.\\
}

\proofcase{\textsc{$\varepsilon$-MethCall}} {
Then $e = e_1.m_i(e_2)$ and we know:
\begin{itemize}
	\item $\Gamma \vdash e : \type{\tau_3}{\varepsilon_1 \cup \varepsilon_2 \cup \varepsilon_3}$
	\item $\Gamma \vdash e_1 : \{ \bar \sigma \}~\keyw{with} \varepsilon_1$
	\item $\Gamma \vdash e_2 : \type{\tau_2}{\varepsilon_2}$
	\item $\sigma_i = \keyw{def} m_i(y : \tau_2) : \tau_3~\keyw{with} \varepsilon_3$ 
\end{itemize}
Applying definitions, $\hat e = \keywadj{label}(e_1.m_i(e_2)) = (\keywadj{label}(e_1)).m_i(\keywadj{label}(e_2)) = \hat e_1.m_i(\hat e_2)$. By inductive assumption, $\Gamma \vdash \hat e_1 : \{ \bar \sigma \}~\keyw{with} \hat \varepsilon_1$ and $\Gamma \vdash \hat e_2 : \type{\tau_2}{\hat \varepsilon_2}$, where $\hat \varepsilon_1 \subseteq \varepsilon_1$ and $\hat \varepsilon_2 \subseteq \varepsilon_2$. Then $\Gamma \vdash \hat e : \tau_3~\keyw{with} \hat \varepsilon_1 \cup \hat \varepsilon_2 \cup \varepsilon_3$ under \textsc{$\varepsilon$-MethCall}. Importantly, $\hat \varepsilon_1 \cup \hat \varepsilon_2 \cup \varepsilon_3 \subseteq \varepsilon_1 \cup \varepsilon_2 \cup \varepsilon_3$ as claimed.\\
}


\proofcase{\textsc{C-MethCall}} {
Then $e = e_1.m_i(e_2)$ and we know:
\begin{itemize}
	\item $\Gamma \vdash e : \type{\tau_3}{\varepsilon_1 \cup \varepsilon_2 \cup \varepsilon_3}$
	\item $\Gamma \vdash e_1 : \{ \bar d~\keyw{captures} \varepsilon_c \}~\keyw{with} \varepsilon_1$
	\item $\Gamma \vdash e_2 : \type{\tau_2}{\varepsilon_2}$
	\item $d_i = \keyw{def} m_i(y : \tau_2) : \tau_3$ 
\end{itemize}
The reasoning is the same as the above case, but use \textsc{C-MethCall} instead of \textsc{$\varepsilon$-MethCall}.\\
}

\proofcase{\textsc{C-Inference}}{
We know:
\begin{itemize}
	\item $\Gamma' \subseteq \Gamma$
	\item $\Gamma' \vdash e : \tau$
	\item $\Gamma \vdash e : \tau~\keyw{with} \keywadj{effects}(\Gamma')$
\end{itemize}

There aren't any judgements of the form $e : \tau~\keyw{with} \varepsilon$ in the antecedent of this rule so we cannot use the induction hypothesis. We will instead do a case-by-case analysis of the form of $e$.

\subcase{$e = r$ or $e = x$.
Then $e = \hat e$ so the statement holds immediately.
}

\subcase{$e = e_1.\pi$.
Then $\hat e = (\hat e_1).\pi = \hat e_1.\pi$. As $e_1$ is a subexpression of $e$, and since $\Gamma$ can type $e_1$, we may conclude $\Gamma \vdash e_1 : \{ r \}$. By an application of \textsc{C-Inference} choosing the same $\Gamma' $, we know $\Gamma \vdash e_1 : \{ r \}~\keyw{with} \keywadj{effects}(\Gamma')$. By applying the inductive hypothesis to $e_1$ we know that $\Gamma \vdash \hat e_1 : \{ r \}~\keyw{with} \hat \varepsilon_1$, where $\hat \varepsilon_1 \subseteq \keywadj{effects}(\Gamma')$. Therefore $\Gamma \vdash \hat e_1 : \tau_1$. By an application of \textsc{T-OperCall} we know that
}

	\textbf{This one's kind of interesting. There aren't any judgements of the form $e : \tau~\keyw{with} \varepsilon$ in the antecedent of this rule, so we can't use the induction hypothesis. We also don't know anything about $e$.\\}
}
	
\proofcase{\textsc{$\varepsilon$-NewObj}}{
Then $e = \newsig$ and we know:
\begin{itemize}
	\item $\Gamma \vdash e : \type{ \{ \bar \sigma \} }{\varnothing}$
	\item $\Gamma, x : \{ \bar \sigma \} \vdash \overline{ \sigma = e }~\keyw{OK}$
\end{itemize}
For each $i$, $\sigma_i = e_i~\keywadj{OK}$ only matches \textsc{$\varepsilon$-ValidImpl$_\sigma$}. By inversion on that rule, $\Gamma, y : \tau_2 \vdash e: \tau_3~\keyw{with} \varepsilon_3$ and $\sigma_i = \keyw{def} m_i(y : \tau_2) : \tau_3~\keyw{with} \varepsilon_3$. Applying definitions, $\hat e = \keywadj{label}(\newsig) = \keywadj{new}_\sigma~x \Rightarrow \keywadj{label \hyphen helper}(\overline{\sigma = e})$. Then for each $i$, 
 $\keywadj{label \hyphen helper}(\sigma_i = e _i) = \sigma_i = \keywadj{label}(e_i)$. Let $\hat e_i = \keywadj{label}(e_i)$. Applying the inductive assumption we get $\Gamma \vdash \hat e_i : \type{\tau_3}{\hat \varepsilon_3}$. Then $\Gamma \vdash \sigma_i = \keywadj{label}(e_i)~\keywadj{OK}$ by \textsc{$\varepsilon$-ValidImpl$_\sigma$}. This was for any $i$, so $\Gamma \vdash \overline{ \sigma_i = \keywadj{label}(e_i) }~\keywadj{OK}$. Finally we can apply \textsc{$\varepsilon$-NewObj} to the labeled object $\overline{ \sigma_i = \keywadj{label}(e_i) }$, which gives the judgement $\Gamma \vdash \hat e : \{ \bar \sigma \}~\keyw{with} \varnothing$.\\
}

\proofcase{\textsc{C-NewObj}}{
Then $e = \newd$ and we know:
\begin{itemize}
	\item $\Gamma \vdash e_1.m_i(e_2) : \type{\tau_3}{\varepsilon_1 \cup \varepsilon_2 \cup \varepsilon_3}$
	\item $\Gamma' \subseteq \Gamma$
	\item $\varepsilon_c = \keywadj{effects}(\Gamma')~\keyw{with} \varnothing$
	\item $\Gamma', x : \{ \bar d~\keyw{captures} \varepsilon_c \} \vdash \overline{d = e}~\keyw{OK}$
\end{itemize}
(Similar to above). For each $i$, $d_i = e_i~\keywadj{OK}$ only matches \textsc{$\varepsilon$-ValidImpl$_d$}. By inversion on that rule, $\Gamma, y : \tau_2 \vdash e: \tau_3$ and $d_i = \keyw{def} m(y : \tau_2) : \tau_3~\keyw{with} \varepsilon_3$. Applying definitions, $\hat e = \keywadj{label}(\newsig) = \keywadj{new}_d~x \Rightarrow \keywadj{label \hyphen helper}(\overline{d = e})$. Then for each $i$, $\keywadj{label \hyphen helper}(\keywadj{def}~m(y : \tau_2) : \tau_3 = e) = \keywadj{def}~m(y : \tau_2) : \tau_3~\keyw{with}  \keywadj{effects}(\Gamma \cap \keywadj{freevars}(e_i)) = \keywadj{label}(e_i)$. Let $\hat e_i = \keywadj{label}(e_i)$. By inductive assumption, $\Gamma \vdash \hat e_i : \tau_3~\keyw{with} \hat \varepsilon_3$. This was for any $i$, so if $\sigma_i$ is the labeled version of $d_i$ then $\Gamma \vdash \overline{ \sigma_i = \keywadj{label}(e_i) }~\keywadj{OK}$. Finally we can apply \textsc{$\varepsilon$-NewObj} to the labeled object $\overline{ d_i = \keywadj{label}(e_i) }$, which gives the judgement $\Gamma \vdash \hat e : \{ \bar d \}~\keyw{with} \varnothing$.
}
}

\thm{Theorem 3.11. (Soundness Theoerm)}
{If $\Gamma \vdash e_A : \tau_A~\keyw{with} \varepsilon_A$ and $e_A \longrightarrow e_B~|~\varepsilon$ then $\Gamma \vdash e_B : \tau_B~\keyw{with} \varepsilon_B$, where $\tau_B = \tau_A$ and $\varepsilon \subseteq \varepsilon_A$.\\\\}
{Let $\hat e_A = \keywadj{label}(e_A)$. By Refinement Theorem, $\Gamma \vdash \hat e_A : \type{\hat \tau_A}{\hat \varepsilon_A}$, where $\tau_A = \hat \tau_A$ and $\hat \varepsilon_A \subseteq \varepsilon_A$. By Invariance Of Runtime Under $\keywadj{label}$, we know $\hat e_A \longrightarrow \hat e_B~|~\varepsilon$. Since $\hat e_A$ is a fully-labeled program, by Soundness of $\varepsilon$ rules, we know $\Gamma \vdash \hat e_B : \type{\hat \tau_A}{\hat \varepsilon_B}$ where $\varepsilon \subseteq \hat \varepsilon_A$. By Runtime Invariance Under $\keywadj{label}$, $\keywadj{label}(e_B) = \hat e_B$.  By Refinement Theorem, $\Gamma \vdash \hat e_B : \type{\tau_B}{\hat \varepsilon_B}$. \\

\noindent
Putting this all together we know $\tau_A = \hat \tau_A = \tau_B$ and $\varepsilon \subseteq \hat \varepsilon_A \subseteq \varepsilon_A$.
}

\end{document}











