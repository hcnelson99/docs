\documentclass{llncs}

\usepackage{listings}
\usepackage{proof}
\usepackage{amssymb}
\usepackage[margin=.9in]{geometry}
\usepackage{amsmath}
\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage{enumitem}
\usepackage{filecontents}
\usepackage{calc}
\usepackage[linewidth=0.5pt]{mdframed}
\usepackage{changepage}
\usepackage{tabto}
\allowdisplaybreaks

\usepackage{fancyhdr}
\renewcommand{\headrulewidth}{0pt}
\pagestyle{fancy}
 \fancyhf{}
\rhead{\thepage}

\lstset{tabsize=3, basicstyle=\ttfamily\small, commentstyle=\itshape\rmfamily, numbers=left, numberstyle=\tiny, language=java,moredelim=[il][\sffamily]{?},mathescape=true,showspaces=false,showstringspaces=false,columns=fullflexible,xleftmargin=5pt,escapeinside={(@}{@)}, morekeywords=[1]{objtype,module,import,let,in,fn,var,type,rec,fold,unfold,letrec,alloc,ref,application,policy,external,component,connects,to,meth,val,where,return,group,by,within,count,connect,with,attr,html,head,title,style,body,div,keyword,unit,def}}
\lstloadlanguages{Java,VBScript,XML,HTML}

\newcommand{\keywadj}[1]{\mathtt{#1}}
\newcommand{\keyw}[1]{\keywadj{#1}~}

\newcommand{\kw}[1]{\keyw{ #1 }}
\newcommand{\kwa}[1]{\keywadj{ #1 }}
\newcommand{\reftt}{\mathtt{ref}~}
\newcommand{\Reftt}{\mathtt{Ref}~}
\newcommand{\inttt}{\mathtt{int}~}
\newcommand{\Inttt}{\mathtt{Int}~}
\newcommand{\stepsto}{\leadsto}
\newcommand{\todo}[1]{\textbf{[#1]}}
\newcommand{\intuition}[1]{#1}
\newcommand{\hyphen}{\hbox{-}}

%\newcommand{\intuition}[1]{}

\newlist{pcases}{enumerate}{1}
\setlist[pcases]{
  label=\fbox{\textit{Case}}\protect\thiscase\textit{:}~,
  ref=\arabic*,
  align=left,
  labelsep=0pt,
  leftmargin=0pt,
  labelwidth=0pt,
  parsep=0pt
}
\newcommand{\pcase}[1][]{

  \if\relax\detokenize{#1}\relax
    \def\thiscase{}
  \else
    \def\thiscase{~\fbox{#1:}}
  \fi
  \item
}

\newcommand{\thm}[3]{
	\begin{large}
		\bf{#1}
	\end{large} \\\\
	\fbox{Statement.} ~ #2
	\fbox{Proof.}~ #3 \qed
}

\newcommand{\proofcase}[2]{
	\begin{adjustwidth}{1.5em}{0pt}
		\fbox{Case.}~~#1. \\ ~#2
	\end{adjustwidth}
}

\newcommand{\subcase}[1] {
	\begin{adjustwidth}{2.2em}{0pt}
		\underline{Subcase.} #1
	\end{adjustwidth}
}

\newcommand{\stmt}[1] {

\begin{adjustwidth}{2.5em}{0pt}
	#1
\end{adjustwidth}

}
\newcommand{\type}[2]{
	#1~\keyw{with} #2
}

\newcommand{\newd}[0]{
	\keywadj{new}_d~x \Rightarrow \overline{d = e}
}

\newcommand{\newsig}[0]{
	\keywadj{new}_\sigma~x \Rightarrow \overline{\sigma = e}
}


\begin{document}


\section{Grammar}

\[
\begin{array}{lll}

\begin{array}{lllr}

e & ::= & x & expressions \\
  		& | & r \\
		& | & \keywadj{new}_\sigma~x \Rightarrow \overline{\sigma = e} \\
 		& | & \keywadj{new}_d~x \Rightarrow \overline{d = e} \\
 		& | & e.m(e)\\
 		& | & e.\pi\\
		&&\\

\tau & ::= & \{ \bar \sigma \} & types \\
		& | & \{ \bar r \} \\
		& | & \{ \bar d \} \\
		& | & \{ \bar d ~\keyw{captures} \varepsilon \} \\
		&&\\
		
\sigma & ::= & d~\keyw{with}\varepsilon  & labeled~ decls.\\
		&&\\

d & ::= & \keyw{def} m(x:\tau):\tau & unlabeled~decls.\\
		&&\\

\end{array}
& ~~~~~~
&
\end{array}
\]

\noindent \textbf{Notes:}
\begin{itemize}
	\item $\sigma$ denotes a declaration with effect labels; $d$ a declaration without effect labels.
	\item $\keywadj{new}_\sigma$ is for creating annotated objects; $\keywadj{new}_d$ for unannotated objects.
	\item $\{ \bar \sigma \}$ is the type of an annotated object. $\{ \bar d \}$ is the type of an unannotated object.
	\item $\{ \bar d ~\keyw{captures} \varepsilon \}$ is a special kind of type that doesn't appear in source programs but may be assigned by the new rules in this section. Intuitively, $\varepsilon$ is an upper-bound on the effects captured by $\{ \bar d \}$.
\end{itemize}

\section{Semantics}

\subsection{Static Semantics}

\noindent
$\fbox{$\Gamma \vdash e : \tau$}$

\[
\begin{array}{c}
\infer[\textsc{(T-Var)}]
	{\Gamma,~x : \tau \vdash x : \tau}
	{}
~~~~~~~~~~
\infer[\textsc{(T-Resource)}]
	{\Gamma,~r : \{ \bar r \} \vdash r : \{ \bar r \}}
	{} \\[5ex]
~~~~~~~~~~
\infer[\textsc{(T-OperCall)}]
	{\Gamma \vdash e_1.\pi : \keywadj{Unit}}
	{\Gamma \vdash e_1 : \{ \bar r \}} \\[5ex]
~~~~~~~~~~
\infer[\textsc{(T-MethCall$_\sigma$)}]
	{\Gamma \vdash e_1.m(e_2) : \tau_3}
	{\Gamma \vdash e_1 : \{ \bar \sigma \} & \keyw{def} m(y : \tau_2) : \tau_3~\keyw{with} \varepsilon_3 \in \{ \bar \sigma \} &  \Gamma \vdash e_2 : \tau_2 }\\[5ex]
~~~~~~~~~~
\infer[\textsc{(T-MethCall$_d$)}]
	{\Gamma \vdash e_1.m(e_2) : \tau_3}
	{\Gamma \vdash e_1 : \{ \bar d\} & \keyw{def} m(y : \tau_2) : \tau_3 \in \{ \bar d \} &  \Gamma \vdash e_2 : \tau_2 }\\[5ex]
~~~~~~~~~~

~~~~~~~~~~
\infer[\textsc{(T-New$_\sigma$)}]
	{\Gamma \vdash~\keywadj{new}_\sigma~x \Rightarrow \overline{\sigma = e} : \{ \bar \sigma \}}
	{\Gamma, x : \{ \bar \sigma \} \vdash \overline{\sigma = e}~\keywadj{OK}}
~~~~~~~~~~
\infer[\textsc{(T-New$_d$)}]
	{\Gamma \vdash~\keywadj{new}_d~x \Rightarrow \overline{d = e} : \{ \bar d \}}
	{\Gamma, x : \{ \bar d \} \vdash \overline{d = e}~\keywadj{OK}}\\[5ex]
\end{array}
\]

\noindent
$\fbox{$\Gamma \vdash d = e~\keyw{OK}$}$
\[
\begin{array}{c}
\infer[\textsc{($\varepsilon$-ValidImpl$_d$)}]
	{\Gamma \vdash d = e~\keywadj{OK}}
	{d = \keyw{def} m(y : \tau_2) : \tau_3 & \Gamma, y : \tau_2 \vdash e : \tau_3}
	\\[5ex]
\end{array}
\]

\noindent
$\fbox{$\Gamma \vdash \sigma = e~\keyw{OK}$}$

\[
\begin{array}{c}
\infer[\textsc{($\varepsilon$-ValidImpl$_\sigma$)}]
	{\Gamma \vdash \sigma = e~\keywadj{OK}}
	{\Gamma,~y:\tau_2 \vdash e: \tau_3~\keyw{with} \varepsilon_3 & \sigma = \keyw{def} m(y:\tau_2):\tau_3~\keyw{with} \varepsilon_3} \\[5ex]
\end{array}
\]


\noindent
\fbox{$\Gamma \vdash e : \tau~\keyw{with} \varepsilon$}

\[
\begin{array}{c}
	\infer[\textsc{($\varepsilon$-Var)}]
  {\Gamma,~x:\tau \vdash x: \type{\tau}{\varnothing} }
  {} 
~~~~~~~~~~
\infer[\textsc{($\varepsilon$-Resource)}]
  {\Gamma,~r :\{\bar r\} \vdash r: \type{   \{ \bar r \}  }{\varnothing}}
  {} \\[5ex]

\infer[\textsc{($\varepsilon$-NewObj)}]
	{\Gamma \vdash \newsig : \{ \bar \sigma \}~\keyw{with} \varnothing}
	{\Gamma,~x : \{ \bar \sigma \} \vdash \overline{\sigma = e}~\keywadj{OK}} ~~~~~~

\infer[\textsc{($\varepsilon$-OperCall)}]
	{\Gamma \vdash e_1.\pi : \keyw{Unit} \keyw{with} \{ \bar r.\pi \} \cup \varepsilon_1}
	{\Gamma \vdash e_1 : \{ \bar r \}~ \keyw{with} \varepsilon_1} \\[5ex]
	
\infer[\textsc{($\varepsilon$-MethCall)}]
	{\Gamma \vdash e_1.m_i(e_2):\tau_3~\keyw{with} \varepsilon_1 \cup \varepsilon_2 \cup \varepsilon_3}
	{\Gamma \vdash e_1 : \{ \bar \sigma \}~\keyw{with} \varepsilon_1 & \Gamma \vdash e_2 : \tau_2~\keyw{with} \varepsilon_2 & \sigma_i = \keyw{def} m_i(y:\tau_2):\tau_3~\keyw{with} \varepsilon_3} \\[5ex]
	
\infer[\textsc{(C-NewObj)}]
	{\Gamma \vdash~\keywadj{new}_d~x \Rightarrow \overline{d = e} : \{  \bar d~\keyw{captures} \varepsilon_c \} ~\keyw{with} \varnothing }
	{\varepsilon_c = \keywadj{effects}(\Gamma') & \Gamma' \subseteq \Gamma & \Gamma', x : \{ \bar d~\keyw {captures} \varepsilon_c \} \vdash \overline{d = e}~\keyw{OK}} \\[5ex]
	
\infer[\textsc{(C-MethCall)}]
	{\Gamma \vdash e_1.m_i(e_2) : \tau_3~ \keyw{with} \varepsilon_1 \cup \varepsilon_2 \cup \keywadj{effects}(\tau_2) \cup \varepsilon_c}
	{\Gamma \vdash e_1 : \{ \bar d~\keyw{captures} \varepsilon_c \}~\keyw{with} \varepsilon_1 & \Gamma \vdash e_2:\tau_2~\keyw{with} \varepsilon_2&d_i =~\keyw{def} m_i(y:\tau_2):\tau_3 } \\[5ex]

\infer[\textsc{(C-Inference)}]
	{\Gamma \vdash e : \tau ~\keyw{with} \keywadj{effects}(\Gamma') }
	{\Gamma' \subseteq \Gamma & \Gamma' \vdash e : \tau } \\[5ex]
\end{array}
\]

\noindent \textbf{Notes:}

\begin{itemize}
	\item This system includes all the rules from the fully-annotated system.
	\item The \textsc{T} rules do standard typing of objects, without any effect analysis. Their sole purpose is so $\varepsilon$-ValidImpl$_d$ can be applied. \textbf{We are assuming the T-rules on their own are sound}.
	\item In \textsc{C-NewObj}, $\Gamma'$ is intended to be some subcontext of the current $\Gamma$. The object is labelled as capturing the effects in $\Gamma'$ (exact definition in the next section).
	\item In $\textsc{C-NewObj}$ we must add $\keywadj{effects}(\tau_2)$ to the static effects of the object, because the method body will have access to the resources captured by $\tau_2$ (the type of the argument passed into the method).
	\item A good choice of $\Gamma'$ would be $\Gamma$ restricted to the free variables in the object definition.
	\item The purpose of \textsc{C-Inference} is to ascribe static effects to unannotated portions of code (for instance, the body of an unlabeled method).
	\item As a useful convention we'll often use $\varepsilon_c$ to denote the output of the $\keywadj{effects}$ function.
\end{itemize}

\subsection{$\keywadj{effects}$ Function}

\noindent
The $\keywadj{effects}$ function returns the set of effects captured in a particular context.

\begin{itemize}
	\item $\keywadj{effects}(\varnothing) = \varnothing$
	\item $\keywadj{effects}(\Gamma, x : \tau) = \keywadj{effects}(\Gamma) \cup \keywadj{effects}(\tau)$
	\item $\keywadj{effects}(\{\bar r\}) = \{ (r, \pi) \mid r \in \bar r, \pi \in \Pi \}$
	\item $\keywadj{effects}(\{\bar \sigma\}) = \bigcup_{\sigma \in \bar \sigma}~\keywadj{effects}(\sigma)$
	\item $\keywadj{effects}(\{\bar d\}) = \bigcup_{d \in \bar d}~\keywadj{effects}(d)$
	\item $\keywadj{effects}(d~\keyw{with} \varepsilon) = \varepsilon \cup \keywadj{effects}(d)$
	\item $\keywadj{effects}(\keywadj{def~m}(x : \tau_1) : \tau_2) = \keywadj{effects}(\tau_2)$
	\item $\keywadj{effects}(\{\bar d ~\keyw{captures} \varepsilon_c\}) = \varepsilon_c$
\end{itemize}

\noindent \textbf{Notes:}
\begin{itemize}
	\item Since a method can return a capability for a resource $r$ we need to figure out what the return type of a method captures. This requires a recursive crawl through the definitions and types inside it.
	\item In the last case we don't want to recurse to sub-declarations because the effects have already been captured previously (this is $\varepsilon_c$) by a potentially different context.
\end{itemize}

\subsection{Dynamic Semantics}

~\\
\noindent
\fbox{$e \longrightarrow e~|~\varepsilon$}

\[
\begin{array}{c}

	\infer[\textsc{(E-MethCall1)}]
		{e_1.m(e_2) \longrightarrow e_1'.m(e_2)~|~\varepsilon}
		{e_1 \longrightarrow e_1'~|~\varepsilon} \\[5ex]

	\infer[\textsc{(E-MethCall2$_{\sigma}$)}]
		{v_1.m(e_2) \longrightarrow v_1.m(e_2')~|~\varepsilon}
		{v_1 = \newsig & e_2 \longrightarrow e_2'~|~\varepsilon} ~~~~~~
		
	\infer[\textsc{(E-MethCall2$_d$)}]
		{v_1.m(e_2) \longrightarrow v_1.m(e_2')~|~\varepsilon}
		{v_1 = \newd & e_2 \longrightarrow e_2'~|~\varepsilon}\\[5ex]
				
	\infer[\textsc{(E-MethCall3$_{\sigma}$)}]
		{v_1.m(v_2)
			\longrightarrow
		 [v_1/x, v_2/y]e~|~\varnothing}
  		{v_1 = \newsig & \keywadj{def~m}(y: \tau_1) : \tau_2~\keyw{with} \varepsilon = e \in \overline {\sigma = e}} \\[5ex]

	\infer[\textsc{(E-MethCall3$_d$)}]
		{v_1.m(v_2)
			\longrightarrow
		 [v_1/x, v_2/y]e~|~\varnothing}
  		{v_1 = \newd & \keywadj{def~m}(y: \tau_1) : \tau_2 = e \in \overline {d = e}} \\[5ex]

	\infer[\textsc{(E-OperCall1)}]
		{e_1.\pi
			\longrightarrow
		 e_1'.\pi~|~\varepsilon}
		{e_1 \longrightarrow e_1'~|~\varepsilon}
~~~~~~

			\infer[\textsc{(E-OperCall2)}]
		{r.\pi
			\longrightarrow
		 \keywadj{unit}~|~\{r.\pi\}}
		{} \\[5ex]
			
\end{array}
\]
\noindent
\fbox{$e \longrightarrow_* e~|~\varepsilon$}

\[
\begin{array}{c}

	\infer[\textsc{(E-MultiStep1)}]
	{e \longrightarrow_* e~|~\varnothing}
	{} ~~~~~~~~
	
	\infer[\textsc{(E-MultiStep2)}]
	{e \longrightarrow_* e'~|~\varepsilon}
	{e \longrightarrow e'~|~\varepsilon} \\[5ex]

	\infer[\textsc{(E-MultiStep3)}]
	{e \longrightarrow_* e''~|~\varepsilon_1 \cup \varepsilon_2}
	{e \longrightarrow_* e'~|~\varepsilon_1 & e' \longrightarrow_* e''~|~\varepsilon_2}

\end{array}
\]

\noindent \textbf{Notes:}
\begin{itemize}
	\item \textsc{E-MethCall2$_d$} and \textsc{E-MethCall2$_\sigma$} are really doing the same thing, but one applies to labeled objects (the $\sigma$ version) and the other on unlabeled objects. Same goes for \textsc{E-MethCall3$_\sigma$} and \textsc{E-MethCall3$_d$}.
	\item \textsc{E-MethCall1} can be used for both labeled and unlabeled objects.
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Substitution Function}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\noindent
We extend our Substitution function from the previous system in a straightforward way by adding a new case for unlabeled objects.

\begin{itemize}
	\item $[e'/z]z = e'$
	\item $[e'/z]y = y$, if $y \neq z$
	\item $[e'/z]r = r$
	\item $[e'/z](e_1.m(e_2)) = ([e'/z]e_1).m([e'/z]e_2)$
	\item $[e'/z](e_1.\pi) = ([e'/z]e_1).\pi$
	\item $[e'/z](\newd) = \keywadj{new}_d~x \Rightarrow \overline{ \sigma = [e'/z]e }$, if $z \neq x$ and $z \notin \keywadj{freevars}(e_i)$
	\item $[e'/z](\newsig) = \keywadj{new}_\sigma~x \Rightarrow \overline{ \sigma = [e'/z]e }$, if $z \neq x$ and $z \notin \keywadj{freevars}(e_i)$
\end{itemize}



\section{Proofs}
~


\thm{Lemma 3.1. (Canonical Forms)}
{Suppose $e$ is a value. The following are true:
	\begin{itemize}
	\item If $\Gamma \vdash e : \type{ \{ \bar r \} }{\varepsilon} $, then $e = r$ for some resource $r$.
	\item If $\Gamma \vdash e : \type{ \{ \bar \sigma \}}{\varepsilon}$, then $e = \newsig$.
	\item If $\Gamma \vdash e : \{ \bar d~\keyw{captures} \varepsilon_c \}~ \keyw{with} \varepsilon$, then $e = \keywadj{new}_{d}~x \Rightarrow \overline{ d = e }$.
	\end{itemize}
Furthermore, $\varepsilon = \varnothing$ in each case. \\\\
}
{ These typing judgements each appear exactly once in the conclusion of different rules. The result follows by inversion of \textsc{$\varepsilon$-Resource}, \textsc{$\varepsilon$-NewObj}, and \textsc{C-NewObj} respectively. \\
}

\thm{Lemma 3.2. (Substitution Lemma)}
{If $\Gamma, z : \tau' \vdash e : \tau~\keyw{with} \varepsilon$, and $\Gamma \vdash e' : \tau'~\keyw{with} \varepsilon'$, then $\Gamma \vdash [e'/z]e : \tau~\keyw{with} \varepsilon$. \\\\
\fbox{Intuition} If you substitute $z$ for something of the same type, the type of the whole expression stays the same after substitution.
\\\\}
{We've already proven the lemma by structural induction on the $\varepsilon$ rules. The new case is defined on a form not in the grammar for the fully-annotated system. So all that remains is to induct on derivations of $\Gamma \vdash e : \type{\tau}{\varepsilon}$ using the new $\textsc{C}$ rules.\\

	\proofcase{\textsc{C-MethCall}}{
Then $e = e_1.m(e_2)$ and $[e'/z]e = ([e'/z]e_1).m([e'/z]e_2)$ . By inductive assumption we know that $e_1$ and $[e'/z]e_1$ have the same types, and that $e_2$ and $[e'/z]e_2$ have the same types. Since $e$ and $[e'/z]e$ have the same syntactic struture, and their corresponding subexpressions have the same types, then $\Gamma$ can use \textsc{C-MethCall} to type $[e'/z]e$ the same as $e$.\\
}

	\proofcase{\textsc{C-Inference}}{
Then $\Gamma \vdash e : \tau~\keyw{with} \keywadj{effects}(\Gamma')$, where $\Gamma' \subseteq \Gamma$. By inversion $\Gamma' \vdash e : \tau$. Applying the inductive hypothesis (and our assumption that the \textsc{T} rules are sonud) $\Gamma' \vdash [e'/z]e : \tau$. Since $\Gamma' \subseteq \Gamma'$ we have $\Gamma' \vdash [e'/z]e : \tau~\keyw{with} \keyw{effects}(\Gamma')$ under \textsc{C-Inference}. Because $\Gamma' \subseteq \Gamma$ then $\Gamma \vdash [e'/z]e : \tau~\keyw{with} \keyw{effects}(\Gamma')$.\\


}

	\proofcase{\textsc{C-NewObj}}{
		Then $e = \newd$. $z$ appears in some method body $e_i$. By inversion we know $\Gamma, x : \{ \bar \sigma \} \vdash \overline {d = e}~\keywadj{OK}$. The only rule with this conclusion is \textsc{$\varepsilon$-ValidImpl$_d$}; by inversion on that we know for each $i$ that:
		 \begin{itemize}
		 	\item $d_i = \keyw{def} m_i(y : \tau_1) : \tau_2~\keyw{with} \varepsilon$
		 	\item $\Gamma, y : \tau_1 \vdash e_i : \tau_2~\keyw{with} \varepsilon$
		\end{itemize}

\noindent
If $z$ appears in the body of $e_i$ then $\Gamma, z : \tau \vdash d_i = e_i~\keywadj{OK}$ by inductive assumption. Then we can use \textsc{$\varepsilon$-ValidImpl$_d$} to conclude $\overline{d = [e'/z]e}~\keywadj{OK}$. This tells us that the types and static effects of all the methods are unchanged under substitution. By choosing the same $\Gamma' \subseteq \Gamma$ used in the original application of \textsc{C-NewObj}, we can apply \textsc{C-NewObj} to the expression after substitution. The types and static effects the methods are the same, and the same $\Gamma'$ has been chosen, so $[e'/z]e$ will be ascribed the same type as $e$.
}
}

\thm{Lemma 3.3. (Monotonicity of $\keywadj{effects}$)}
{If $\Gamma_1 \subseteq \Gamma_2$ then $\keywadj{effects}(\Gamma_1) \subseteq \keywadj{effects}(\Gamma_2)$ \\\\}
{Because $\keywadj{effects}(\Gamma_1)$ is the union of $\keywadj{effects}(\tau)$, for every $(x, \tau) \in \Gamma_1 \subseteq \Gamma_2$. Then $\keywadj{effects}(\Gamma_1) \subseteq \keywadj{effects}(\Gamma_2)$.\\\\}

\thm{Lemma 3.4. (Use Principle)}
{If $\Gamma \vdash e_A : \tau_A~\keyw{with} \varepsilon_A$, and $e_A \longrightarrow_* e_A'~|~\varepsilon$, then $\forall r.\pi \in \varepsilon \mid (r, \{ r \}) \in \Gamma$. Furthermore, $\varepsilon \subseteq \keywadj{effects}(\Gamma)$.\\\\}
{The only reduction that can add effects to $\varepsilon$ is $r.\pi$. So at some point, an expression of the form $r.\pi$ must have been evaluated. In the source program it must have had the form $e.\pi$. Since the entire program typechecked under $\Gamma$, $e$ must have been typed to $\{ r \}$ at some point. Since resources cannot be dynamically created, $(r, \{ r \}) \in \Gamma$. Since every resource with an operation called upon it is $\Gamma$, $\varepsilon \subseteq \keywadj{effects}(\Gamma)$ follows by the definition of $\keywadj{effects}$ for the case of a resource. \\

\noindent
\fbox{Intuition.} If you typecheck $e$ with $\Gamma$, if an effect can happen on $r$ when executing $e$ then $r$ must be in $\Gamma$.
\\\\}

\thm{Lemma 3.5. (Tightening Lemma)}
{If $\Gamma \vdash e : \type{\tau}{\varepsilon}$ then $\Gamma \cap \keywadj{freevars}(e) \vdash e : \type{\tau}{\varepsilon}$. \\\\
}{The typing judgements operate on the form of $e$, so don't consider any variables external to $e$.\\
}

\noindent
\fbox{Note.} We'll use $\keywadj{freevars}(e) \cap \Gamma$ to mean $\Gamma$, where the pair $(x,\tau)$ is thrown out if $x \notin \keywadj{freevars}(e)$. \\

\noindent
\fbox{Intuition.} If you can typecheck $e$ in $\Gamma$, you can throw out the parts in $\Gamma$ not relevant to $e$ and still typecheck it.\\\\

\begin{large}
\bf{Definition 3.6. ($\keywadj{label}$)}
\end{large}

Given a program containing unlabeled parts we can safely label those parts. This process is well-defined if $\Gamma \vdash e:  \tau$; then we say the labeling of $e$ is $\keywadj{label}(\Gamma, e) = \hat e$.

\begin{itemize}
	\item $\keywadj{label}(r, \Gamma)$ = r
	\item $\keywadj{label}(x, \Gamma)$ = x
	\item $\keywadj{label}(e_1.m(e_2), \Gamma) = \keywadj{label}(e_1, \Gamma).m(\keywadj{label}(e_2), \Gamma)$
	\item $\keywadj{label}(e_1.\pi(e_2), \Gamma) = \keywadj{label}(e_1, \Gamma).\pi(\keywadj{label}(e_2), \Gamma)$
	\item $\keywadj{label}(\keyw{new_\sigma} x \Rightarrow \overline{\sigma = e}, \Gamma) = \keywadj{new}_\sigma~x \Rightarrow \keywadj{label \hyphen helper}(\overline{\sigma = e}, \Gamma)$
	\item $\keywadj{label}(\keyw{new_d} x \Rightarrow \overline{d = e}, \Gamma) = \keyw{new_\sigma} x \Rightarrow \keywadj{label \hyphen helper}(\overline{d = e}, \Gamma)$
	\item $\keywadj{label \hyphen helper}(\sigma = e, \Gamma) = \sigma = \keywadj{label}(e, \Gamma)$
	\item $\keywadj{label \hyphen helper}(\keywadj{def}~m(y : \tau_2) : \tau_3 = e, \Gamma) = \keywadj{def}~m(y : \tau_2) : \tau_3~\keyw{with} \keywadj{effects}(\Gamma \cap \keywadj{freevars}(e)) = \keywadj{label}(e, \Gamma)$
\end{itemize}

\noindent \textbf{Notes:}
\begin{itemize}
\item $\Gamma \cap \keywadj{freevars}(e)$ is the set of pairs $x : \tau \in \Gamma$, such that $x \in \keywadj{freevars}(e)$.
\item $\keywadj{label}(e, \Gamma)$ is read as: ``the labeling of $e$ in $\Gamma$''.
\item Often the $\Gamma$ we use is obvious in context; in such cases we write $\kwa{label}(e)$ instead of $\kwa{label}(e, \Gamma)$.
\item Beware of confusing notation: there are two types of equality in the above definitions. One is the equality which defines $\keywadj{label}$, and the other is the equality $\sigma = e$ of declarations in the programming language.
\item The program after labeling will be fully-labeled, so typing it will be sound under the $\varepsilon$ rules.
\item $\keywadj{label}$ is defined on expressions; $\keywadj{label \hyphen helper}$ on declarations. Everywhere other than this section we'll only use $\keywadj{label}$.
\item Initially it seems like $\keywadj{label}$ on a $\keywadj{new_\sigma}$ object should just be the identity function; but the body of the methods of such an object may instantiate unlabeled objects and/or call methods on unlabeled objects, so we must recursively label those.
\item We may sometimes say $\keywadj{labels}(e) = \hat e$, and from then on refer to the labeled version of $e$ as $\hat e$. We'll use $\hat \tau$ and $\hat \varepsilon$ to refer to the type and static effects of the labeled version.\\
\end{itemize}






\noindent
\thm{Observations 3.7.}
{The following are true.
\begin{itemize}
	\item $\keywadj{label}(e)$ is a value if and only if $e$ is a value.
	\item If $e$ has type $\{ \bar \sigma \}$, then for any method $m_i \in \{ \bar \sigma \}$ with a label $\varepsilon_i$, the exact same method and label will occur in $\hat e$.
\end{itemize}}
{By inspection of the definition of $\keywadj{label}$.\\\\}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\noindent
\thm{Property 3.8. (Commutativity Between $\kwa{label}$ and $\kwa{sub}$)}
{Fix $\Gamma$ and define $\kwa{label}(e) = \kwa{label}(e, \Gamma)$. Then $\kwa{label}([e'/z]e) = [\kwa{label}(e')/z](\kwa{label}(e))$\\

\noindent
\fbox{Intuition.} ~~If perform substitution and labeling on an expression, the order in which you do things doesn't matter.\\\\}
{Induction on the form of $e$. In each case,``left-hand side'' refers to $\kwa{label}([e'/z]e)$ while ``right-hand side'' refers to $[\kwa{label}(e')/z](\kwa{label}(e))$.\\

\proofcase{$e = r$}{
By definition, $\kwa{label}(r) = r$ and $[e'/z]r = r$, for any $e'$. Both sides are equivalent to $r$ because $\kwa{sub}$ and $\kwa{label}$ act like the identity function.\\
}

\proofcase{$e = x$}{
By definition, $\kwa{label}(x) = x$. $[e'/z]x$ has two definitions, depending on if $x = z$; consider each case.\\

\subcase{ $x \neq z$. Then $[e'/z]x = x$. Both sides are equivalent to $x$ because $\kwa{sub}$ and $\kwa{label}$ act like the identity function.\\}

\subcase{ $x = z$. Then $[e'/z]x = z$. On the left-hand side, $\keywadj{label}([e'/z]x) = \keywadj{label}(e')$. On the right-hand side, $[\keywadj{label}(e')/z]x = \keywadj{label}(e')$.\\
}
}

\proofcase{$e = e_1.\pi$}{
\noindent
On the left-hand side.
\begin{adjustwidth}{1.5em}{0em}
$\kwa{label}([e'/z](e_1.\pi))$\\
$= \kwa{label}( ([e'/z]e_1).\pi )$
\tabto{15em} (definition of $\kwa{sub}$)\\
$= (\kwa{label}([e'/z]e_1)).\pi$
\tabto{15em} (definition of $\kwa{label}$)\\
$= ( [\kwa{label}(e')/z] (\kwa{label}(e_1)) ).\pi$
\tabto{15em} (inductive assumption on $e_1$)\\
\end{adjustwidth}
On the right-hand side.
\begin{adjustwidth}{1.5em}{0em}
$[\kwa{label}(e')/z](\kwa{label}(e_1.\pi))$ \\
$= [\kwa{label}(e')/z](\kwa{label}(e_1).\pi)$
\tabto{15em} (definition of $\kwa{label}$)\\
$= ([\kwa{label}(e')/z](\kwa{label}(e_1))).\pi$
\tabto{15em} (definition of $\kwa{sub}$)\\
\end{adjustwidth}
}

\proofcase{$e = e_1.m(e_2)$}{
On the left-hand side.
\begin{adjustwidth}{1.5em}{0em}
$\kwa{label}([e'/z](e_1.m(e_2)))$ \\
$= \kwa{label}(([e'/z]e_1).m([e'/z]e_2)) $
\tabto{26em} (definition of $\kwa{sub}$)\\
$= (\kwa{label}([e'/z]e_1)).m(\kwa{label}([e'/z]e_2))$
\tabto{26em} (definition of $\kwa{label}$)\\
$= ([\kwa{label}(e')/z](\kwa{label}(e_1)).m(\kwa{label}([e'/z]e_2))$
\tabto{26em} (inductive assumption on $e_1$) \\
$= ([\kwa{label}(e')/z](\kwa{label}(e_1)).m([\kwa{label}(e')/z](\kwa{label}(e_2)))$
\tabto{26em} (inductive assumption on $e_2$) \\
\end{adjustwidth}

\noindent
On the right-hand side.
\begin{adjustwidth}{1.5em}{0em}
$[\kwa{label}(e')/z](\kwa{label}(e_1.m(e_2)))$ \\
$= [\kwa{label}(e')/z]((\kwa{label}(e_1)).m(\kwa{label}(e_2)))$
\tabto{28em} (definition of $\kwa{label}$)\\
$= ( [\kwa{label}(e')/z](\kwa{label}(e_1)) ).m( [\kwa{label}(e')/z](\kwa{label}(e_2)) )$
\tabto{28em} (definition of $\kwa{sub}$)
\end{adjustwidth}~
}

\proofcase{$e = \newsig$}{
On the left-hand side.
\begin{adjustwidth}{1.5em}{0em}
$\kwa{label}([e'/z](\kwa{new}_\sigma~x \Rightarrow \overline{\sigma_i = e_i})$ \\
$=\kwa{label}(\kwa{new}_\sigma~x \Rightarrow \overline{\sigma_i = [e'/z]e_i})$
\tabto{20em} (definition of $\kwa{sub}$) \\
$= \kwa{new}_\sigma~x \Rightarrow \kwa{label \hyphen helper}(\overline{\sigma_i = [e'/z]e_i)}$
\tabto{20em} (definition of $\kwa{label}$) \\
$= \kwa{new}_\sigma~x \Rightarrow \overline{\sigma_i = \kwa{label}([e'/z]e_i)}$
\tabto{20em} (definition of $\kwa{label \hyphen helper}$ on each $\sigma_i = [e'/z]e_i$) \\
\end{adjustwidth}

\noindent
On the right-hand side.
\begin{adjustwidth}{1.5em}{0em}
$[\kwa{label}(e')/z](\kwa{label}(\kwa{new}_\sigma~x \Rightarrow \overline{\sigma_i = e_i}))$ \\
$= [\kwa{label}(e')/z](\kwa{new}_\sigma~x \Rightarrow \kwa{label \hyphen helper}(\overline{\sigma_i = e_i}))$
\tabto{24em} (definition of $\kwa{label}$) \\
$= [\kwa{label}(e')/z](\kwa{new}_\sigma~x \Rightarrow \overline{\sigma_i = \kwa{label}(e_i)})$
\tabto{24em} (definition of $\kwa{label \hyphen helper}$ on each $\sigma_i = e_i$) \\
$= \kwa{new}_\sigma~x \Rightarrow \overline{\sigma_i = [\kwa{label}(e')/z](\kwa{label}(e_i)}$
\tabto{24em} (definition of $\kwa{sub}$) \\
$= \kwa{new}_\sigma~x \Rightarrow \overline{\sigma_i = \kwa{label}([e'/z]e_i)}$
\tabto{24em} (inductive assumption on each $e_i$)
\end{adjustwidth}~
}

\proofcase{$e = \newd$}{
The proof of this is quite similar to previous case for labeled objects. The main difference is that when labeling an unlabeled object, each $d_i = e_i$ turns into a $\sigma_i = e_i$. For clarity we will define $\varepsilon_i = \kwa{effects}(\Gamma \cap \kwa{freevars}(e_i))$, and $\sigma_i = d_i~\kw{with} \varepsilon_i$ (these are from the definition of $\kwa{label \hyphen helper}$).\\

\noindent
On the left-hand side.
\begin{adjustwidth}{1.5em}{0em}
$\kwa{label}([e'/z](\kwa{new}_d~x \Rightarrow \overline{d_i = e_i}))$ \\
$= \kwa{label}( \kwa{new}_d~x \Rightarrow \overline{d_i = [e'/z]e_i} )$
\tabto{24em} (definition of $\kwa{sub}$) \\
$= \kwa{new}_d~x \Rightarrow \kwa{label \hyphen helper}(\overline{d_i = [e'/z]e_i})$
\tabto{24em} (definition of $\kwa{label}$) \\
$= \kwa{new}_d~x \Rightarrow \overline{d_i~\kw{with} \varepsilon_i = \kwa{label}([e'/z]e_i)}$
\tabto{24em} (definition of $\kwa{label \hyphen helper}$) \\
$= \kwa{new}_d~x \Rightarrow \overline{\sigma_i = \kwa{label}([e'/z]e_i)}$
\tabto{24em} ($\sigma_i = d_i~\kw{with} \varepsilon_i$) 


\end{adjustwidth}~

\noindent
On the right-hand side.
\begin{adjustwidth}{1.5em}{0em}
$[\kwa{label}(e')/z](\kwa{label}(\kwa{new}_d~x \Rightarrow \overline{d_i = e_i}))$ \\
$= [\kwa{label}(e')/z](\kwa{new}_d~x \Rightarrow \kwa{label \hyphen helper}(\overline{d_i = e_i}))$
\tabto{24em} (definition of $\kwa{label}$) \\
$= [\kwa{label}(e')/z](\kwa{new}_\sigma~x \Rightarrow \overline{d_i~\kw{with} \varepsilon_i = \kwa{label}(e_i)})$
\tabto{24em} (definition of $\kwa{label \hyphen helper}$ on each $d_i = e_i$) \\
$= [\kwa{label}(e')/z](\kwa{new}_\sigma~x \Rightarrow \overline{\sigma_i = \kwa{label}(e_i)})$
\tabto{24em} ($\sigma_i = d_i~\kw{with} \varepsilon_i$) \\
$= \kwa{new}_\sigma~x \Rightarrow \overline{\sigma_i = [\kwa{label}(e')/z](\kwa{label}(e_i)})$
\tabto{24em} (definition of $\kwa{sub}$) \\
$= \kwa{new}_\sigma~x \Rightarrow \overline{\sigma_i = \kwa{label}([e'/z]e_i)}$
\tabto{24em} (inductive assumption on each $e_i$)
\end{adjustwidth}~
}
}

\noindent
\thm{Lemma 3.9. (Runtime Invariance Under $\keywadj{label}$)}
{If the following are true:
	\begin{itemize}
	\item $\Gamma \vdash e_A : \type{\tau_A}{\varepsilon_A}$
	\item $e_A \longrightarrow e_B~|~\varepsilon$
	\item $\hat e_A = \keywadj{label}(e_A, \Gamma)$
	\end{itemize}
Then $\hat e_A \longrightarrow \hat e_B~|~\varepsilon$ and $\hat e_B = \keywadj{label}(e_B, \Gamma)$.\\\\
}
{Induct on the form of $e_A$ and then on the reduction rule $e_A \longrightarrow e_B~|~\varepsilon$. Throughout this proof there is only a single context $\Gamma$, so we'll write $\keywadj{label}(e)$ instead of $\keywadj{label}(e, \Gamma)$ as a notational short-hand.\\

\proofcase{$e=r$, $e=x$, $e=\newsig$, $e=\newd$}{
	Then $e$ is a value and the theorem statement holds automatically.\\
}

\proofcase{$e=e_1.\pi$}{
The only typing rule which applies is \textsc{$\varepsilon$-OperCall}, which tells us:
	\begin{itemize}
		\item $\Gamma \vdash e_1 : \type{ \{ r \} }{\varepsilon_1}$
		\item $\Gamma \vdash e_1.\pi : \type{\keywadj{Unit}}{\varepsilon_1 \cup \{ r.\pi \}}$
	\end{itemize}
\noindent
There are two possible reductions. \\

\subcase{\textsc{E-OperCall1}. We also know $e_1 \longrightarrow e_1'~|~\varepsilon$, and $e_1.\pi \longrightarrow e_1'.\pi~|~\varepsilon$. By inductive assumption, $\hat e_1 \longrightarrow \hat e_1'~|~\varepsilon$, and $\hat e_1' = \keywadj{label}(e_1')$. Applying definitions, $\hat e_A = \keywadj{label}(e_1.\pi) = (\keywadj{label}(e_1)).\pi = \hat e_1.\pi$. Because $\hat e_1 \longrightarrow \hat e_1'~|~\varepsilon$, we may apply the reduction \textsc{E-OperCall1} to obtain $\hat e_1.\pi \longrightarrow \hat e_1'.\pi~|~\varepsilon$. Lastly, $\hat e_B = \keywadj{label}(e_1'.\pi) = (\keywadj{label}(e_1')).\pi$, which we know to be $\hat e_1'.\pi$ by inductive assumption.\\
}

\subcase{\textsc{E-OperCall2}. We also know $e_1 = r$ and $r.\pi \longrightarrow \keywadj{Unit}~|~\{ r.\pi \}$. Applying definitions, $\hat e_A = \keywadj{label}(r.\pi) = (\keywadj{label}(r)).\pi = r.\pi = e_A$. The theorem holds immediately.\\

}
}
	
\proofcase{$e=e_1.m_i(e_2)$}{
\noindent
There are five possible reductions. \\

\subcase{ \textsc{E-MethCall1}. We also know $e_1 \longrightarrow e_1'~|~\varepsilon$ and $e_1.m_i(e_2) \longrightarrow e_1'.m_i(e_2)~|~\varepsilon$. By inductive assumption, $\hat e_1 \longrightarrow \hat e_1'~|~\varepsilon$, and $\keywadj{label}(e_1') = \hat e_1'$. Applying definitions $\hat e_A = \keywadj{label}(e_1.m_i(e_2)) = (\keywadj{label}(e_1)).m_i(\keywadj{label}(e_2)) = \hat e_1.m_i(\hat e_2)$. Because $\hat e_1 \longrightarrow \hat e_1'~|~\varepsilon$, we may apply the reduction \textsc{E-MethCall1} to obtain $\hat e_1.m_i(\hat e_2) \longrightarrow \hat e_1'.m_i(\hat e_2)~|~\varepsilon$. Lastly, $\hat e_B = \keywadj{label}(e_1'.m_i(\hat e_2)) = (\keywadj{label}(e_1')).m_i(\keywadj{label}(e_2))$, which we know to be $\hat e_1'.m_i(\hat e_2) = \hat e_B$ by assumptions.\\

}

\subcase{ \textsc{E-MethCall2$_\sigma$}. We also know $e_1 = v_1 = \newsig$, and $e_2 \longrightarrow e_2'~|~\varepsilon$ and $v_1.m_i(e_2) \longrightarrow v_1.m_i(e_2')~|~\varepsilon$. By inductive assumption, $\hat e_2 \longrightarrow \hat e_2'~|~\varepsilon$, and $\keywadj{label}(e_2') = \hat e_2'$. Applying definitions, $\hat e_A = \keywadj{label}(v_1.m_i(e_2)) = (\keywadj{label}(v_1)).m_i(\keywadj{label}(e_2)) = \hat v_1.m_i(\hat e_2)$. Because $\hat e_2 \longrightarrow \hat e_2'~|~\varepsilon$, we may apply the reduction \textsc{E-MethCall$_\sigma$} to obtain $\hat v_1.m_i(\hat e_2) \longrightarrow \hat v_1.m_i(\hat e_2')$. Lastly, $\hat e_B = \keywadj{label}(v_1.m_i(e_2')) = (\keywadj{label}(v_1)).m_i(\keywadj{label}(e_2'))$, which we know to be $\hat v_1.m_i(\hat e_2')$ by assumptions. \\
}

\subcase{ \textsc{E-MethCall2$_d$}. Identical to the above subcase, but $e_1 = v_1 = \newd$, and we apply the reduction rule \textsc{E-MethCall$_d$} instead. 
\\}


\subcase{ \textsc{E-MethCall3$_\sigma$}. We also know the following:
\begin{itemize}
	\item $e_1 = v_1 = \newsig$
	\item $e_2 = v_2$
	\item $\keywadj{def~} m_i(y : \tau_2) : \type{\tau_3}{\varepsilon_3} = e_{body} \in \{ \bar \sigma \}$
	\item $v_1.m_i(v_2) \longrightarrow [v_1/x, v_2/y]e_{body}~|~\varnothing$.
\end{itemize}
\noindent
Applying definitions, $\keywadj{label}(v_1.m_i(v_2)) = (\keywadj{label}(v_1)).m_i(\keywadj{label}(v_2)) = \hat v_1.m_i(\hat v_2)$, where we define $\hat v_1 = \kwa{label}(v_1)$ and $\hat v_2 = \kwa{label}(v_2)$. Before labeling, the object $v_1$ has method $m_i$ with body $e_{body}$. The labeled version, $\hat v_1$, has method $m_i$ with body $\keywadj{label}(e_{body}) = \hat e_{body}$. Because $v_1$ and $v_2$ are values, so are $\hat v_1$ and $\hat v_2$. Therefore we can apply \textsc{E-MethCall3$_\sigma$} to $\hat v_1.m_i(\hat v_2)$, giving us $\hat v_1.m_i(\hat v_2) \longrightarrow [\hat v_1 / x, \hat v_2 / y]\hat e_{body}~|~\varnothing$. Because $\keywadj{label}$ and $\keywadj{sub}$ commute, $\keywadj{label}(e_B) = \keywadj{label}([v_1/x, v_2/y]e_{body}) = [\keywadj{label}(v_1)/x, \keywadj{label}(v_2)/y](\keywadj{label}(e_{body})))$, which is $[\hat v_1/x, \hat v_2/y] \hat e_{body} = \hat e_B$, by how we defined $\hat v_1$, $\hat v_2$, and $\hat e_{body}$.\\
}


\subcase{ \textsc{E-MethCall3$_d$}.
This case is identical to the previous one, except $e_1 = v_1 = \newd$. The same reasoning applies though.
}

}
}





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\thm{Theorem 3.10. (Extension Lemma)}
{If $\Gamma \vdash e : \{ \bar d \}$ and $e$ is closed under $\Gamma$ then $\Gamma \vdash \kwa{label}(e) : \{ \bar \sigma \}$, where $\sigma_i = d_i~\kw{with} \kwa{effects}(\Gamma) \cap e_i$.\\\\}
{By closure, $m_i$ has some method body $e_i$. \\\\}



\thm{Theorem 3.11. (Extension Theorem)}
{If $\Gamma\vdash e : \tau$ and $\hat e = \kwa{label}(e, \Gamma)$ then one of the following is true:
\begin{itemize}
	\item $e$ is a value, and $\Gamma \vdash \hat e : \type{\hat \tau}{\hat \varepsilon}$, where $\tau = \hat \tau$ and $\hat \varepsilon = \varnothing$.
	\item $e$ is an expression, and $e \longrightarrow e'~|~\varepsilon$, and $\Gamma \vdash \hat e : \type{\hat \tau}{\hat \varepsilon}$, where $\hat \tau = \tau$ and $\varepsilon \subseteq \hat \varepsilon$.
\end{itemize}

\noindent
\fbox{Intuition.}~~~If $\Gamma$ can type $e$ without an effect, there is a way to label $e$ with $\hat \varepsilon$ which contains the possible runtime effects of $e$ (so $\hat \varepsilon$ is an upper-bound). (\textbf{Also, $\keywadj{effects}(\Gamma)$ is an upper bound on $\hat \varepsilon$ but we omit this from the proof (for now) to keep it simple.})
\\\\}
{Throughout this proof there is only one $\Gamma$, so we say $\kwa{label}(e)$ as short-hand for $\kwa{label}(e, \Gamma)$. Proceed by induction on $\Gamma \vdash e : \tau$ and then on the reduction $e \longrightarrow e'~|~\varepsilon$.\\

\proofcase{\textsc{T-Var}}{
$e = x$ is a value, and $\kwa{label}(x) = x$. By assumption that the program is closed under $\Gamma$, we can apply \textsc{$\varepsilon$-Var} to conclude $\Gamma \vdash x : \type{\tau}{\varnothing}$ .\\
}

\proofcase{\textsc{T-Resource}}{
$e = r$ is a value, and $\kwa{label}(r) = r$. By assumption that the program is closed under $\Gamma$, we can apply \textsc{$\varepsilon$-Resource} to conclude $\Gamma \vdash r : \type{\{ r \}}{\varnothing}$.\\
}


\proofcase{\textsc{T-New$_\sigma$}}{
We also know $e = \newsig$ and $\Gamma \vdash \sigma_i = e_i~\kw{OK}$. By applying the definition of $\kwa{label}$, define $\hat e = \kwa{label}(\newsig) = \kwa{new}_\sigma~x \Rightarrow \overline{\sigma = \kwa{label}(e)}$. To type $\hat e$ we want to use \textsc{$\varepsilon$-NewObj}; to do that we need to know $\Gamma, x : \{ \bar \sigma \} \vdash \overline{ \sigma = \kwa{label}(e) }~\kwa{OK}$.\\

\noindent
Fix some $i$. By assumption, $\Gamma \vdash \sigma_i = e_i~\kw{OK}$. By inversion on \textsc{$\varepsilon$-ValidImpl$_\sigma$}, we know $\Gamma, y : \tau_2 \vdash e_i : \type{\tau_3}{\varepsilon_3}$. Consider $\hat e_i = \kwa{label}(e_i)$. By inductive assumption, $\Gamma, y : \tau_2 \vdash \hat e_i : \type{\tau_3}{\hat \varepsilon}$, and by application of \textsc{$\varepsilon$-ValidImpl$_\sigma$} we know $\Gamma \vdash \sigma_i = \kwa{label}(e_i)~\kwa{OK}$. (\textbf{We're applying inductive assumption to something of the form $\Gamma \vdash e : \type{\tau}{\varepsilon}$, not $\Gamma \vdash e : \tau$ though.)}\\

\noindent
$i$ was arbitrary; therefore $\Gamma \vdash \overline{\sigma = \kwa{label}(e)}~\kw{OK}$. Therefore $\Gamma \vdash \hat e : \{ \bar \sigma \}~\kw{with} \varnothing$ by \textsc{$\varepsilon$-NewObj$_\sigma$}.\\
}


\proofcase{\textsc{T-New$_d$}}{
We also know $e = \newd$ and $\Gamma, \{ \bar d \} \vdash d_i = e_i~\kwa{OK}$. To simplify things, let $\varepsilon_i = \kwa{freevars}(\Gamma) \cap e_i$ (this definition comes from the definition of $\kwa{label \hyphen helper}$) and define $\hat e$ in the following way:

\begin{adjustwidth}{1.5em}{0em}
$\kwa{label}(e)$ \\
$= \kwa{label}(\newd)$
\tabto{18em} (definition of $e$) \\
$= \kwa{new}_\sigma x \Rightarrow \kwa{label \hyphen helper}(\overline{d_i = e_i})$
\tabto{18em} (definition of $\kwa{label}$) \\
$= \kwa{new}_\sigma x \Rightarrow \overline{d_i~\kw{with} \varepsilon_i = e_i}$ 
\tabto{18em} (definition of $\kwa{label \hyphen helper}$) \\
$= \kwa{new}_\sigma x \Rightarrow \overline{\sigma_i = e_i}$
\tabto{18em} (defining $\sigma = d_i~\kw{with} \varepsilon_i$)
\end{adjustwidth}

\noindent
To type $\hat e$ we want to use \textsc{$\varepsilon$-NewObj}; to do that we need to know $\Gamma, x : \{ \sigma \} \vdash \overline{\sigma_i = e_i}~\kwa{OK}$, so fix some $i$. By assumption $\Gamma \vdash d_i = e_i~\kwa{OK}$. By inversion on \textsc{$\varepsilon$-ValidImpl$_d$} we know $\Gamma, y : \tau_2 \vdash e_i : \tau_3$. By inductive assumption on this, $\Gamma, y : \tau_2 \vdash \hat e_i : \tau_3~\kwa{with} \hat \varepsilon$. \\

\noindent
Fix some $i$. By assumption $\Gamma, \{ \bar d \} \vdash \overline{d_i = e_i}~\kwa{OK}$. By inversion on \textsc{$\varepsilon$-ValidImpl$_d$}, we know $\Gamma, \{ \bar d \}, y : \tau_2 \vdash e_i : \tau_3$. By inductive assumption, $\Gamma, \{ \bar d \}, y : \tau_2 \vdash \hat e_i : \tau_3~\kw{with} \hat \varepsilon$, and by an application of \textsc{$\varepsilon$-ValidImpl$_\sigma$} we know $\Gamma \vdash \sigma_i = \kwa{label}(e_i)~\kwa{OK}$. \\

\noindent
$i$ was arbitrary; therefore $\Gamma \vdash \overline{\sigma = \kwa{label}(e)}~\kwa{OK}$. Therefore $\Gamma \vdash \hat e : \{ \bar \sigma \}~\kw{with} \varnothing$ by \textsc{$\varepsilon$-NewObj}.\\

}


\proofcase{\textsc{T-OperCall}}{
Then the following are known:
\begin{itemize}
	\item $e = e_1.\pi$
	\item $\Gamma \vdash e_1 : \{ \bar r \}$
	\item $\Gamma \vdash e_1.\pi : \keywadj{Unit}$
\end{itemize}
There are two reduction rules which could be applied to $e_1.\pi$.\\

	\subcase{\textsc{E-OperCall1}.
		Then we know $e_1.\pi \longrightarrow e_1'.\pi~|~\varepsilon$, and $e_1 \rightarrow e_1'~|~\varepsilon$. Because $\Gamma \vdash e_1 : \{ \bar r \}$ by assumption of the typing rule, we may apply the inductive assumption. Then $\Gamma \vdash \hat e_1 : \type{\{ \bar r \}}{\hat \varepsilon_1$, where $\varepsilon \subseteq \hat \varepsilon_1$ and $\hat e_1 = \keywadj{label}(e_1)$.\\

\noindent
By definition $\hat e = \keywadj{label}(\Gamma, e) = \keywadj{label}(\Gamma, e_1.\pi) = (\keywadj{label}(\Gamma, e_1)).\pi = \hat e_1.\pi$. Because $\Gamma \vdash \hat e_1 : \type{\{ \bar r \}}{\hat \varepsilon}$ we can aply \textsc{$\varepsilon$-OperCall} and type $\hat e = \hat e_1.\pi$ with the judgement $\Gamma \vdash \hat e_1.\pi : \type{\keywadj{Unit}}{\{ r.\pi \} \cup \hat \varepsilon_1}$. \\

\noindent
$\varepsilon \subseteq \hat \varepsilon_1$ is an inductive assumption; so $\varepsilon \subseteq \hat \varepsilon_1 \cup \{ r.\pi \} = \hat \varepsilon$. Also, $\hat \tau = \keywadj{Unit} = \tau$.\\
		}
	}
	
	\subcase{\textsc{E-OperCall2}.
		Then we know $e = r.\pi$ and $r.\pi \longrightarrow \keywadj{Unit}~|~\{ r.\pi \}$. By definition $\hat e = \keywadj{label}(\Gamma, e) = (\keywadj{label}(\Gamma, r)).\pi = r.\pi = e$, so $\hat e = e$. Then $\hat \tau = \tau$ automatically. We need only show $\varepsilon = r.\pi \in \hat \varepsilon$.\\
		
\noindent
By \textsc{$\varepsilon$-Resource}, $\Gamma \vdash r : \type{ \{ r \} }{\varnothing}$ and by \textsc{$\varepsilon$-OperCall}, $\Gamma \vdash r.\pi : \type{\keywadj{Unit}}{\{ r.\pi \}}$. Since $\hat e = r.\pi$, then $\hat \varepsilon = r.\pi = \varepsilon$.\\
	}
}

\proofcase{\textsc{T-MethCall$_\sigma$}}{
Then the following are known:
\begin{itemize}
	\item $e = e_1.m_i(e_2)$
	\item $\Gamma \vdash e_1 : \{ \bar \sigma \}$
	\item $\Gamma \vdash e_2 : \tau_2$
	\item $\Gamma \vdash e_1.m_i(e_2) : \tau_3$
	\item $\keywadj{def}~m_i(y:\tau_2) : \type{\tau_3}{\varepsilon_3} \in \{ \bar \sigma \}$
\end{itemize}
There are three reduction rules which could be applied to a method call $e_1.m_i(e_2)$ on a labeled object.\\

	\subcase{\textsc{E-MethCall1}.				
	Then we know $e_1 \longrightarrow e_1'~|~\varepsilon$ and $e_1.m_i(e_2) \longrightarrow e_1'.m_i(e_2)~|~\varepsilon$.	 By definition, $\hat e = \keywadj{label}(e_1.m_i(e_2)) = (\keywadj{label}(e_1)).m_i(\keywadj{label}(e_2)) = \hat e_1.m_i(\hat e_2)$. Method $m_i$ has the same label $\varepsilon_3$ in $\hat e$ as it does in $e$. \\
	
	\noindent
	Because $\Gamma \vdash e_1 : \{ \bar \sigma \}$ and $\Gamma \vdash e_2 : \tau_2$, by applying the inductive assumption to each we learn $\Gamma \vdash \hat e_1 : \{ \bar \sigma \}~\kw{with} \hat \varepsilon_1$ and $\Gamma \vdash \hat e_2 : \tau_2~\kw{with} \hat \varepsilon_2$, where $\varepsilon \subseteq \hat \varepsilon_1$.\\
	
	\noindent
  Putting this all together and using \textsc{$\varepsilon$-MethCall} we learn $\Gamma \vdash \hat e_1.m_i(\hat e_2) : \type{\tau_3}{\hat \varepsilon_1 \cup \hat \varepsilon_2 \cup \varepsilon_3}$, and since $\varepsilon \subseteq \hat \varepsilon_1$ this type contains the run-time effects.\\
	}
	
	\subcase{\textsc{E-MethCall2$_\sigma$}.
	Then we know $e_1 = v_1 = \newsig$ and $e_2 \longrightarrow e_2'~|~\varepsilon$ and $e_1.m_i(e_2) \longrightarrow e_1'.m_i(e_2)~|~\varepsilon$. By definition, $\hat e = \keywadj{label}(e_1.m_i(e_2)) = (\keywadj{label}(e_1)).m_i(\keywadj{label}(e_2)) = \hat e_1.m_i(\hat e_2)$. Method $m_i$ has the same label $\varepsilon_3$ in $\hat e$ as it does in $e$. \\
	
	\noindent
	Because $\Gamma \vdash v_1 : \{ \bar \sigma \}$ and $\Gamma \vdash e_2 : \tau_2$, by applying the inductive assumption to each we learn $\Gamma \vdash \hat e_1 : \{ \bar \sigma \}~\kw{with} \hat \varepsilon_1$ and $\Gamma \vdash \hat e_2 : \tau_2~\kw{with} \hat \varepsilon_2$, where $\varepsilon \subseteq \hat \varepsilon_2$.\\
	
	\noindent
	 Putting this all together and using \textsc{$\varepsilon$-MethCall} we learn $\Gamma \vdash \hat e_1.m_i(\hat e_2) : \type{\tau_3}{\hat \varepsilon_1 \cup \hat \varepsilon_2 \cup \varepsilon_3}$, and since $\varepsilon \subseteq \hat \varepsilon_1$ this type contains the run-time effects.\\
	}
	
	\subcase{ \textsc{E-MethCall3$_\sigma$}. Then we know $e_1 = v_1 = \newsig$ and $e_2 = v_2$ is a value. Also, $v_1.m_i(v_2) \longrightarrow [v_1/x, v_2/y]e_{body}~|~\varnothing$. By definition, $\hat e = \kwa{label}(v_1.m_i(v_2)) = (\kwa{label}(v_1)).m_i(\kwa{label}(v_2)) = \hat v_1.m_i(\hat v_2)$.\\
	
\noindent
Applying the inductive assumption to $v_1$ and $v_2$, we get $\Gamma \vdash v_1 : \type{\{ \bar \sigma \}}{\hat \varepsilon_1}$ and $\Gamma \vdash v_2 : \type{\{ \bar \sigma \}}{\hat \varepsilon_2}$. Because $v_1$ was already a labeled object, the method $m_i$ has the same label $\varepsilon_3$ in $\hat v_1$ as it does in $v_1$. By an application of \textsc{$\varepsilon$-MethCall} we learn $\Gamma \vdash v_1.m_i(v_2) : \type{\tau_3}{\hat \varepsilon_1 \cup \hat \varepsilon_2 \cup \varepsilon_3}$. Since $\varepsilon = \varnothing$ this type contains all the runtime effects.\\	
	}
}

\proofcase{\textsc{T-MethCall$_d$}}{
Then the following are known:
\begin{itemize}
	\item $e = e_1.m_i(e_2)$
	\item $\Gamma \vdash e_1 : \{ \bar d \}$
	\item $\Gamma \vdash e_2 : \tau_2$
	\item $\Gamma \vdash e_1.m_i(e_2) : \tau_3$
	\item $\keywadj{def}~m_i(y:\tau_2) : \tau_3 \in \{ \bar d \}$
\end{itemize}

\noindent
There are three reduction rules which could be applied to a method call $e_1.m_i(e_2)$ on an unlabeled object.\\

	\subcase{\textsc{E-MethCall1}. Then we know $e_1 \longrightarrow e_1'~|~\varepsilon$ and $e_1.m_i(e_2) \longrightarrow e_1'.m_i(e_2)~|~\varepsilon$. By definition, $\hat e = \kwa{label}(e_1.m_i(e_2)) = (\kwa{label}(e_1)).m_i(\kwa{label}(e_2)) = \hat e_1.m_i(\hat e_2)$. In the object $e_1$ method $m_i$ has no labeled effects. By definition of $\kwa{label}$, in $\hat e_1$ method $m_i$ will have the label $\kwa{effects}(\Gamma) \cap e_i$, where $e_i$ is the body of method $m_i$. \textbf{Not possible to tell if the expression is well-formed at this point i.e. if $m_i$ actually has a method body, so we probably need to add the assumption that $e$ is closed under $\Gamma$.}\\
	
\noindent
Because $\Gamma \vdash e_1 : \{ \bar d \}$ and $\Gamma \vdash e_2 : \tau_2$, by applying the inductive assumption to each we learn $\Gamma \vdash \hat e_1 : \type{\{ \bar \sigma \}}{\hat \varepsilon_1}$ and $\Gamma \vdash \hat e_2 : \tau_2~\kw{with} \hat \varepsilon_2$ (\textbf{first inductive assumption needs justification, and probably an invocation of the extension lemma)}, where $\varepsilon \subseteq \hat \varepsilon_1$. \\

\noindent
Now we can apply \textsc{$\varepsilon$-MethCall}, giving us $\Gamma \vdash \hat e_1.m_i(\hat e_2) : \type{\tau_3}{\hat \varepsilon_1 \cup \hat \varepsilon_2 \cup \varepsilon_3 }$, where $\varepsilon_3$ is the label on $m_i$. This is $\kwa{effects}(\Gamma) \cap e_i$, so this type has the effect-set $\hat \varepsilon_1 \cup \hat \varepsilon_2 \cup (\kwa{effects}(\Gamma) \cap e_i)$. $\varepsilon \subseteq \hat \varepsilon_1$ is an inductive assumption, so this type contains the runtime effects.
	}
}
}


\thm{Theorem 3.12. (Refinement Theorem)}
{If $\Gamma \vdash e : \tau~\keyw{with} \varepsilon$ and $\keywadj{label}(e) = \hat e$, then $\Gamma \vdash \hat e : \hat \tau~\keyw{with} \hat \varepsilon$, where $\hat \varepsilon \subseteq \varepsilon$ and $\tau = \hat \tau$.\\

\noindent
\fbox{Intuition.}~~~Labels can only make the static effects more precise; never less precise. \textbf{Needs to be edited/proofread so it makes sense with the new Extension theorem.}
\\\\
}
{By induction on the judgement $\Gamma \vdash e : \type{\tau}{\varepsilon}$.\\

\proofcase{\textsc{$\varepsilon$-Resource}, \textsc{$\varepsilon$-Var}}{
	If $e$ is a resource or a variable then $e = \hat e$ so the statement is automatically fulfilled.\\
}

\proofcase{\textsc{$\varepsilon$-OperCall}} {
Then $e = e_1.\pi$ and we know:
\begin{itemize}
	\item $\Gamma \vdash e : \type{\keywadj{Unit}}{ \{ r.\pi \} \cup \varepsilon_1 }$
	\item $\Gamma \vdash e_1 : \type{ \{ \bar r \} }{\varepsilon_1}$
\end{itemize}
Applying definitions, $\hat e = \keywadj{label}(e_1.\pi) = (\keywadj{label}(e_1)).\pi = \hat e_1.\pi$. By inductive assumption, $\Gamma \vdash \hat e_1 : \type{ \{ \bar r \} }{\hat \varepsilon_1}$, where $\hat \varepsilon_1 \subseteq \varepsilon_1$. Then $\Gamma \vdash \hat e : \type{\keywadj{Unit}}{ \{ r.\pi \} \cup \hat \varepsilon_1 }$ by \textsc{$\varepsilon$-OperCall}. Importantly, $\{ r.\pi \} \cup \hat \varepsilon_1 \subseteq \{ r.\pi \} \cup \varepsilon_1$ as claimed.\\
}

\proofcase{\textsc{$\varepsilon$-MethCall}} {
Then $e = e_1.m_i(e_2)$ and we know:
\begin{itemize}
	\item $\Gamma \vdash e : \type{\tau_3}{\varepsilon_1 \cup \varepsilon_2 \cup \varepsilon_3}$
	\item $\Gamma \vdash e_1 : \{ \bar \sigma \}~\keyw{with} \varepsilon_1$
	\item $\Gamma \vdash e_2 : \type{\tau_2}{\varepsilon_2}$
	\item $\sigma_i = \keyw{def} m_i(y : \tau_2) : \tau_3~\keyw{with} \varepsilon_3$ 
\end{itemize}
Applying definitions, $\hat e = \keywadj{label}(e_1.m_i(e_2)) = (\keywadj{label}(e_1)).m_i(\keywadj{label}(e_2)) = \hat e_1.m_i(\hat e_2)$. By inductive assumption, $\Gamma \vdash \hat e_1 : \{ \bar \sigma \}~\keyw{with} \hat \varepsilon_1$ and $\Gamma \vdash \hat e_2 : \type{\tau_2}{\hat \varepsilon_2}$, where $\hat \varepsilon_1 \subseteq \varepsilon_1$ and $\hat \varepsilon_2 \subseteq \varepsilon_2$. Then $\Gamma \vdash \hat e : \tau_3~\keyw{with} \hat \varepsilon_1 \cup \hat \varepsilon_2 \cup \varepsilon_3$ under \textsc{$\varepsilon$-MethCall}. Importantly, $\hat \varepsilon_1 \cup \hat \varepsilon_2 \cup \varepsilon_3 \subseteq \varepsilon_1 \cup \varepsilon_2 \cup \varepsilon_3$ as claimed.\\
}


\proofcase{\textsc{C-MethCall}} {
Then $e = e_1.m_i(e_2)$ and we know:
\begin{itemize}
	\item $\Gamma \vdash e : \type{\tau_3}{\varepsilon_1 \cup \varepsilon_2 \cup \varepsilon_3}$
	\item $\Gamma \vdash e_1 : \{ \bar d~\keyw{captures} \varepsilon_c \}~\keyw{with} \varepsilon_1$
	\item $\Gamma \vdash e_2 : \type{\tau_2}{\varepsilon_2}$
	\item $d_i = \keyw{def} m_i(y : \tau_2) : \tau_3$ 
\end{itemize}
The reasoning is the same as the above case, but use \textsc{C-MethCall} instead of \textsc{$\varepsilon$-MethCall}.\\
}

\proofcase{\textsc{$\varepsilon$-NewObj}}{
Then $e = \newsig$ and we know:
\begin{itemize}
	\item $\Gamma \vdash e : \type{ \{ \bar \sigma \} }{\varnothing}$
	\item $\Gamma, x : \{ \bar \sigma \} \vdash \overline{ \sigma = e }~\keyw{OK}$
\end{itemize}
For each $i$, $\sigma_i = e_i~\keywadj{OK}$ only matches \textsc{$\varepsilon$-ValidImpl$_\sigma$}. By inversion on that rule, $\Gamma, y : \tau_2 \vdash e: \tau_3~\keyw{with} \varepsilon_3$ and $\sigma_i = \keyw{def} m_i(y : \tau_2) : \tau_3~\keyw{with} \varepsilon_3$. Applying definitions, $\hat e = \keywadj{label}(\newsig) = \keywadj{new}_\sigma~x \Rightarrow \keywadj{label \hyphen helper}(\overline{\sigma = e})$. Then for each $i$, 
 $\keywadj{label \hyphen helper}(\sigma_i = e _i) = \sigma_i = \keywadj{label}(e_i)$. Let $\hat e_i = \keywadj{label}(e_i)$. Applying the inductive assumption we get $\Gamma \vdash \hat e_i : \type{\tau_3}{\hat \varepsilon_3}$. Then $\Gamma \vdash \sigma_i = \keywadj{label}(e_i)~\keywadj{OK}$ by \textsc{$\varepsilon$-ValidImpl$_\sigma$}. This was for any $i$, so $\Gamma \vdash \overline{ \sigma_i = \keywadj{label}(e_i) }~\keywadj{OK}$. Finally we can apply \textsc{$\varepsilon$-NewObj} to the labeled object $\overline{ \sigma_i = \keywadj{label}(e_i) }$, which gives the judgement $\Gamma \vdash \hat e : \{ \bar \sigma \}~\keyw{with} \varnothing$.\\
}

\proofcase{\textsc{C-NewObj}}{
Then $e = \newd$ and we know:
\begin{itemize}
	\item $\Gamma \vdash e_1.m_i(e_2) : \type{\tau_3}{\varepsilon_1 \cup \varepsilon_2 \cup \varepsilon_3}$
	\item $\Gamma' \subseteq \Gamma$
	\item $\varepsilon_c = \keywadj{effects}(\Gamma')~\keyw{with} \varnothing$
	\item $\Gamma', x : \{ \bar d~\keyw{captures} \varepsilon_c \} \vdash \overline{d = e}~\keyw{OK}$
\end{itemize}
(Similar to above). For each $i$, $d_i = e_i~\keywadj{OK}$ only matches \textsc{$\varepsilon$-ValidImpl$_d$}. By inversion on that rule, $\Gamma, y : \tau_2 \vdash e: \tau_3$ and $d_i = \keyw{def} m(y : \tau_2) : \tau_3~\keyw{with} \varepsilon_3$. Applying definitions, $\hat e = \keywadj{label}(\newsig) = \keywadj{new}_d~x \Rightarrow \keywadj{label \hyphen helper}(\overline{d = e})$. Then for each $i$, $\keywadj{label \hyphen helper}(\keywadj{def}~m(y : \tau_2) : \tau_3 = e) = \keywadj{def}~m(y : \tau_2) : \tau_3~\keyw{with}  \keywadj{effects}(\Gamma \cap \keywadj{freevars}(e_i)) = \keywadj{label}(e_i)$. Let $\hat e_i = \keywadj{label}(e_i)$. By inductive assumption, $\Gamma \vdash \hat e_i : \tau_3~\keyw{with} \hat \varepsilon_3$. This was for any $i$, so if $\sigma_i$ is the labeled version of $d_i$ then $\Gamma \vdash \overline{ \sigma_i = \keywadj{label}(e_i) }~\keywadj{OK}$. Finally we can apply \textsc{$\varepsilon$-NewObj} to the labeled object $\overline{ d_i = \keywadj{label}(e_i) }$, which gives the judgement $\Gamma \vdash \hat e : \{ \bar d \}~\keyw{with} \varnothing$.
}
}

\thm{Theorem 3.13. (Soundness Theorem)}
{If $\Gamma \vdash e_A : \tau_A~\keyw{with} \varepsilon_A$ and $e_A \longrightarrow e_B~|~\varepsilon$ then $\Gamma \vdash e_B : \tau_B~\keyw{with} \varepsilon_B$, where $\tau_B = \tau_A$ and $\varepsilon \subseteq \varepsilon_A$.\\\\}
{~\\\\Let $\hat e_A = \keywadj{label}(e_A)$. By applying the Refinement theorem to $e_A$ we know the following:

\begin{adjustwidth}{1.5em}{0em}
\begin{enumerate}
	\item $\Gamma \vdash \hat e_A : \type{\hat \tau_A}{\hat \varepsilon_A}$
	\item $\tau_A = \hat \tau_A$
	\item $\hat \varepsilon_A \subseteq \varepsilon_A$\\
\end{enumerate}
\end{adjustwidth}

\noindent
From Invariance of Runtime Under $\kwa{label}$ we also know:

\begin{adjustwidth}{1.5em}{0em}
\begin{enumerate}
	\setcounter{enumi}{4}
	\item $\hat e_A \longrightarrow \hat e_B~|~\varepsilon$
	\item $\kwa{label}(e_B) = \hat e_B$\\
\end{enumerate}
\end{adjustwidth}

\noindent
Applying the Refinement theorem to $e_B$ we get:
 
\begin{adjustwidth}{1.5em}{0em}
\begin{enumerate}
	\setcounter{enumi}{6}
	\item $\Gamma \vdash \hat e_B : \type{\tau_B}{\hat \varepsilon_B}$\\
\end{enumerate}
\end{adjustwidth}

\noindent
$\hat e_A$ is a fully-labeled program. By the soundness of $\varepsilon$ rules applied to reduction \textbf{5}:


\begin{adjustwidth}{1.5em}{0em}
\begin{enumerate}
	\setcounter{enumi}{7}
	\item $\Gamma \vdash \hat e_B : \type{\hat \tau_A}{\hat \varepsilon_B}$
	\item $\varepsilon \subseteq \hat \varepsilon_A$\\
\end{enumerate}
\end{adjustwidth}

\noindent
\textbf{9} and \textbf{3} gives us effect-soundness.

\begin{adjustwidth}{1.5em}{0em}
\begin{enumerate}
	\setcounter{enumi}{9}
	\item $\varepsilon \subseteq \hat \varepsilon_A$ \\
\end{enumerate}
\end{adjustwidth}


\noindent
Because of \textbf{2}, judgement \textbf{7} can be rewritten as:

\begin{adjustwidth}{1.5em}{0em}
\begin{enumerate}
	\setcounter{enumi}{10}
	\item $\Gamma \vdash \hat e_B : \type{\tau_A}{\hat \varepsilon_B}$ \\
\end{enumerate}
\end{adjustwidth}

\noindent
From \textbf{1} we know $\hat e_A$ has type $\hat \tau_A$; from \textbf{7} we know $\hat e_B$ has type $\tau_B$. By type preservation of fully-labeled programs applied to \textbf{5} we know:

\begin{adjustwidth}{1.5em}{0em}
\begin{enumerate}
	\setcounter{enumi}{11}
	\item $\hat \tau_A = \tau_B$ \\
\end{enumerate}
\end{adjustwidth}

\noindent
By comparing \textbf{2} and \textbf{12} we get type-soundnses.

\begin{adjustwidth}{1.5em}{0em}
\begin{enumerate}
	\setcounter{enumi}{11}
	\item $\tau_A = \hat \tau_A = \tau_B$
\end{enumerate}
\end{adjustwidth}
}

\end{document}











