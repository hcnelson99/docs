\documentclass{llncs}

\usepackage{listings}
\usepackage{proof}
\usepackage{amssymb}
\usepackage[margin=.9in]{geometry}
\usepackage{amsmath}
\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage{enumitem}
\usepackage{filecontents}
\usepackage{calc}
\usepackage[linewidth=0.5pt]{mdframed}
\usepackage{changepage}
\usepackage{tabto}
\allowdisplaybreaks

\usepackage{fancyhdr}
\renewcommand{\headrulewidth}{0pt}
\pagestyle{fancy}
 \fancyhf{}
\rhead{\thepage}

\lstset{tabsize=3, basicstyle=\ttfamily\small, commentstyle=\itshape\rmfamily, numbers=left, numberstyle=\tiny, language=java,moredelim=[il][\sffamily]{?},mathescape=true,showspaces=false,showstringspaces=false,columns=fullflexible,xleftmargin=5pt,escapeinside={(@}{@)}, morekeywords=[1]{objtype,module,import,let,in,fn,var,type,rec,fold,unfold,letrec,alloc,ref,application,policy,external,component,connects,to,meth,val,where,return,group,by,within,count,connect,with,attr,html,head,title,style,body,div,keyword,unit,def}}
\lstloadlanguages{Java,VBScript,XML,HTML}

\newcommand{\keywadj}[1]{\mathtt{#1}}
\newcommand{\keyw}[1]{\keywadj{#1}~}

\newcommand{\kw}[1]{\keyw{ #1 }}
\newcommand{\kwa}[1]{\keywadj{ #1 }}
\newcommand{\reftt}{\mathtt{ref}~}
\newcommand{\Reftt}{\mathtt{Ref}~}
\newcommand{\inttt}{\mathtt{int}~}
\newcommand{\Inttt}{\mathtt{Int}~}
\newcommand{\stepsto}{\leadsto}
\newcommand{\todo}[1]{\textbf{[#1]}}
\newcommand{\intuition}[1]{#1}
\newcommand{\hyphen}{\hbox{-}}

%\newcommand{\intuition}[1]{}

\newlist{pcases}{enumerate}{1}
\setlist[pcases]{
  label=\fbox{\textit{Case}}\protect\thiscase\textit{:}~,
  ref=\arabic*,
  align=left,
  labelsep=0pt,
  leftmargin=0pt,
  labelwidth=0pt,
  parsep=0pt
}
\newcommand{\pcase}[1][]{

  \if\relax\detokenize{#1}\relax
    \def\thiscase{}
  \else
    \def\thiscase{~\fbox{#1:}}
  \fi
  \item
}

\newcommand{\thm}[3]{
	\begin{large}
		\bf{#1}
	\end{large} \\\\
	\fbox{Statement.} ~ #2
	\fbox{Proof.}~ #3 \qed
}

\newcommand{\proofcase}[2]{
	\begin{adjustwidth}{1.5em}{0pt}
		\fbox{Case.}~~#1. \\ ~#2
	\end{adjustwidth}
}

\newcommand{\subcase}[1] {
	\begin{adjustwidth}{2.2em}{0pt}
		\underline{Subcase.} #1
	\end{adjustwidth}
}

\newcommand{\stmt}[1] {

\begin{adjustwidth}{2.5em}{0pt}
	#1
\end{adjustwidth}

}
\newcommand{\type}[2]{
	#1~\keyw{with} #2
}

\newcommand{\newd}[0]{
	\keywadj{new}_d~x \Rightarrow \overline{d = u}
}

\newcommand{\newsig}[0]{
	\keywadj{new}_\sigma~x \Rightarrow \overline{\sigma = l}
}

\begin{document}

\section{Grammar}

\[
\begin{array}{lll}

\begin{array}{lllr}

\rho & ::= & x & primitives\\
		& | & r \\
		&&\\
		
\tau_\rho & ::= & \{ r \} & primitive~types \\
		&&\\\\\\

e_u & ::= & \rho & deeply~unlabeled~progs. \\
 		& | & \kwa{new}_d~x \Rightarrow \overline{d = e_u} \\
 		& | & e_u.m(e_u)\\
 		& | & e_u.\pi\\
		&&\\

d & ::= & \kw{def} m(y:\tau_u):\tau_u & e_u \hyphen prog~decls.\\
		&&\\

\tau_u & ::= & \{ \overline{ d } \} & e_u \hyphen prog~types \\
	& | & \{ \overline{ d }~\kw{captures} \varepsilon \} \\
	& | & \tau_\rho \\
	&&\\\\\\





e_l & ::= & \rho & deeply~labeled~progs. \\
	& | & \kwa{new}_\sigma~x \Rightarrow \overline{\sigma = e_l} \\
	& | & l.m(l) \\
	& | & l.\pi \\
	&&\\

\sigma & ::= & \kwa{def}~m(y : \tau_l) : \tau_l~\kw{with} \varepsilon & e_l \hyphen prog~decls. \\
	&&\\

\tau_l & ::= & \{ \bar \sigma \} & e_l \hyphen prog~types \\
	& | & \tau_\rho \\
	&&\\\\\\
	
	
	
	
	
	
	
	
	
e & ::= & \rho & progs. \\
	& | & e.m(e) \\
	& | & e.\pi \\
	& | & \kwa{new}_d~x \Rightarrow \overline{d = e_u} \\
	& | & \kwa{new}_\sigma~x \Rightarrow \overline{\sigma = e} \\
	&&\\
	
\tau & ::= & \tau_l & types \\
	& | & \tau_u \\
	&&\\
		
		
\end{array}
& ~~~~~~
&
\end{array}
\]

\noindent \textbf{Notes:}

\begin{itemize}
	\item $e_u$ programs are \textit{deeply unlabeled} programs: no labels appear in the source code (though label inference may be done by the type system).
	\item $e_l$ programs are \textit{deeply labeled} programs: everything in the source code is labeled.
	\item $e$ programs are the general form of a syntactically-correct program. They may contain a mixture of labeled and unlabeled parts. Any unlabeled parts must be deeply unlabeled, but labeled parts need not be deeply labeled. This means you can have unlabeled parts appearing inside labeled parts, but not vice versa.
\end{itemize}


\section{Static Semantics}

\noindent
$\fbox{$\Gamma \vdash \rho : \tau$}$

\[
\begin{array}{c}

\infer[\textsc{($\rho$-Var)}]
	{\Gamma, x : \tau \vdash x : \tau}
	{}
~~~~~~~~~~
\infer[\textsc{($\rho$-Resource)}]
	{\Gamma, r : \{ r \} \vdash r : \{ r \}}
	{} \\[6ex]

\end{array}
\]

\noindent
$\fbox{$\Gamma \vdash \rho : \type{\tau}{\varepsilon}$}$

\[
\begin{array}{c}

\infer[\textsc{($\rho$-Var$_\varepsilon$)}]
	{\Gamma, x : \tau \vdash x : \type{\tau}{\varnothing}}
	{}
~~~~~~~~~~
\infer[\textsc{($\rho$-Resource$_\varepsilon$)}]
	{\Gamma, r : \{ r \} \vdash r : \type{\{ r \}}{\varnothing}}
	{} \\[6ex]

\end{array}
\]

\noindent
$\fbox{$\Gamma \vdash e_u : \tau_u$}$

\[
\begin{array}{c}
\infer[\textsc{($e_u$-New)}]
	{\Gamma \vdash~\kwa{new}_d~x \Rightarrow \overline{ d = e_u } : \{ \overline{d} \}}
	{\Gamma, x : \{ \overline{d} \} \vdash \overline{d = e_u}~\keywadj{OK}}
~~~~~~~~~~
\infer[\textsc{($e_u$-OperCall)}]
	{\Gamma \vdash e_u.\pi : \keywadj{Unit}}
	{\Gamma \vdash e_u : \{ r \}} \\[5ex]

\infer[\textsc{($e_u$-MethCall)}]
	{\Gamma \vdash e_{u, 1}.m(e_{u, 2}) : \tau_{u, 3}}
	{\Gamma \vdash e_{u, 1} : \{ \overline{ d }\} &~~~ \keyw{def} m(y : \tau_{u, 2}) : \tau_{u, 3} \in \{ \overline{d} \} &~~~  \Gamma \vdash e_{u, 2} : \tau_{u, 2} }\\[6ex]

\end{array}
\]

\noindent
$\fbox{$\Gamma \vdash d = e_u~\keyw{OK}$}$
\[
\begin{array}{c}
\infer[\textsc{($e_u$-ValidImpl)}]
	{\Gamma \vdash d = e_u~\keywadj{OK}}
	{d = \keyw{def} m(y : \tau_{u, 2}) : \tau_{u, 3} & \Gamma, y : \tau_{u, 2} \vdash e_u : \tau_{u, 3}}
	\\[5ex]
\end{array}
\]

\noindent
$\fbox{$\Gamma \vdash e_u : \tau_u~\kw{with} \varepsilon$}$
\[
\begin{array}{c}
\infer[\textsc{($e_u$-New$_\varepsilon$)}]
	{\Gamma \vdash~\kwa{new}_d~x \Rightarrow \overline{ d = e_u } : \{ \overline{d}~\kw{captures} \varepsilon_c \}~ \kw{with} \varnothing }
	{\varepsilon_c = \keywadj{effects}(\Gamma') &~~~ \Gamma' \subseteq \Gamma &~~~ \Gamma' \vdash~\kwa{new}_d~x \Rightarrow \overline{ d = e_u } : \{ \overline{d} \}}
	{}
	\\[5ex]
	
	\infer[\textsc{($e_u$-MethCall$_\varepsilon$)}]
	{\Gamma \vdash e_{u, 1}.m(e_{u, 2}) : \tau_{l, 3}~ \keyw{with} \varepsilon_1 \cup \varepsilon_2 \cup \keywadj{effects}(\tau_{u, 2}) \cup \varepsilon_c}
	{\Gamma \vdash e_{u,1} : \{ \overline{d}~\keyw{captures} \varepsilon_c \}~\keyw{with} \varepsilon_1 &~~~ \Gamma \vdash e_{u,2}:\tau_{u,2}~\keyw{with} \varepsilon_2 &~~~ d =~\keyw{def} m(y:\tau_{u,2}):\tau_{u,3} \in \overline{d} }
	\\[5ex]
\end{array}
\]

\noindent
\fbox{$\Gamma \vdash e : \tau~\keyw{with} \varepsilon$}

\[
\begin{array}{c}

\infer[\textsc{($e$-NewObj)}]
	{\Gamma \vdash \kwa{new}_\sigma~x \Rightarrow \overline{\sigma = e} : \{ \bar \sigma \}~\keyw{with} \varnothing}
	{\Gamma,~x : \{ \bar \sigma \} \vdash \overline{\sigma = e}~\keywadj{OK}} ~~~~~~

\infer[\textsc{($e$-OperCall)}]
	{\Gamma \vdash e_1.\pi : \keyw{Unit} \keyw{with} \{ r.\pi \} \cup \varepsilon_1}
	{\Gamma \vdash e_1 : \{ r \}~ \keyw{with} \varepsilon_1} \\[5ex]
	
\infer[\textsc{($e$-MethCall)}]
	{\Gamma \vdash e_{1}.m_i(e_{2}):\tau_{3}~\keyw{with} \varepsilon_1 \cup \varepsilon_2 \cup \varepsilon_3}
	{\Gamma \vdash e_{1} : \{ \bar \sigma \}~\keyw{with} \varepsilon_1 & \Gamma \vdash e_{2} : \tau_{2}~\keyw{with} \varepsilon_2 & \sigma = \keyw{def} m(y:\tau_{2}):\tau_{3}~\keyw{with} \varepsilon_3 \in \overline{\sigma = e}} \\[5ex]
\end{array}
\]

\noindent
$\fbox{$\Gamma \vdash \sigma = e~\keyw{OK}$}$

\[
\begin{array}{c}
\infer[\textsc{($\varepsilon$-ValidImpl)}]
	{\Gamma \vdash \sigma = e~\keywadj{OK}}
	{\Gamma,~y:\tau_{2} \vdash e: \tau_{3}~\keyw{with} \varepsilon_3 & \sigma = \keyw{def} m(y:\tau_{2}):\tau_{3}~\keyw{with} \varepsilon_3} \\[5ex]
\end{array}
\]



\noindent
$\fbox{$\Gamma \vdash \tau <: \tau$}$

\[
\begin{array}{c}

\infer[\textsc{(St-Reflexive)}]
	{\Gamma \vdash \tau <: \tau}
	{}
	
~~~~~~~~~~

	\infer[\textsc{(St-Transitive)}]
	{\Gamma \vdash \tau_1 <: \tau_3}
	{\Gamma \vdash \tau_1 <: \tau_2 & \Gamma \vdash \tau_2 <: \tau_3}\\[5ex]

\infer[\textsc{(St-Subsumption)}]
	{\Gamma \vdash e : \tau_2}
	{\Gamma \vdash e : \tau_1 & \Gamma \vdash \tau_1 <: \tau_2} 
	
	~~~~~~~~~~
	
\infer[\textsc{(St-EffectTypes)}]
	{ \Gamma \vdash \type{\tau_1}{\varepsilon_1} <: \type{\tau_2}{\varepsilon_2}}
	{ \Gamma \vdash \tau_1 <: \tau_2 ~~~~~~ \varepsilon_1 \subseteq \varepsilon_2} \\[5ex]

\infer[\textsc{(St-Permutation$_\sigma$)}]
	{\Gamma \vdash \{ \bar \sigma \}_1 <: \{ \bar \sigma \}_2 }
	{\Gamma \vdash \{ \bar \sigma \}_1 $ is a permutation of $ \{ \bar \sigma \}_2}
	
	~~~~~~~~~~
	
\infer[\textsc{(St-Permutation$_d$)}]
	{\Gamma \vdash \{ \bar d \}_1 <: \{ \bar d \}_2 }
	{\Gamma \vdash \{ \bar d \}_1 $ is a permutation of $ \{ \bar d \}_2}
	
	\\[5ex]
	
	~~~~~~~~~~

\infer[\textsc{(St-Depth$_\sigma$)}]
	{ \Gamma \vdash \{ \sigma_i~^{i \in 1..n} \} <: \{ \sigma_j~^{j \in 1..n} \} }
	{ \Gamma \vdash \sigma_i <:: \sigma_j }
	
	~~~~~~~~~~
	
\infer[\textsc{(St-Depth$_d$)}]
	{ \Gamma \vdash \{ d_i~^{i \in 1..n} \} <: \{ d_j~^{j \in 1..n} \} }
	{ \Gamma \vdash d_i <:: d_j }
	
	\\[5ex]
	
\infer[\textsc{(St-Width$_\sigma$)}]
	{ \Gamma \vdash \{ \sigma_i~^{i \in 1..n+k} \} <: \{ \sigma_i~^{i \in 1..n} \} }
	{n,k \geq 0}
	
~~~~~
  
\infer[\textsc{(St-Width$_d$)}]
	{ \Gamma \vdash \{ d_i~^{i \in 1..n+k} \} <: \{ d_i~^{i \in 1..n} \} }
	{n,k \geq 0}
	
		\\[5ex]
	
	
\end{array}
\]


\noindent
$\fbox{$\Gamma \vdash \sigma <:: \sigma$}$

\[
\begin{array}{c}

\infer[\textsc{(St-Method$_\sigma$)}]
	{ \Gamma \vdash \sigma_i <:: \sigma_j }
{{\def\arraystretch{1.6}
  \begin{array}{c}
\sigma_i = \kw{def} m_A(y : \tau_1) : \type{\tau_2}{\varepsilon_A}
~~~~~~\sigma_j = \kw{def} m_B(y : \tau_1') : \type{\tau_2'}{\varepsilon_B} \\
\Gamma \vdash \tau_1' <: \tau_1 ~~~~~~ \Gamma \vdash \tau_2 <: \tau_2' ~~~~~~ \varepsilon_A \subseteq \varepsilon_B
  \end{array}}} \\[5ex]
 
\end{array}
\]



\noindent
$\fbox{$\Gamma \vdash d <:: d$}$

\[
\begin{array}{c}

\infer[\textsc{(St-Method$_d$)}]
	{ \Gamma \vdash d_i <:: d_j }
{{\def\arraystretch{1.6}
  \begin{array}{c}
d_i = \kw{def} m_A(y : \tau_1) : \tau_2 ~~~~~~ d_j = \kw{def} m_B(y : \tau_1') : \tau_2' \\
\Gamma \vdash \tau_1' <: \tau_1 ~~~~~~ \Gamma \vdash \tau_2 <: \tau_2'
  \end{array}}} \\[5ex]

\end{array}
\]

\noindent \textbf{Notes:}
\begin{itemize}
	\item A good choice of $\Gamma'$ for \textsc{$e_u$-New$_\varepsilon$} is the intersection of $\Gamma$ with the free variables in the object.
	\item By convention we use $\varepsilon_c$ to denote the output of the $\keywadj{effects}$ function.
\end{itemize}

\section{Definition: $\keywadj{effects}$ Function}

\noindent
The $\keywadj{effects}$ function returns the set of effects captured in a particular context.

\begin{itemize}
	\item $\keywadj{effects}(\varnothing) = \varnothing$
	\item $\keywadj{effects}(\Gamma, x : \tau) = \keywadj{effects}(\Gamma) \cup \keywadj{effects}(\tau)$
	\item $\keywadj{effects}(\{\bar r\}) = \{ (r, \pi) \mid r \in \bar r, \pi \in \Pi \}$
	\item $\keywadj{effects}(\{\bar \sigma\}) = \bigcup_{\sigma \in \bar \sigma}~\keywadj{effects}(\sigma)$
	\item $\keywadj{effects}(\{\bar d\}) = \bigcup_{d \in \bar d}~\keywadj{effects}(d)$
	\item $\keywadj{effects}(d~\keyw{with} \varepsilon) = \varepsilon \cup \keywadj{effects}(d)$
	\item $\keywadj{effects}(\keywadj{def~m}(x : \tau_1) : \tau_2) = \keywadj{effects}(\tau_2)$
	\item $\keywadj{effects}(\{\bar d ~\keyw{captures} \varepsilon_c\}) = \varepsilon_c$
\end{itemize}

\noindent \textbf{Notes:}

\begin{enumerate}
	\item The function is monotonic; if $\Gamma_1 \subseteq \Gamma_2$, then $\kwa{effects}(\Gamma_1) \subseteq \kwa{effects}(\Gamma_2)$.
\end{enumerate}


\section{Dynamic Semantics}

~\\
\noindent
\fbox{$e \longrightarrow e~|~\varepsilon$}

\[
\begin{array}{c}

	\infer[\textsc{(E-MethCall1)}]
		{e_1.m(e_2) \longrightarrow e_1'.m(e_2)~|~\varepsilon}
		{e_1 \longrightarrow e_1'~|~\varepsilon} \\[5ex]

	\infer[\textsc{(E-MethCall2$_{\sigma}$)}]
		{v_1.m(e_2) \longrightarrow v_1.m(e_2')~|~\varepsilon}
		{v_1 = \newsig & e_2 \longrightarrow e_2'~|~\varepsilon} ~~~~~~
		
	\infer[\textsc{(E-MethCall2$_d$)}]
		{v_1.m(e_2) \longrightarrow v_1.m(e_2')~|~\varepsilon}
		{v_1 = \newd & e_2 \longrightarrow e_2'~|~\varepsilon}\\[5ex]
				
	\infer[\textsc{(E-MethCall3$_{\sigma}$)}]
		{v_1.m(v_2)
			\longrightarrow
		 [v_1/x, v_2/y]l~|~\varnothing}
  		{v_1 = \newsig & \keywadj{def~m}(y: \tau_1) : \tau_2~\keyw{with} \varepsilon = l \in \overline {\sigma = l}} \\[5ex]

	\infer[\textsc{(E-MethCall3$_d$)}]
		{v_1.m(v_2)
			\longrightarrow
		 [v_1/x, v_2/y]u~|~\varnothing}
  		{v_1 = \newd & \keywadj{def~m}(y: \tau_1) : \tau_2 = e \in \overline {d = u}} \\[5ex]

	\infer[\textsc{(E-OperCall1)}]
		{e_1.\pi
			\longrightarrow
		 e_1'.\pi~|~\varepsilon}
		{e_1 \longrightarrow e_1'~|~\varepsilon}
~~~~~~

			\infer[\textsc{(E-OperCall2)}]
		{r.\pi
			\longrightarrow
		 \keywadj{unit}~|~\{r.\pi\}}
		{} \\[5ex]
			
\end{array}
\]
\noindent
\fbox{$e \longrightarrow_* e~|~\varepsilon$}

\[
\begin{array}{c}

	\infer[\textsc{(E-MultiStep1)}]
	{e \longrightarrow_* e~|~\varnothing}
	{} ~~~~~~~~
	
	\infer[\textsc{(E-MultiStep2)}]
	{e \longrightarrow_* e'~|~\varepsilon}
	{e \longrightarrow e'~|~\varepsilon} \\[5ex]

	\infer[\textsc{(E-MultiStep3)}]
	{e \longrightarrow_* e''~|~\varepsilon_1 \cup \varepsilon_2}
	{e \longrightarrow_* e'~|~\varepsilon_1 & e' \longrightarrow_* e''~|~\varepsilon_2}

\end{array}
\]

\noindent \textbf{Notes:}
\begin{itemize}
	\item \textsc{E-MethCall2$_d$} and \textsc{E-MethCall2$_\sigma$} are really doing the same thing, but one applies to labeled objects (the $\sigma$ version) and the other to unlabeled objects. Same goes for \textsc{E-MethCall3$_\sigma$} and \textsc{E-MethCall3$_d$}.
	\item \textsc{E-MethCall1} can be used for both labeled and unlabeled objects.
\end{itemize}


\section{Definition ($\keywadj{substitution}$)}

TODO










\section{Lemma (Canonical Forms)}

\textbf{Lemma. } If $u$ is a value then $\Gamma \vdash u : \type{\tau}{\varnothing}$, and one of the following is true:
\begin{enumerate}
	\item $u = r$ and $\tau = \kwa{Unit}$.
	\item $u = x$ and $x : \tau \in \Gamma$.
	\item $u = \newd$ and $\tau = \{ \bar d \}$ 
\end{enumerate} 

\noindent
\textbf{Proof.} By inspection.








\section{Lemma (Substitution)}

\textbf{Lemma. } Suppose the following is true: 

\begin{enumerate}
	\item $\Gamma, z : \tau' \vdash e : \tau~\keyw{with} \varepsilon$
	\item $\Gamma \vdash e' : \tau'~\keyw{with} \varepsilon'$
\end{enumerate}
	
	\noindent
Then $\Gamma \vdash [e'/z]e : \tau~\keyw{with} \varepsilon$.\\

\noindent
\textbf{Proof.} TODO (Should be same as the proof in previous grammar, just need to convert everything to new grammar)






\section{Definition ($\keywadj{label}$)}
A program may be converted into a fully-labeled program. This is a function from $e$-terms to $e_l$-terms. It is always defined relative to some $\Gamma$, which is usually clear from context. The process is well-defined on $e$ if $\Gamma \vdash e : \type{\tau}{\varepsilon}$. Then $\kwa{label}$ is defined below.

\begin{enumerate}
	\item $\kwa{label}(\rho) = \rho$
	\item $\kwa{label}(u_1.\pi) = \kwa{label}(u_1).\pi$
	\item $\kwa{label}(u_1.m(u_2)) = \kwa{label}(u_1).m(\kwa{label}(u_2))$
	\item $\kwa{label}(\newd) = \kwa{new}_\sigma~x \Rightarrow \kwa{label \hyphen decl}(\overline{d = u})$
	\item $\kwa{label}(\kwa{new}_\sigma~x \Rightarrow \overline{\sigma = e}) = \kwa{new}_\sigma~x \Rightarrow \overline{\sigma = \kwa{label}(e)}$
\end{enumerate}

\noindent
The helper function $\kwa{label \hyphen decl}$ works by labeling each declaration with what it captures in the context $\Gamma$. We abbreviate this as $\kwa{effects}(\Gamma \cap \kwa{freevars}(e))$. The helper is defined below.

\begin{enumerate}
  \setcounter{enumi}{4}
  \item $\kwa{label \hyphen decl}(d = u) = d~\kw{with} \kwa{effects}(\Gamma \cap \kwa{freevars}(e)) = \kwa{label}(u)$
\end{enumerate}

\noindent \textbf{Notes:}
\begin{itemize}
	\item The image of $\kwa{label}(e_u)$ is an $e_l$-term (proof by induction on definition).
	\item $e_u$ is a value $\iff \kwa{label}(e_u)$ is a value.
	\item More rigorously we can define $\varnothing \cap \kwa{freevars}(e)$ as $\varnothing$, and $(\Gamma, x : \tau) \cap \kwa{freevars}(e)$ as $(\{ x \} \cap \kwa{freevars}(e)) \cup (\Gamma \cap \kwa{freevars}(e))$.
\end{itemize}












\section{Theorem ($\kwa{label}$ and $\kwa{sub}$ Commute)}

TODO









\section{Theorem (Runtime Invariant Under Labeling)}

If the following are true:
	\begin{enumerate}
	\item $\Gamma \vdash e_A : \type{\tau_A}{\varepsilon_A}$
	\item $e_A \longrightarrow e_B~|~\varepsilon$
	\item $\hat e_A = \keywadj{label}(e_A, \Gamma)$
	\end{enumerate}
Then $\hat e_A \longrightarrow \hat e_B~|~\varepsilon$ and $\hat e_B = \keywadj{label}(e_B, \Gamma)$.









\section{Theorem (Refinement)}

\textbf{Theorem.} Suppose $\Gamma \vdash u : \tau_A~\kwa{with}~\varepsilon_A$. Then $\Gamma \vdash \kwa{label}(u) : \type{\tau_B}{\varepsilon_B}$ and:
\begin{enumerate}
	\item $\tau_B <: \tau_A$
	\item $\varepsilon_B \subseteq \varepsilon_A$
\end{enumerate}

\noindent
\textbf{Proof.} By induction on $\Gamma \vdash u : \type{\tau_A}{\varepsilon_A}$.\\

\proofcase{\textsc{T-NewInf}}{
Then the following are known.


\begin{adjustwidth}{1.5em}{0em}
\begin{enumerate}
  \setcounter{enumi}{4}
  \item $u = \newd$
  \item $\tau_A = \{ \bar d~\kw{captures} \varepsilon_C \}$
  \item $\varepsilon_A = \varnothing$
  \item $\Gamma' \subseteq \Gamma$
  \item $\Gamma', x : \{ \bar d~\kw{captures} \varepsilon_C \} \vdash \overline{d = u}~\kwa{OK}$
  \item $\varepsilon_C = \kwa{effects}(\Gamma')$
\end{enumerate}
\end{adjustwidth}

~\\
Let $l = \kwa{label}(u)$. Applying the definition of label to (5) we get:

\begin{adjustwidth}{1.5em}{0em}
$l = \kwa{label}(u) \\
= \kwa{label}(\newd) \\
= \kwa{new}_\sigma~x \Rightarrow \kwa{label \hyphen decl}(\overline{d = u}) \\
= \kwa{new}_\sigma~x \Rightarrow \overline{d~\kw{with} \kwa{effects}(\Gamma \cap \kwa{freevars}(u)) = \kwa{label}(u)}$
\end{adjustwidth}

\noindent
\\Fix some method declaration $d_i = u_i$ in the original unlabeled object $u$. From (9) we know $\Gamma', x : \{ \bar d~\kw{captures} \varepsilon_c \} \vdash d_i = u_i~\kwa{OK}$. The only rule with this judgement is \textsc{T-ValidImpl}. By inversion we obtain:
\begin{adjustwidth}{1.5em}{0em}
\begin{enumerate}
  \setcounter{enumi}{10}
  \item $d_i = \kw{def} m(y : \tau_2) : \tau_3$
  \item $\Gamma', x : \{ \bar d~\kw{captures} \varepsilon_c \}, y : \tau_2 \vdash e : \tau_3$
\end{enumerate}
\end{adjustwidth}


}

\proofcase{\textsc{T-MethCallInf}}{
hi\\
}


\section{Theorem (Soundness)}

\textbf{Theorem.} Suppose $\Gamma \vdash u_A : \type{\tau_A}{\varepsilon_A}$ and $u_A \longrightarrow u_B~|~\varepsilon$. The following are true:
\begin{enumerate}
	\item $\Gamma \vdash u_B : \type{\tau_B}{\varepsilon_B}$
	\item $\tau_B <: \tau_A$
	\item $\varepsilon_B \cup \varepsilon = \varepsilon_A$
	\end{enumerate}

\noindent
\textbf{Proof.} Without loss of generality assume $u_A$ is not a value. Let $l_A = \kwa{label}(u_A)$. By Theorem 11 (Refinement) we learn:
\begin{enumerate}
  \setcounter{enumi}{3}
  \item $\Gamma \vdash l_A : \type{\hat \tau_A}{\hat \varepsilon_A}$
  \item $\hat \tau_A <: \tau_A$
  \item $\hat \varepsilon_A \subseteq \varepsilon_A$
\end{enumerate}
 
\noindent
Because $u_A$ is not a value, neither is $l_A$. By Theorem 10 the runtime is invariant under labeling, so $l_A \longrightarrow l_B~|~\varepsilon$, where $l_B = \kwa{label}(u_B)$. Because the typing rules for $l$-terms are sound, $\Gamma \vdash l_B : \type{\hat \tau_B}{\hat \varepsilon_B}$ where:

\begin{enumerate}
  \setcounter{enumi}{6}
	\item $\hat \tau_B <: \hat \tau_A$
	\item $\hat \varepsilon_B \subseteq \hat \varepsilon_A$
\end{enumerate}

\noindent
\textbf{It's at this point we invoked Refinement again to relate $l_B$ and $u_B$. However, the judgement for $l_B$ comes from the soundness theorem. We don't know if this is the same judgement guaranteed by the refinement theorem, so it's not right to equate them.}\\

\noindent
\textbf{What we need to know: if $\Gamma \vdash \kwa{label}(u_B) : \type{\hat \tau_B}{\hat \varepsilon_B}$, then for *any* judgement $\Gamma \vdash u_B : \type{\tau_B}{\varepsilon_B}$, that $\hat \tau_B <: \tau_B$ and $\hat \varepsilon_B \subseteq \varepsilon_B$ (in general that's not true though, since you can just type $\hat \tau_B$ as $\top$ or some other type which isn't useful). }

\end{document}
