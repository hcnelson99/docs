\documentclass{llncs}

\usepackage{listings}
\usepackage{proof}
\usepackage{amssymb}
\usepackage[margin=.9in]{geometry}
\usepackage{amsmath}
\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage{enumitem}
\usepackage{filecontents}
\usepackage{calc}
\usepackage[linewidth=0.5pt]{mdframed}
\usepackage{changepage}
\allowdisplaybreaks

\usepackage{fancyhdr}
\renewcommand{\headrulewidth}{0pt}
\pagestyle{fancy}
 \fancyhf{}
\rhead{\thepage}

\lstset{tabsize=3, basicstyle=\ttfamily\small, commentstyle=\itshape\rmfamily, numbers=left, numberstyle=\tiny, language=java,moredelim=[il][\sffamily]{?},mathescape=true,showspaces=false,showstringspaces=false,columns=fullflexible,xleftmargin=5pt,escapeinside={(@}{@)}, morekeywords=[1]{objtype,module,import,let,in,fn,var,type,rec,fold,unfold,letrec,alloc,ref,application,policy,external,component,connects,to,meth,val,where,return,group,by,within,count,connect,with,attr,html,head,title,style,body,div,keyword,unit,def}}
\lstloadlanguages{Java,VBScript,XML,HTML}

\newcommand{\keywadj}[1]{\mathtt{#1}}
\newcommand{\keyw}[1]{\keywadj{#1}~}

\newcommand{\kw}[1]{\keyw{ #1 }}
\newcommand{\kwa}[1]{\keywadj{ #1 }}
\newcommand{\reftt}{\mathtt{ref}~}
\newcommand{\Reftt}{\mathtt{Ref}~}
\newcommand{\inttt}{\mathtt{int}~}
\newcommand{\Inttt}{\mathtt{Int}~}
\newcommand{\stepsto}{\leadsto}
\newcommand{\todo}[1]{\textbf{[#1]}}
\newcommand{\intuition}[1]{#1}
\newcommand{\hyphen}{\hbox{-}}

%\newcommand{\intuition}[1]{}

\newlist{pcases}{enumerate}{1}
\setlist[pcases]{
  label=\fbox{\textit{Case}}\protect\thiscase\textit{:}~,
  ref=\arabic*,
  align=left,
  labelsep=0pt,
  leftmargin=0pt,
  labelwidth=0pt,
  parsep=0pt
}
\newcommand{\pcase}[1][]{

  \if\relax\detokenize{#1}\relax
    \def\thiscase{}
  \else
    \def\thiscase{~\fbox{#1:}}
  \fi
  \item
}

\newcommand{\thm}[3]{
	\begin{large}
		\bf{#1}
	\end{large} \\\\
	\fbox{Statement.} ~ #2
	\fbox{Proof.}~ #3 \qed
}

\newcommand{\proofcase}[2]{
	\begin{adjustwidth}{1.5em}{0pt}
		\fbox{Case.}~~#1. \\ ~#2
	\end{adjustwidth}
}

\newcommand{\subcase}[1] {
	\begin{adjustwidth}{2.2em}{0pt}
		\underline{Subcase.} #1
	\end{adjustwidth}
}

\newcommand{\stmt}[1] {

\begin{adjustwidth}{2.5em}{0pt}
	#1
\end{adjustwidth}

}
\newcommand{\type}[2]{
	#1~\keyw{with} #2
}

\newcommand{\newd}[0]{
	\keywadj{new}_d~x \Rightarrow \overline{d = u}
}

\newcommand{\newsig}[0]{
	\keywadj{new}_\sigma~x \Rightarrow \overline{\sigma = l}
}

\begin{document}

\section{Grammar}

\[
\begin{array}{lll}

\begin{array}{lllr}

\rho & ::= & x & primitives\\
		& | & r \\
		&&\\
		
\tau_\rho & ::= & \{ r \} & primitive~types \\
		&&\\\\\\

e_u & ::= & \rho & deeply~unlabeled~progs. \\
 		& | & \kwa{new}_d~x \Rightarrow \overline{d = e_u} \\
 		& | & e_u.m(e_u)\\
 		& | & e_u.\pi\\
		&&\\

d & ::= & \kw{def} m(y:\tau_u):\tau_u & e_u \hyphen prog~decls.\\
		&&\\

\tau_u & ::= & \{ \overline{ d } \} & e_u \hyphen prog~types \\
	& | & \tau_\rho \\
	&&\\\\\\





e_l & ::= & \rho & deeply~labeled~progs. \\
	& | & \kwa{new}_\sigma~x \Rightarrow \overline{\sigma = e_l} \\
	& | & l.m(l) \\
	& | & l.\pi \\
	&&\\

\sigma & ::= & \kwa{def}~m(y : \tau_l) : \tau_l~\kw{with} \varepsilon & e_l \hyphen prog~decls. \\
	&&\\

\tau_l & ::= & \{ \bar \sigma \} & e_l \hyphen prog~types \\
	& | & \tau_\rho \\
	&&\\\\\\
	
	
	
	
	
	
	
	
	
e & ::= & \rho & progs. \\
	& | & e.m(e) \\
	& | & e.\pi \\
	& | & \kwa{new}_d~x \Rightarrow \overline{d = e_u} \\
	& | & \kwa{new}_\sigma~x \Rightarrow \overline{\sigma = e} \\
	&&\\
	
\tau & ::= & \tau_l & types \\
	& | & \tau_u \\
	&&\\
		
		
\end{array}
& ~~~~~~
&
\end{array}
\]

\noindent \textbf{Notes:}

\begin{itemize}
	\item $e_u$ programs are \textit{deeply unlabeled} programs: no labels appear in the source code (though label inference may be done by the type system).
	\item $e_l$ programs are \textit{deeply labeled} programs: everything in the source code is labeled.
	\item $e$ programs are the general form of a syntactically-correct program. They may contain a mixture of labeled and unlabeled parts. Any unlabeled parts must be deeply unlabeled, but labeled parts need not be deeply labeled. This means you can have unlabeled parts appearing inside labeled parts, but not vice versa.
	\item Any $e_l$ or $e_u$ term is also an $e$ term.
\end{itemize}


\section{Static Semantics}

\noindent
$\fbox{$\Gamma \vdash \rho : \tau$}$

\[
\begin{array}{c}

\infer[\textsc{($\rho$-Var)}]
	{\Gamma, x : \tau \vdash x : \tau}
	{}
~~~~~~~~~~
\infer[\textsc{($\rho$-Resource)}]
	{\Gamma, r : \{ r \} \vdash r : \{ r \}}
	{} \\[6ex]

\end{array}
\]

\noindent
$\fbox{$\Gamma \vdash \rho : \type{\tau}{\varepsilon}$}$

\[
\begin{array}{c}

\infer[\textsc{($\rho$-Var$_\varepsilon$)}]
	{\Gamma, x : \tau \vdash x : \type{\tau}{\varnothing}}
	{}
~~~~~~~~~~
\infer[\textsc{($\rho$-Resource$_\varepsilon$)}]
	{\Gamma, r : \{ r \} \vdash r : \type{\{ r \}}{\varnothing}}
	{} \\[6ex]

\end{array}
\]

\noindent
$\fbox{$\Gamma \vdash e_u : \tau_u$}$

\[
\begin{array}{c}
\infer[\textsc{($e_u$-New)}]
	{\Gamma \vdash~\kwa{new}_d~x \Rightarrow \overline{ d = e_u } : \{ \overline{d} \}}
	{\Gamma, x : \{ \overline{d} \} \vdash \overline{d = e_u}~\keywadj{OK}}
~~~~~~~~~~
\infer[\textsc{($e_u$-OperCall)}]
	{\Gamma \vdash e_u.\pi : \keywadj{Unit}}
	{\Gamma \vdash e_u : \{ r \}} \\[5ex]

\infer[\textsc{($e_u$-MethCall)}]
	{\Gamma \vdash e_{u, 1}.m(e_{u, 2}) : \tau_{u, 3}}
	{\Gamma \vdash e_{u, 1} : \{ \overline{ d }\} &~~~ \keyw{def} m(y : \tau_{u, 2}) : \tau_{u, 3} \in \{ \overline{d} \} &~~~  \Gamma \vdash e_{u, 2} : \tau_{u, 2} }\\[6ex]

\end{array}
\]

\noindent
$\fbox{$\Gamma \vdash d = e_u~\keyw{OK}$}$
\[
\begin{array}{c}
\infer[\textsc{($e_u$-ValidImpl)}]
	{\Gamma \vdash d = e_u~\keywadj{OK}}
	{d = \keyw{def} m(y : \tau_{u, 2}) : \tau_{u, 3} & \Gamma, y : \tau_{u, 2} \vdash e_u : \tau_{u, 3}}
	\\[5ex]
\end{array}
\]

\noindent
\fbox{$\Gamma \vdash e : \tau~\keyw{with} \varepsilon$}

\[
\begin{array}{c}

\infer[\textsc{($e$-NewObj)}]
	{\Gamma \vdash \kwa{new}_\sigma~x \Rightarrow \overline{\sigma = e} : \{ \bar \sigma \}~\keyw{with} \varnothing}
	{\Gamma,~x : \{ \bar \sigma \} \vdash \overline{\sigma = e}~\keywadj{OK}} ~~~~~~

\infer[\textsc{($e$-OperCall)}]
	{\Gamma \vdash e_1.\pi : \keyw{Unit} \keyw{with} \{ r.\pi \} \cup \varepsilon_1}
	{\Gamma \vdash e_1 : \{ r \}~ \keyw{with} \varepsilon_1} \\[5ex]
	
\infer[\textsc{($e$-MethCall)}]
	{\Gamma \vdash e_{1}.m_i(e_{2}):\tau_{3}~\keyw{with} \varepsilon_1 \cup \varepsilon_2 \cup \varepsilon_3}
	{\Gamma \vdash e_{1} : \{ \bar \sigma \}~\keyw{with} \varepsilon_1 & \Gamma \vdash e_{2} : \tau_{2}~\keyw{with} \varepsilon_2 & \sigma = \keyw{def} m(y:\tau_{2}):\tau_{3}~\keyw{with} \varepsilon_3 \in \overline{\sigma = e}} \\[5ex]
\end{array}
\]

\noindent
$\fbox{$\Gamma \vdash \sigma = e~\keyw{OK}$}$

\[
\begin{array}{c}
\infer[\textsc{($\varepsilon$-ValidImpl)}]
	{\Gamma \vdash \sigma = e~\keywadj{OK}}
	{\Gamma,~y:\tau_{2} \vdash e: \tau_{3}~\keyw{with} \varepsilon_3 & \sigma = \keyw{def} m(y:\tau_{2}):\tau_{3}~\keyw{with} \varepsilon_3} \\[5ex]
\end{array}
\]



\noindent
$\fbox{$\Gamma \vdash \tau <: \tau$}$

\[
\begin{array}{c}

\infer[\textsc{(St-Reflexive)}]
	{\Gamma \vdash \tau <: \tau}
	{}
	
~~~~~~~~~~

	\infer[\textsc{(St-Transitive)}]
	{\Gamma \vdash \tau_1 <: \tau_3}
	{\Gamma \vdash \tau_1 <: \tau_2 & \Gamma \vdash \tau_2 <: \tau_3}\\[5ex]

\infer[\textsc{(St-Subsumption)}]
	{\Gamma \vdash e : \tau_2}
	{\Gamma \vdash e : \tau_1 & \Gamma \vdash \tau_1 <: \tau_2} 
	
	~~~~~~~~~~
	
\infer[\textsc{(St-EffectTypes)}]
	{ \Gamma \vdash \type{\tau_1}{\varepsilon_1} <: \type{\tau_2}{\varepsilon_2}}
	{ \Gamma \vdash \tau_1 <: \tau_2 ~~~~~~ \varepsilon_1 \subseteq \varepsilon_2} \\[5ex]

\infer[\textsc{(St-Permutation$_\sigma$)}]
	{\Gamma \vdash \{ \bar \sigma \}_1 <: \{ \bar \sigma \}_2 }
	{\Gamma \vdash \{ \bar \sigma \}_1 $ is a permutation of $ \{ \bar \sigma \}_2}
	
	~~~~~~~~~~
	
\infer[\textsc{(St-Permutation$_d$)}]
	{\Gamma \vdash \{ \bar d \}_1 <: \{ \bar d \}_2 }
	{\Gamma \vdash \{ \bar d \}_1 $ is a permutation of $ \{ \bar d \}_2}
	
	\\[5ex]
	
	~~~~~~~~~~

\infer[\textsc{(St-Depth$_\sigma$)}]
	{ \Gamma \vdash \{ \sigma_i~^{i \in 1..n} \} <: \{ \sigma_j~^{j \in 1..n} \} }
	{ \Gamma \vdash \sigma_i <:: \sigma_j }
	
	~~~~~~~~~~
	
\infer[\textsc{(St-Depth$_d$)}]
	{ \Gamma \vdash \{ d_i~^{i \in 1..n} \} <: \{ d_j~^{j \in 1..n} \} }
	{ \Gamma \vdash d_i <:: d_j }
	
	\\[5ex]
	
\infer[\textsc{(St-Width$_\sigma$)}]
	{ \Gamma \vdash \{ \sigma_i~^{i \in 1..n+k} \} <: \{ \sigma_i~^{i \in 1..n} \} }
	{n,k \geq 0}
	
~~~~~
  
\infer[\textsc{(St-Width$_d$)}]
	{ \Gamma \vdash \{ d_i~^{i \in 1..n+k} \} <: \{ d_i~^{i \in 1..n} \} }
	{n,k \geq 0}
	
		\\[5ex]
	
	
\end{array}
\]


\noindent
$\fbox{$\Gamma \vdash \sigma <:: \sigma$}$

\[
\begin{array}{c}

\infer[\textsc{(St-Method$_\sigma$)}]
	{ \Gamma \vdash \sigma_i <:: \sigma_j }
{{\def\arraystretch{1.6}
  \begin{array}{c}
\sigma_i = \kw{def} m_A(y : \tau_1) : \type{\tau_2}{\varepsilon_A}
~~~~~~\sigma_j = \kw{def} m_B(y : \tau_1') : \type{\tau_2'}{\varepsilon_B} \\
\Gamma \vdash \tau_1' <: \tau_1 ~~~~~~ \Gamma \vdash \tau_2 <: \tau_2' ~~~~~~ \varepsilon_A \subseteq \varepsilon_B
  \end{array}}} \\[5ex]
 
\end{array}
\]



\noindent
$\fbox{$\Gamma \vdash d <:: d$}$

\[
\begin{array}{c}

\infer[\textsc{(St-Method$_d$)}]
	{ \Gamma \vdash d_i <:: d_j }
{{\def\arraystretch{1.6}
  \begin{array}{c}
d_i = \kw{def} m_A(y : \tau_1) : \tau_2 ~~~~~~ d_j = \kw{def} m_B(y : \tau_1') : \tau_2' \\
\Gamma \vdash \tau_1' <: \tau_1 ~~~~~~ \Gamma \vdash \tau_2 <: \tau_2'
  \end{array}}} \\[5ex]

\end{array}
\]

\noindent \textbf{Notes:}
\begin{itemize}
	\item A good choice of $\Gamma'$ for \textsc{$e_u$-New$_\varepsilon$} is the intersection of $\Gamma$ with the free variables in the object.
	\item By convention we use $\varepsilon_c$ to denote the output of the $\keywadj{effects}$ function.
\end{itemize}

\section{Definition: $\keywadj{effects}$ Function}

\noindent
The $\keywadj{effects}$ function returns the set of effects captured in a particular context.

\begin{itemize}
	\item $\keywadj{effects}(\varnothing) = \varnothing$
	\item $\keywadj{effects}(\Gamma, x : \tau) = \keywadj{effects}(\Gamma) \cup \keywadj{effects}(\tau)$
	\item $\keywadj{effects}(\{\bar r\}) = \{ (r, \pi) \mid r \in \bar r, \pi \in \Pi \}$
	\item $\keywadj{effects}(\{\bar \sigma\}) = \bigcup_{\sigma \in \bar \sigma}~\keywadj{effects}(\sigma)$
	\item $\keywadj{effects}(\{\bar d\}) = \bigcup_{d \in \bar d}~\keywadj{effects}(d)$
	\item $\keywadj{effects}(d~\keyw{with} \varepsilon) = \varepsilon \cup \keywadj{effects}(d)$
	\item $\keywadj{effects}(\keywadj{def~m}(x : \tau_1) : \tau_2) = \keywadj{effects}(\tau_2)$
	\item $\keywadj{effects}(\{\bar d ~\keyw{captures} \varepsilon_c\}) = \varepsilon_c$
\end{itemize}

\noindent \textbf{Notes:}

\begin{enumerate}
	\item The function is monotonic: if $\Gamma_1 \subseteq \Gamma_2$, then $\kwa{effects}(\Gamma_1) \subseteq \kwa{effects}(\Gamma_2)$.
\end{enumerate}


\section{Dynamic Semantics}

~\\
\noindent
\fbox{$e_u \longrightarrow e_u~|~\varepsilon$}

\[
\begin{array}{c}

	\infer[\textsc{(E-MethCall1)}]
		{e_{u, 1}.m(e_{u, 2}) \longrightarrow e_{u, 1}'.m(e_{u, 2})~|~\varepsilon}
		{e_{u, 1} \longrightarrow e_{u, 1}'~|~\varepsilon} \\[5ex]

	\infer[\textsc{(E-MethCall2)}]
		{v_{u, 1}.m(e_{u, 2}) \longrightarrow v_{u, 1}.m(e_{u, 2}')~|~\varepsilon}
		{v_{u, 1} = \newsig & e_{u, 2} \longrightarrow e_{u, 2}'~|~\varepsilon} \\[5ex]
		
	\infer[\textsc{(E-MethCall3)}]
		{v_1.m(v_2)
			\longrightarrow
		 [v_1/x, v_2/y]e_u~|~\varnothing}
  		{v_1 = \newd & \keywadj{def~m}(y: \tau_1) : \tau_2 = e_u \in \overline {d = e_u}} \\[5ex]

	\infer[\textsc{(E-OperCall1)}]
		{e_{u, 1}.\pi
			\longrightarrow
		 e_{u, 1}'.\pi~|~\varepsilon}
		{e_{u, 1} \longrightarrow e_{u, 1}'~|~\varepsilon}
~~~~~~

			\infer[\textsc{(E-OperCall2)}]
		{r.\pi
			\longrightarrow
		 \keywadj{unit}~|~\{r.\pi\}}
		{} \\[5ex]
			
\end{array}
\]
\noindent
\fbox{$e_u \longrightarrow_* e_u~|~\varepsilon$}

\[
\begin{array}{c}

	\infer[\textsc{(E-MultiStep1)}]
	{e_u \longrightarrow_* e_u~|~\varnothing}
	{} ~~~~~~~~
	
	\infer[\textsc{(E-MultiStep2)}]
	{e_u \longrightarrow_* e_u'~|~\varepsilon}
	{e_u \longrightarrow e_u'~|~\varepsilon} \\[5ex]

	\infer[\textsc{(E-MultiStep3)}]
	{e_u \longrightarrow_* e_u''~|~\varepsilon_1 \cup \varepsilon_2}
	{e_u \longrightarrow_* e_u'~|~\varepsilon_1 & e' \longrightarrow_* e''~|~\varepsilon_2}

\end{array}
\]

\noindent \textbf{Notes:}
\begin{itemize}
	\item The runtime only operates on (deeply) unlabeled expressions. You may think of a compiler as stripping all the effect labels from a program before execution.
\end{itemize}
















\section{Lemma (Canonical Forms)}

TODO














\section{Definition ($\keywadj{substitution}$)}

TODO













\section{Lemma (Substitution)}

\textbf{Lemma. } Suppose the following is true: 

\begin{enumerate}
	\item $\Gamma, z : \tau' \vdash e : \tau~\keyw{with} \varepsilon$
	\item $\Gamma \vdash e' : \tau'~\keyw{with} \varepsilon'$
\end{enumerate}
	
	\noindent
Then $\Gamma \vdash [e'/z]e : \tau~\keyw{with} \varepsilon$.\\

\noindent
\textbf{Proof.} TODO (Should be same as the proof in previous grammar, just need to convert everything to new grammar)






\section{Definition ($\keywadj{label}$)}
A program may be converted into a fully-labeled program. This is a function from $e$-terms to $e_l$-terms. It is always defined relative to some $\Gamma$, which is usually clear from context. The process is well-defined on $e$ if $\Gamma \vdash e : \type{\tau}{\varepsilon}$. Then $\kwa{label}$ is defined below.

\begin{enumerate}
	\item $\kwa{label}(\rho) = \rho$
	\item $\kwa{label}(e_1.\pi) = \kwa{label}(e_1).\pi$
	\item $\kwa{label}(e_1.m(e_2)) = \kwa{label}(e_1).m(\kwa{label}(e_2))$
	\item $\kwa{label}(\kwa{new}_d~x \Rightarrow \overline{d = e_u}) = \kwa{new}_\sigma~x \Rightarrow \overline{ \kwa{label \hyphen decl}(d = e_u) }$
	\item $\kwa{label}(\kwa{new}_\sigma~x \Rightarrow \overline{\sigma = e}) = \kwa{new}_\sigma~x \Rightarrow \overline{\sigma = \kwa{label}(e)}$
\end{enumerate}

\noindent
The helper function $\kwa{label \hyphen decl}$ works by labeling each declaration with what it captures in the context $\Gamma$. We abbreviate this as $\kwa{effects}(\Gamma \cap \kwa{freevars}(e))$. The helper is defined below.

\begin{enumerate}
  \setcounter{enumi}{4}
  \item $\kwa{label \hyphen decl}(d = u) = d~\kw{with} \kwa{effects}(\Gamma \cap \kwa{freevars}(e)) = \kwa{label}(u)$
\end{enumerate}

\noindent \textbf{Notes:}
\begin{itemize}
	\item The image of $\kwa{label}(e_u)$ is an $e_l$-term (proof by induction on definition).
	\item $e_u$ is a value $\iff \kwa{label}(e_u)$ is a value.
	\item We can define $\varnothing \cap \kwa{freevars}(e)$ as $\varnothing$, and $(\Gamma, x : \tau) \cap \kwa{freevars}(e)$ as $(\Gamma \cap \kwa{freevars}(e)) \cup (\{ x \} \cap \kwa{freevars}(e))$.
\end{itemize}





\section{Definition ($\keywadj{unlabel}$)}

The inverse of $\kwa{label}$. TODO






\section{Theorem ($\kwa{label}$ and $\kwa{sub}$ Commute)}

TODO






\section{Theorem (Soundness)}

\textbf{Theorem.} Suppose $\Gamma \vdash e_A : \tau_A$ and $e_A \longrightarrow e_B~|~\varepsilon$. The following are true:

	\begin{enumerate}
	\item $\Gamma \vdash e_B : \tau_B$
	\item $\tau_B <: \tau_A$
	\item $\Gamma \vdash \kwa{label}(e_A) : \type{\hat \tau_A}{\varepsilon_A}$
	\item $\Gamma \vdash \kwa{label}(e_B) : \type{\hat \tau_B}{\varepsilon_B}$
	\item $\varepsilon \cup \varepsilon_B = \varepsilon_A$
	\end{enumerate}

\noindent
\textbf{Proof.} 

\end{document}
