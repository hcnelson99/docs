\documentclass{llncs}

\usepackage{listings}
\usepackage{proof}
\usepackage{amssymb}
\usepackage[margin=.9in]{geometry}
\usepackage{amsmath}
\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage{enumitem}
\usepackage{filecontents}
\usepackage{calc}
\usepackage[linewidth=0.5pt]{mdframed}
\usepackage{changepage}
\usepackage{tabto}
\allowdisplaybreaks

\usepackage{fancyhdr}
\renewcommand{\headrulewidth}{0pt}
\pagestyle{fancy}
 \fancyhf{}
\rhead{\thepage}

\lstset{tabsize=3, basicstyle=\ttfamily\small, commentstyle=\itshape\rmfamily, numbers=left, numberstyle=\tiny, language=java,moredelim=[il][\sffamily]{?},mathescape=true,showspaces=false,showstringspaces=false,columns=fullflexible,xleftmargin=5pt,escapeinside={(@}{@)}, morekeywords=[1]{objtype,module,import,let,in,fn,var,type,rec,fold,unfold,letrec,alloc,ref,application,policy,external,component,connects,to,meth,val,where,return,group,by,within,count,connect,with,attr,html,head,title,style,body,div,keyword,unit,def}}
\lstloadlanguages{Java,VBScript,XML,HTML}

\newcommand{\keywadj}[1]{\mathtt{#1}}
\newcommand{\keyw}[1]{\keywadj{#1}~}

\newcommand{\kw}[1]{\keyw{ #1 }}
\newcommand{\kwa}[1]{\keywadj{ #1 }}
\newcommand{\reftt}{\mathtt{ref}~}
\newcommand{\Reftt}{\mathtt{Ref}~}
\newcommand{\inttt}{\mathtt{int}~}
\newcommand{\Inttt}{\mathtt{Int}~}
\newcommand{\stepsto}{\leadsto}
\newcommand{\todo}[1]{\textbf{[#1]}}
\newcommand{\intuition}[1]{#1}
\newcommand{\hyphen}{\hbox{-}}

%\newcommand{\intuition}[1]{}

\newlist{pcases}{enumerate}{1}
\setlist[pcases]{
  label=\fbox{\textit{Case}}\protect\thiscase\textit{:}~,
  ref=\arabic*,
  align=left,
  labelsep=0pt,
  leftmargin=0pt,
  labelwidth=0pt,
  parsep=0pt
}
\newcommand{\pcase}[1][]{

  \if\relax\detokenize{#1}\relax
    \def\thiscase{}
  \else
    \def\thiscase{~\fbox{#1:}}
  \fi
  \item
}

\newcommand{\thm}[3]{
	\begin{large}
		\bf{#1}
	\end{large} \\\\
	\fbox{Statement.} ~ #2
	\fbox{Proof.}~ #3 \qed
}

\newcommand{\proofcase}[2]{
	\begin{adjustwidth}{1.5em}{0pt}
		\fbox{Case.}~~#1. \\ ~#2
	\end{adjustwidth}
}

\newcommand{\subcase}[1] {
	\begin{adjustwidth}{2.2em}{0pt}
		\underline{Subcase.} #1
	\end{adjustwidth}
}

\newcommand{\stmt}[1] {

\begin{adjustwidth}{2.5em}{0pt}
	#1
\end{adjustwidth}

}
\newcommand{\type}[2]{
	#1~\keyw{with} #2
}

\newcommand{\newd}[0]{
	\keywadj{new}_d~x \Rightarrow \overline{d = e}
}

\newcommand{\newsig}[0]{
	\keywadj{new}_\sigma~x \Rightarrow \overline{\sigma = e}
}


\begin{document}

\section{Grammar}

\[
\begin{array}{lll}

\begin{array}{lllr}

e & ::= & x & expressions \\
  		& | & r \\
		& | & \keywadj{new}_\sigma~x \Rightarrow \overline{\sigma = e} \\
 		& | & \keywadj{new}_d~x \Rightarrow \overline{d = e} \\
 		& | & e.m(e)\\
 		& | & e.\pi\\
		&&\\

\tau & ::= & \{ \bar \sigma \} & types \\
		& | & \{ r \} \\
		& | & \{ \bar d \} \\
		& | & \{ \bar d ~\keyw{captures} \varepsilon \} \\
		&&\\
		
\sigma & ::= & d~\keyw{with}\varepsilon  & labeled~ decls.\\
		&&\\

d & ::= & \keyw{def} m(x:\tau):\tau & unlabeled~decls.\\
		&&\\

\end{array}
& ~~~~~~
&
\end{array}
\]

\noindent \textbf{Notes:}
\begin{itemize}
	\item $\sigma$ is a declaration with its effects labeled; $d$ a declaration without.
	\item $\keywadj{new}_\sigma$ is for creating annotated objects; $\keywadj{new}_d$ for unannotated objects.
	\item $\{ \bar \sigma \}$ is the type of an annotated object; $\{ \bar d \}$ of unannotated objects.
	\item $\{ \bar d ~\keyw{captures} \varepsilon \}$ is a special kind of type that doesn't appear in source programs. $\varepsilon$ is an upper-bound on the effects captured by $\{ \bar d \}$.
\end{itemize}

\section{Semantics}

\subsection{Static Semantics}

\noindent
$\fbox{$\Gamma \vdash e : \tau$}$

\[
\begin{array}{c}
\infer[\textsc{(T-Var)}]
	{\Gamma,~x : \tau \vdash x : \tau}
	{}
~~~~~~~~~~
\infer[\textsc{(T-Resource)}]
	{\Gamma,~r : \{ r \} \vdash r : \{ r \}}
	{} \\[5ex]
~~~~~~~~~~
\infer[\textsc{(T-OperCall)}]
	{\Gamma \vdash e_1.\pi : \keywadj{Unit}}
	{\Gamma \vdash e_1 : \{ r \}} \\[5ex]
~~~~~~~~~~
\infer[\textsc{(T-MethCall$_\sigma$)}]
	{\Gamma \vdash e_1.m(e_2) : \tau_3}
	{\Gamma \vdash e_1 : \{ \bar \sigma \} & \keyw{def} m(y : \tau_2) : \tau_3~\keyw{with} \varepsilon_3 \in \{ \bar \sigma \} &  \Gamma \vdash e_2 : \tau_2 }\\[5ex]
~~~~~~~~~~
\infer[\textsc{(T-MethCall$_d$)}]
	{\Gamma \vdash e_1.m(e_2) : \tau_3}
	{\Gamma \vdash e_1 : \{ \bar d\} & \keyw{def} m(y : \tau_2) : \tau_3 \in \{ \bar d \} &  \Gamma \vdash e_2 : \tau_2 }\\[5ex]
~~~~~~~~~~

~~~~~~~~~~
\infer[\textsc{(T-New$_\sigma$)}]
	{\Gamma \vdash~\keywadj{new}_\sigma~x \Rightarrow \overline{\sigma = e} : \{ \bar \sigma \}}
	{\Gamma, x : \{ \bar \sigma \} \vdash \overline{\sigma = e}~\keywadj{OK}}
~~~~~~~~~~
\infer[\textsc{(T-New$_d$)}]
	{\Gamma \vdash~\keywadj{new}_d~x \Rightarrow \overline{d = e} : \{ \bar d \}}
	{\Gamma, x : \{ \bar d \} \vdash \overline{d = e}~\keywadj{OK}}\\[5ex]
\end{array}
\]

\noindent
$\fbox{$\Gamma \vdash d = e~\keyw{OK}$}$
\[
\begin{array}{c}
\infer[\textsc{($\varepsilon$-ValidImpl$_d$)}]
	{\Gamma \vdash d = e~\keywadj{OK}}
	{d = \keyw{def} m(y : \tau_2) : \tau_3 & \Gamma, y : \tau_2 \vdash e : \tau_3}
	\\[5ex]
\end{array}
\]

\noindent
$\fbox{$\Gamma \vdash \sigma = e~\keyw{OK}$}$

\[
\begin{array}{c}
\infer[\textsc{($\varepsilon$-ValidImpl$_\sigma$)}]
	{\Gamma \vdash \sigma = e~\keywadj{OK}}
	{\Gamma,~y:\tau_2 \vdash e: \tau_3~\keyw{with} \varepsilon_3 & \sigma = \keyw{def} m(y:\tau_2):\tau_3~\keyw{with} \varepsilon_3} \\[5ex]
\end{array}
\]


\noindent
\fbox{$\Gamma \vdash e : \tau~\keyw{with} \varepsilon$}

\[
\begin{array}{c}
	\infer[\textsc{($\varepsilon$-Var)}]
  {\Gamma,~x:\tau \vdash x: \type{\tau}{\varnothing} }
  {} 
~~~~~~~~~~
\infer[\textsc{($\varepsilon$-Resource)}]
  {\Gamma,~r :\{\bar r\} \vdash r: \type{   \{ \bar r \}  }{\varnothing}}
  {} \\[5ex]

\infer[\textsc{($\varepsilon$-NewObj)}]
	{\Gamma \vdash \newsig : \{ \bar \sigma \}~\keyw{with} \varnothing}
	{\Gamma,~x : \{ \bar \sigma \} \vdash \overline{\sigma = e}~\keywadj{OK}} ~~~~~~

\infer[\textsc{($\varepsilon$-OperCall)}]
	{\Gamma \vdash e_1.\pi : \keyw{Unit} \keyw{with} \{ \bar r.\pi \} \cup \varepsilon_1}
	{\Gamma \vdash e_1 : \{ \bar r \}~ \keyw{with} \varepsilon_1} \\[5ex]
	
\infer[\textsc{($\varepsilon$-MethCall)}]
	{\Gamma \vdash e_1.m_i(e_2):\tau_3~\keyw{with} \varepsilon_1 \cup \varepsilon_2 \cup \varepsilon_3}
	{\Gamma \vdash e_1 : \{ \bar \sigma \}~\keyw{with} \varepsilon_1 & \Gamma \vdash e_2 : \tau_2~\keyw{with} \varepsilon_2 & \sigma_i = \keyw{def} m_i(y:\tau_2):\tau_3~\keyw{with} \varepsilon_3} \\[5ex]
	
\infer[\textsc{(C-NewObj)}]
	{\Gamma \vdash~\keywadj{new}_d~x \Rightarrow \overline{d = e} : \{  \bar d~\keyw{captures} \varepsilon_c \} ~\keyw{with} \varnothing }
	{\varepsilon_c = \keywadj{effects}(\Gamma') & \Gamma' \subseteq \Gamma & \Gamma', x : \{ \bar d~\keyw {captures} \varepsilon_c \} \vdash \overline{d = e}~\keyw{OK}} \\[5ex]
	
\infer[\textsc{(C-MethCall)}]
	{\Gamma \vdash e_1.m_i(e_2) : \tau_3~ \keyw{with} \varepsilon_1 \cup \varepsilon_2 \cup \keywadj{effects}(\tau_2) \cup \varepsilon_c}
	{\Gamma \vdash e_1 : \{ \bar d~\keyw{captures} \varepsilon_c \}~\keyw{with} \varepsilon_1 & \Gamma \vdash e_2:\tau_2~\keyw{with} \varepsilon_2&d_i =~\keyw{def} m_i(y:\tau_2):\tau_3 } \\[5ex]

\end{array}
\]


\noindent
$\fbox{$\Gamma \vdash \tau <: \tau$}$

\[
\begin{array}{c}

\infer[\textsc{(St-Reflexive)}]
	{\Gamma \vdash \tau <: \tau}
	{}
	
~~~~~~~~~~

	\infer[\textsc{(St-Transitive)}]
	{\Gamma \vdash \tau_1 <: \tau_3}
	{\Gamma \vdash \tau_1 <: \tau_2 & \Gamma \vdash \tau_2 <: \tau_3}\\[5ex]

\infer[\textsc{(St-Subsumption)}]
	{\Gamma \vdash e : \tau_2}
	{\Gamma \vdash e : \tau_1 & \Gamma \vdash \tau_1 <: \tau_2} 
	
	~~~~~~~~~~
	
\infer[\textsc{(St-EffectTypes)}]
	{ \Gamma \vdash \type{\tau_1}{\varepsilon_1} <: \type{\tau_2}{\varepsilon_2}}
	{ \Gamma \vdash \tau_1 <: \tau_2 ~~~~~~ \varepsilon_1 \subseteq \varepsilon_2} \\[5ex]

\infer[\textsc{(St-Permutation$_\sigma$)}]
	{\Gamma \vdash \{ \bar \sigma \}_1 <: \{ \bar \sigma \}_2 }
	{\Gamma \vdash \{ \bar \sigma \}_1 $ is a permutation of $ \{ \bar \sigma \}_2}
	
	~~~~~~~~~~
	
\infer[\textsc{(St-Permutation$_d$)}]
	{\Gamma \vdash \{ \bar d \}_1 <: \{ \bar d \}_2 }
	{\Gamma \vdash \{ \bar d \}_1 $ is a permutation of $ \{ \bar d \}_2}
	
	\\[5ex]
	
	~~~~~~~~~~

\infer[\textsc{(St-Depth$_\sigma$)}]
	{ \Gamma \vdash \{ \sigma_i~^{i \in 1..n} \} <: \{ \sigma_j~^{j \in 1..n} \} }
	{ \Gamma \vdash \sigma_i <:: \sigma_j }
	
	~~~~~~~~~~
	
\infer[\textsc{(St-Depth$_d$)}]
	{ \Gamma \vdash \{ d_i~^{i \in 1..n} \} <: \{ d_j~^{j \in 1..n} \} }
	{ \Gamma \vdash d_i <:: d_j }
	
	\\[5ex]
	
\infer[\textsc{(St-Width$_\sigma$)}]
	{ \Gamma \vdash \{ \sigma_i~^{i \in 1..n+k} \} <: \{ \sigma_i~^{i \in 1..n} \} }
	{n,k \geq 0}
	
~~~~~
  
\infer[\textsc{(St-Width$_d$)}]
	{ \Gamma \vdash \{ d_i~^{i \in 1..n+k} \} <: \{ d_i~^{i \in 1..n} \} }
	{n,k \geq 0}
	
		\\[5ex]
	
	
\end{array}
\]


\noindent
$\fbox{$\Gamma \vdash \sigma <:: \sigma$}$

\[
\begin{array}{c}

\infer[\textsc{(St-Method$_\sigma$)}]
	{ \Gamma \vdash \sigma_i <:: \sigma_j }
{{\def\arraystretch{1.6}
  \begin{array}{c}
\sigma_i = \kw{def} m_A(y : \tau_1) : \type{\tau_2}{\varepsilon_A}
~~~~~~\sigma_j = \kw{def} m_B(y : \tau_1') : \type{\tau_2'}{\varepsilon_B} \\
\Gamma \vdash \tau_1' <: \tau_1 ~~~~~~ \Gamma \vdash \tau_2 <: \tau_2' ~~~~~~ \varepsilon_A \subseteq \varepsilon_B
  \end{array}}} \\[5ex]
 
\end{array}
\]



\noindent
$\fbox{$\Gamma \vdash d <:: d$}$

\[
\begin{array}{c}

\infer[\textsc{(St-Method$_d$)}]
	{ \Gamma \vdash d_i <:: d_j }
{{\def\arraystretch{1.6}
  \begin{array}{c}
d_i = \kw{def} m_A(y : \tau_1) : \tau_2 ~~~~~~ d_j = \kw{def} m_B(y : \tau_1') : \tau_2' \\
\Gamma \vdash \tau_1' <: \tau_1 ~~~~~~ \Gamma \vdash \tau_2 <: \tau_2'
  \end{array}}} \\[5ex]

\end{array}
\]

\noindent \textbf{Notes:}

\begin{itemize}
	\item This system includes all the rules from the fully-annotated system.
	\item The \textsc{T} rules do standard typing of objects, without any effect analysis. Their sole purpose is so $\varepsilon$-ValidImpl$_d$ can be applied. \textbf{We are assuming the T-rules on their own are sound}.
	\item In \textsc{C-NewObj}, $\Gamma'$ is intended to be some subcontext of the current $\Gamma$. The object is labelled as capturing the effects in $\Gamma'$ (exact definition of $\kwa{effects}$ in the next section).
	\item In $\textsc{C-NewObj}$ we must add $\keywadj{effects}(\tau_2)$ to the static effects of the object, because the method body will have authority over the resources captured by $\tau_2$ (the type of the argument passed into the method).
	\item A good choice of $\Gamma'$ would be $\Gamma$ restricted to the free variables in the object definition.
	\item By convention we'll use $\varepsilon_c$ to denote the output of the $\keywadj{effects}$ function.
\end{itemize}

\subsection{$\keywadj{effects}$ Function}

\noindent
The $\keywadj{effects}$ function returns the set of effects captured in a particular context.

\begin{itemize}
	\item $\keywadj{effects}(\varnothing) = \varnothing$
	\item $\keywadj{effects}(\Gamma, x : \tau) = \keywadj{effects}(\Gamma) \cup \keywadj{effects}(\tau)$
	\item $\keywadj{effects}(\{\bar r\}) = \{ (r, \pi) \mid r \in \bar r, \pi \in \Pi \}$
	\item $\keywadj{effects}(\{\bar \sigma\}) = \bigcup_{\sigma \in \bar \sigma}~\keywadj{effects}(\sigma)$
	\item $\keywadj{effects}(\{\bar d\}) = \bigcup_{d \in \bar d}~\keywadj{effects}(d)$
	\item $\keywadj{effects}(d~\keyw{with} \varepsilon) = \varepsilon \cup \keywadj{effects}(d)$
	\item $\keywadj{effects}(\keywadj{def~m}(x : \tau_1) : \tau_2) = \keywadj{effects}(\tau_2)$
	\item $\keywadj{effects}(\{\bar d ~\keyw{captures} \varepsilon_c\}) = \varepsilon_c$
\end{itemize}

\section{Dynamic Semantics}

~\\
\noindent
\fbox{$e \longrightarrow e~|~\varepsilon$}

\[
\begin{array}{c}

	\infer[\textsc{(E-MethCall1)}]
		{e_1.m(e_2) \longrightarrow e_1'.m(e_2)~|~\varepsilon}
		{e_1 \longrightarrow e_1'~|~\varepsilon} \\[5ex]

	\infer[\textsc{(E-MethCall2$_{\sigma}$)}]
		{v_1.m(e_2) \longrightarrow v_1.m(e_2')~|~\varepsilon}
		{v_1 = \newsig & e_2 \longrightarrow e_2'~|~\varepsilon} ~~~~~~
		
	\infer[\textsc{(E-MethCall2$_d$)}]
		{v_1.m(e_2) \longrightarrow v_1.m(e_2')~|~\varepsilon}
		{v_1 = \newd & e_2 \longrightarrow e_2'~|~\varepsilon}\\[5ex]
				
	\infer[\textsc{(E-MethCall3$_{\sigma}$)}]
		{v_1.m(v_2)
			\longrightarrow
		 [v_1/x, v_2/y]e~|~\varnothing}
  		{v_1 = \newsig & \keywadj{def~m}(y: \tau_1) : \tau_2~\keyw{with} \varepsilon = e \in \overline {\sigma = e}} \\[5ex]

	\infer[\textsc{(E-MethCall3$_d$)}]
		{v_1.m(v_2)
			\longrightarrow
		 [v_1/x, v_2/y]e~|~\varnothing}
  		{v_1 = \newd & \keywadj{def~m}(y: \tau_1) : \tau_2 = e \in \overline {d = e}} \\[5ex]

	\infer[\textsc{(E-OperCall1)}]
		{e_1.\pi
			\longrightarrow
		 e_1'.\pi~|~\varepsilon}
		{e_1 \longrightarrow e_1'~|~\varepsilon}
~~~~~~

			\infer[\textsc{(E-OperCall2)}]
		{r.\pi
			\longrightarrow
		 \keywadj{unit}~|~\{r.\pi\}}
		{} \\[5ex]
			
\end{array}
\]
\noindent
\fbox{$e \longrightarrow_* e~|~\varepsilon$}

\[
\begin{array}{c}

	\infer[\textsc{(E-MultiStep1)}]
	{e \longrightarrow_* e~|~\varnothing}
	{} ~~~~~~~~
	
	\infer[\textsc{(E-MultiStep2)}]
	{e \longrightarrow_* e'~|~\varepsilon}
	{e \longrightarrow e'~|~\varepsilon} \\[5ex]

	\infer[\textsc{(E-MultiStep3)}]
	{e \longrightarrow_* e''~|~\varepsilon_1 \cup \varepsilon_2}
	{e \longrightarrow_* e'~|~\varepsilon_1 & e' \longrightarrow_* e''~|~\varepsilon_2}

\end{array}
\]

\noindent \textbf{Notes:}
\begin{itemize}
	\item \textsc{E-MethCall2$_d$} and \textsc{E-MethCall2$_\sigma$} are really doing the same thing, but one applies to labeled objects (the $\sigma$ version) and the other to unlabeled objects. Same goes for \textsc{E-MethCall3$_\sigma$} and \textsc{E-MethCall3$_d$}.
	\item \textsc{E-MethCall1} can be used for both labeled and unlabeled objects.
\end{itemize}

\section{Proofs}

In this section we work towards a proof of soundness. \\

\thm{Lemma 4.1. (Canonical Forms)}
{Suppose $e$ is a value. The following are true:
	\begin{itemize}
	\item If $\Gamma \vdash e : \type{ \{ \bar r \} }{\varepsilon} $, then $e = r$ for some resource $r$.
	\item If $\Gamma \vdash e : \type{ \{ \bar \sigma \}}{\varepsilon}$, then $e = \newsig$.
	\item If $\Gamma \vdash e : \{ \bar d~\keyw{captures} \varepsilon_c \}~ \keyw{with} \varepsilon$, then $e = \keywadj{new}_{d}~x \Rightarrow \overline{ d = e }$.
	\end{itemize}
Furthermore, $\varepsilon = \varnothing$ in each case. \\\\
}
{ These typing judgements each appear exactly once in the conclusion of different rules. The result follows by inversion of \textsc{$\varepsilon$-Resource}, \textsc{$\varepsilon$-NewObj}, and \textsc{C-NewObj} respectively. \\
}

~
\noindent
\begin{large}
	\bf{Definition 4.2. (Substitution)}
\end{large}

\begin{itemize}
	\item $[e'/z]z = e'$
	\item $[e'/z]y = y$, if $y \neq z$
	\item $[e'/z]r = r$
	\item $[e'/z](e_1.m(e_2)) = ([e'/z]e_1).m([e'/z]e_2)$
	\item $[e'/z](e_1.\pi) = ([e'/z]e_1).\pi$
	\item $[e'/z](\newd) = \keywadj{new}_d~x \Rightarrow \overline{ \sigma = [e'/z]e }$, if $z \neq x$ and $z \notin \keywadj{freevars}(e_i)$
	\item $[e'/z](\newsig) = \keywadj{new}_\sigma~x \Rightarrow \overline{ \sigma = [e'/z]e }$, if $z \neq x$ and $z \notin \keywadj{freevars}(e_i)$
\end{itemize}


\thm{Lemma 4.2. (Substitution Lemma)}
{If $\Gamma, z : \tau' \vdash e : \tau~\keyw{with} \varepsilon$, and $\Gamma \vdash e' : \tau'~\keyw{with} \varepsilon'$, then $\Gamma \vdash [e'/z]e : \tau~\keyw{with} \varepsilon$. \\\\
\fbox{Intuition} If you substitute $z$ for something of the same type, the type of the whole expression stays the same after substitution.
\\\\}
{We've already proven the lemma by structural induction on the $\varepsilon$ rules. The new case is defined on a form not in the grammar for the fully-annotated system. So all that remains is to induct on derivations of $\Gamma \vdash e : \type{\tau}{\varepsilon}$ using the new $\textsc{C}$ rules.\\

	\proofcase{\textsc{C-MethCall}}{
Then $e = e_1.m(e_2)$ and $[e'/z]e = ([e'/z]e_1).m([e'/z]e_2)$ . By inductive assumption we know that $e_1$ and $[e'/z]e_1$ have the same types, and that $e_2$ and $[e'/z]e_2$ have the same types. Since $e$ and $[e'/z]e$ have the same syntactic struture, and their corresponding subexpressions have the same types, then $\Gamma$ can use \textsc{C-MethCall} to type $[e'/z]e$ the same as $e$.\\
}

	\proofcase{\textsc{C-NewObj}}{
		Then $e = \newd$. $z$ appears in some method body $e_i$. By inversion we know $\Gamma, x : \{ \bar \sigma \} \vdash \overline {d = e}~\keywadj{OK}$. The only rule with this conclusion is \textsc{$\varepsilon$-ValidImpl$_d$}; by inversion on that we know for each $i$ that:
		 \begin{itemize}
		 	\item $d_i = \keyw{def} m_i(y : \tau_1) : \tau_2~\keyw{with} \varepsilon$
		 	\item $\Gamma, y : \tau_1 \vdash e_i : \tau_2~\keyw{with} \varepsilon$
		\end{itemize}

\noindent
If $z$ appears in the body of $e_i$ then $\Gamma, z : \tau \vdash d_i = e_i~\keywadj{OK}$ by inductive assumption. Then we can use \textsc{$\varepsilon$-ValidImpl$_d$} to conclude $\overline{d = [e'/z]e}~\keywadj{OK}$. This tells us that the types and static effects of all the methods are unchanged under substitution. By choosing the same $\Gamma' \subseteq \Gamma$ used in the original application of \textsc{C-NewObj}, we can apply \textsc{C-NewObj} to the expression after substitution. The types and static effects the methods are the same, and the same $\Gamma'$ has been chosen, so $[e'/z]e$ will be ascribed the same type as $e$.
}
}

\begin{large}
\bf{Soundness Strategy}
\end{large}

\noindent
The previous proofs were straightforward grammatical consequences. In the next few proofs we build up to the soundness theorem. Our approach is to show the following:
\begin{enumerate}
	\item For any program containing unlabeled terms, there is a labeled version of that program which contains the runtime effects (this process is called labeling).
	\item After labeling the program will only contain labeled terms, and typing judgements will be sound (from soundness of fully-labeled programs).
	\item The presence of labels can only make static effect information more precise (Refinement theorem).
\end{enumerate}

\noindent
Because the labeled version of a program has more precise type information (3) and is type-and-effect sound (2), then weaker reasoning about the unlabeled version must also be type-and-effect sound. \\
	

\begin{large}
\bf{Definition 4.3. ($\keywadj{label}$)}
\end{large}

\noindent
A program can have its unlabeled terms labeled in a particular context $\Gamma$. We will define $\kwa{label}(e)$. It will be well-defined if $\Gamma \vdash e : \tau$; then we say $\kwa{label}(e, \Gamma) = \hat e$.

\begin{itemize}
	\item $\keywadj{label}(r, \Gamma)$ = r
	\item $\keywadj{label}(x, \Gamma)$ = x
	\item $\keywadj{label}(e_1.m(e_2), \Gamma) = \keywadj{label}(e_1, \Gamma).m(\keywadj{label}(e_2), \Gamma)$
	\item $\keywadj{label}(e_1.\pi(e_2), \Gamma) = \keywadj{label}(e_1, \Gamma).\pi(\keywadj{label}(e_2), \Gamma)$
	\item $\keywadj{label}(\keyw{new_\sigma} x \Rightarrow \overline{\sigma = e}, \Gamma) = \keywadj{new}_\sigma~x \Rightarrow \keywadj{label \hyphen helper}(\overline{\sigma = e}, \Gamma)$
	\item $\keywadj{label}(\keyw{new_d} x \Rightarrow \overline{d = e}, \Gamma) = \keyw{new_\sigma} x \Rightarrow \keywadj{label \hyphen helper}(\overline{d = e}, \Gamma)$
	\item $\keywadj{label \hyphen helper}(\sigma = e, \Gamma) = \sigma = \keywadj{label}(e, \Gamma)$
	\item $\keywadj{label \hyphen helper}(\keywadj{def}~m(y : \tau_2) : \tau_3 = e, \Gamma) = \keywadj{def}~m(y : \tau_2) : \tau_3~\keyw{with} \keywadj{effects}(\Gamma \cap \keywadj{freevars}(e)) = \keywadj{label}(e, \Gamma)$
\end{itemize}

\noindent \textbf{Notes:}
\begin{itemize}
\item $\Gamma \cap \keywadj{freevars}(e)$ is the set of pairs $x : \tau \in \Gamma$, such that $x \in \keywadj{freevars}(e)$.
\item $\keywadj{label}(e, \Gamma)$ is read as: ``the labeling of $e$ in $\Gamma$''. When the $\Gamma$ is obvious in context we will write $\kwa{label}(e)$ instead of $\kwa{label}(e, \Gamma)$.
\item Beware of confusing notation: there are two types of equality in the above definitions. One is the equality which defines $\keywadj{label}$, and the other is the equality $\sigma = e$ of declarations in the programming language.
\item $\keywadj{label}$ is defined on expressions; $\keywadj{label \hyphen helper}$ on declarations. Everywhere other than this section we'll only use $\keywadj{label}$.
\item The body of a $\keywadj{new_\sigma}$ may contain unlabeled objects so those must be recursively labeled too.
\item We may sometimes say $\keywadj{labels}(e) = \hat e$, and from then on refer to the labeled version of $e$ as $\hat e$. We'll use $\hat \tau$ and $\hat \varepsilon$ to refer to the type and static effects of the labeled version.\\
\end{itemize}















\thm{Observation 4.4.}{
If $\Gamma \vdash e : \tau$, then $\kwa{label}(e, \Gamma)$ only contains terms from the fully-labeled system defined in $\kwa{effects.pdf}$.\\\\
}{By inspecting the definition, the right-hand side of $\kwa{label}(e) = \hat e$ contains only such terms.\\\\
}













\thm{Property 4.5. (Commutativity Between $\kwa{label}$ and $\kwa{sub}$)}
{Fix $\Gamma$ and define $\kwa{label}(e) = \kwa{label}(e, \Gamma)$. Then $\kwa{label}([e'/z]e) = [\kwa{label}(e')/z](\kwa{label}(e))$\\

\noindent
\fbox{Intuition.} ~~If perform substitution and labeling on an expression, the order in which you do things doesn't matter.\\\\}
{Induction on the form of $e$. In each case,``left-hand side'' refers to $\kwa{label}([e'/z]e)$ while ``right-hand side'' refers to $[\kwa{label}(e')/z](\kwa{label}(e))$.\\

\proofcase{$e = r$}{
By definition, $\kwa{label}(r) = r$ and $[e'/z]r = r$, for any $e'$. Both sides are equivalent to $r$ because $\kwa{sub}$ and $\kwa{label}$ act like the identity function.\\
}

\proofcase{$e = x$}{
By definition, $\kwa{label}(x) = x$. $[e'/z]x$ has two definitions, depending on if $x = z$; consider each case.\\

\subcase{ $x \neq z$. Then $[e'/z]x = x$. Both sides are equivalent to $x$ because $\kwa{sub}$ and $\kwa{label}$ act like the identity function.\\}

\subcase{ $x = z$. Then $[e'/z]x = z$. On the left-hand side, $\keywadj{label}([e'/z]x) = \keywadj{label}(e')$. On the right-hand side, $[\keywadj{label}(e')/z]x = \keywadj{label}(e')$.\\
}
}

\proofcase{$e = e_1.\pi$}{
\noindent
On the left-hand side.
\begin{adjustwidth}{1.5em}{0em}
$\kwa{label}([e'/z](e_1.\pi))$\\
$= \kwa{label}( ([e'/z]e_1).\pi )$
\tabto{15em} (definition of $\kwa{sub}$)\\
$= (\kwa{label}([e'/z]e_1)).\pi$
\tabto{15em} (definition of $\kwa{label}$)\\
$= ( [\kwa{label}(e')/z] (\kwa{label}(e_1)) ).\pi$
\tabto{15em} (inductive assumption on $e_1$)\\
\end{adjustwidth}
On the right-hand side.
\begin{adjustwidth}{1.5em}{0em}
$[\kwa{label}(e')/z](\kwa{label}(e_1.\pi))$ \\
$= [\kwa{label}(e')/z](\kwa{label}(e_1).\pi)$
\tabto{15em} (definition of $\kwa{label}$)\\
$= ([\kwa{label}(e')/z](\kwa{label}(e_1))).\pi$
\tabto{15em} (definition of $\kwa{sub}$)\\
\end{adjustwidth}
}

\proofcase{$e = e_1.m(e_2)$}{
On the left-hand side.
\begin{adjustwidth}{1.5em}{0em}
$\kwa{label}([e'/z](e_1.m(e_2)))$ \\
$= \kwa{label}(([e'/z]e_1).m([e'/z]e_2)) $
\tabto{26em} (definition of $\kwa{sub}$)\\
$= (\kwa{label}([e'/z]e_1)).m(\kwa{label}([e'/z]e_2))$
\tabto{26em} (definition of $\kwa{label}$)\\
$= ([\kwa{label}(e')/z](\kwa{label}(e_1)).m(\kwa{label}([e'/z]e_2))$
\tabto{26em} (inductive assumption on $e_1$) \\
$= ([\kwa{label}(e')/z](\kwa{label}(e_1)).m([\kwa{label}(e')/z](\kwa{label}(e_2)))$
\tabto{26em} (inductive assumption on $e_2$) \\
\end{adjustwidth}

\noindent
On the right-hand side.
\begin{adjustwidth}{1.5em}{0em}
$[\kwa{label}(e')/z](\kwa{label}(e_1.m(e_2)))$ \\
$= [\kwa{label}(e')/z]((\kwa{label}(e_1)).m(\kwa{label}(e_2)))$
\tabto{28em} (definition of $\kwa{label}$)\\
$= ( [\kwa{label}(e')/z](\kwa{label}(e_1)) ).m( [\kwa{label}(e')/z](\kwa{label}(e_2)) )$
\tabto{28em} (definition of $\kwa{sub}$)
\end{adjustwidth}~
}

\proofcase{$e = \newsig$}{
On the left-hand side.
\begin{adjustwidth}{1.5em}{0em}
$\kwa{label}([e'/z](\kwa{new}_\sigma~x \Rightarrow \overline{\sigma_i = e_i})$ \\
$=\kwa{label}(\kwa{new}_\sigma~x \Rightarrow \overline{\sigma_i = [e'/z]e_i})$
\tabto{20em} (definition of $\kwa{sub}$) \\
$= \kwa{new}_\sigma~x \Rightarrow \kwa{label \hyphen helper}(\overline{\sigma_i = [e'/z]e_i)}$
\tabto{20em} (definition of $\kwa{label}$) \\
$= \kwa{new}_\sigma~x \Rightarrow \overline{\sigma_i = \kwa{label}([e'/z]e_i)}$
\tabto{20em} (definition of $\kwa{label \hyphen helper}$ on each $\sigma_i = [e'/z]e_i$) \\
\end{adjustwidth}

\noindent
On the right-hand side.
\begin{adjustwidth}{1.5em}{0em}
$[\kwa{label}(e')/z](\kwa{label}(\kwa{new}_\sigma~x \Rightarrow \overline{\sigma_i = e_i}))$ \\
$= [\kwa{label}(e')/z](\kwa{new}_\sigma~x \Rightarrow \kwa{label \hyphen helper}(\overline{\sigma_i = e_i}))$
\tabto{24em} (definition of $\kwa{label}$) \\
$= [\kwa{label}(e')/z](\kwa{new}_\sigma~x \Rightarrow \overline{\sigma_i = \kwa{label}(e_i)})$
\tabto{24em} (definition of $\kwa{label \hyphen helper}$ on each $\sigma_i = e_i$) \\
$= \kwa{new}_\sigma~x \Rightarrow \overline{\sigma_i = [\kwa{label}(e')/z](\kwa{label}(e_i)}$
\tabto{24em} (definition of $\kwa{sub}$) \\
$= \kwa{new}_\sigma~x \Rightarrow \overline{\sigma_i = \kwa{label}([e'/z]e_i)}$
\tabto{24em} (inductive assumption on each $e_i$)
\end{adjustwidth}~
}

\proofcase{$e = \newd$}{
The proof of this is quite similar to previous case for labeled objects. The main difference is that when labeling an unlabeled object, each $d_i = e_i$ turns into a $\sigma_i = e_i$. For clarity we will define $\varepsilon_i = \kwa{effects}(\Gamma \cap \kwa{freevars}(e_i))$, and $\sigma_i = d_i~\kw{with} \varepsilon_i$ (these are from the definition of $\kwa{label \hyphen helper}$).\\

\noindent
On the left-hand side.
\begin{adjustwidth}{1.5em}{0em}
$\kwa{label}([e'/z](\kwa{new}_d~x \Rightarrow \overline{d_i = e_i}))$ \\
$= \kwa{label}( \kwa{new}_d~x \Rightarrow \overline{d_i = [e'/z]e_i} )$
\tabto{24em} (definition of $\kwa{sub}$) \\
$= \kwa{new}_d~x \Rightarrow \kwa{label \hyphen helper}(\overline{d_i = [e'/z]e_i})$
\tabto{24em} (definition of $\kwa{label}$) \\
$= \kwa{new}_d~x \Rightarrow \overline{d_i~\kw{with} \varepsilon_i = \kwa{label}([e'/z]e_i)}$
\tabto{24em} (definition of $\kwa{label \hyphen helper}$) \\
$= \kwa{new}_d~x \Rightarrow \overline{\sigma_i = \kwa{label}([e'/z]e_i)}$
\tabto{24em} ($\sigma_i = d_i~\kw{with} \varepsilon_i$) 


\end{adjustwidth}~

\noindent
On the right-hand side.
\begin{adjustwidth}{1.5em}{0em}
$[\kwa{label}(e')/z](\kwa{label}(\kwa{new}_d~x \Rightarrow \overline{d_i = e_i}))$ \\
$= [\kwa{label}(e')/z](\kwa{new}_d~x \Rightarrow \kwa{label \hyphen helper}(\overline{d_i = e_i}))$
\tabto{24em} (definition of $\kwa{label}$) \\
$= [\kwa{label}(e')/z](\kwa{new}_\sigma~x \Rightarrow \overline{d_i~\kw{with} \varepsilon_i = \kwa{label}(e_i)})$
\tabto{24em} (definition of $\kwa{label \hyphen helper}$ on each $d_i = e_i$) \\
$= [\kwa{label}(e')/z](\kwa{new}_\sigma~x \Rightarrow \overline{\sigma_i = \kwa{label}(e_i)})$
\tabto{24em} ($\sigma_i = d_i~\kw{with} \varepsilon_i$) \\
$= \kwa{new}_\sigma~x \Rightarrow \overline{\sigma_i = [\kwa{label}(e')/z](\kwa{label}(e_i)})$
\tabto{24em} (definition of $\kwa{sub}$) \\
$= \kwa{new}_\sigma~x \Rightarrow \overline{\sigma_i = \kwa{label}([e'/z]e_i)}$
\tabto{24em} (inductive assumption on each $e_i$)
\end{adjustwidth}~
}
}

\noindent
\thm{Property 4.6. (Runtime Invariance Under $\keywadj{label}$)}
{If the following are true:
	\begin{itemize}
	\item $\Gamma \vdash e_A : \type{\tau_A}{\varepsilon_A}$
	\item $e_A \longrightarrow e_B~|~\varepsilon$
	\item $\hat e_A = \keywadj{label}(e_A, \Gamma)$
	\end{itemize}
Then $\hat e_A \longrightarrow \hat e_B~|~\varepsilon$ and $\hat e_B = \keywadj{label}(e_B, \Gamma)$.\\\\
\fbox{Intuition} If you label a program and then reduce, or reduce and then label, you get the same thing.
\\\\
}
{Induct on the form of $e_A$ and then on the reduction rule $e_A \longrightarrow e_B~|~\varepsilon$. Throughout this proof there is only a single context $\Gamma$, so we'll write $\keywadj{label}(e)$ instead of $\keywadj{label}(e, \Gamma)$ as a notational short-hand.\\

\proofcase{$e=r$, $e=x$, $e=\newsig$, $e=\newd$}{
	Then $e$ is a value and the theorem statement holds automatically.\\
}

\proofcase{$e=e_1.\pi$}{
The only typing rule which applies is \textsc{$\varepsilon$-OperCall}, which tells us:
	\begin{itemize}
		\item $\Gamma \vdash e_1 : \type{ \{ r \} }{\varepsilon_1}$
		\item $\Gamma \vdash e_1.\pi : \type{\keywadj{Unit}}{\varepsilon_1 \cup \{ r.\pi \}}$
	\end{itemize}
\noindent
There are two possible reductions. \\

\subcase{\textsc{E-OperCall1}. We also know $e_1 \longrightarrow e_1'~|~\varepsilon$, and $e_1.\pi \longrightarrow e_1'.\pi~|~\varepsilon$. By inductive assumption, $\hat e_1 \longrightarrow \hat e_1'~|~\varepsilon$, and $\hat e_1' = \keywadj{label}(e_1')$. Applying definitions, $\hat e_A = \keywadj{label}(e_1.\pi) = (\keywadj{label}(e_1)).\pi = \hat e_1.\pi$. Because $\hat e_1 \longrightarrow \hat e_1'~|~\varepsilon$, we may apply the reduction \textsc{E-OperCall1} to obtain $\hat e_1.\pi \longrightarrow \hat e_1'.\pi~|~\varepsilon$. Lastly, $\hat e_B = \keywadj{label}(e_1'.\pi) = (\keywadj{label}(e_1')).\pi$, which we know to be $\hat e_1'.\pi$ by inductive assumption.\\
}

\subcase{\textsc{E-OperCall2}. We also know $e_1 = r$ and $r.\pi \longrightarrow \keywadj{Unit}~|~\{ r.\pi \}$. Applying definitions, $\hat e_A = \keywadj{label}(r.\pi) = (\keywadj{label}(r)).\pi = r.\pi = e_A$. The theorem holds immediately.\\

}
}
	
\proofcase{$e=e_1.m_i(e_2)$}{
\noindent
There are five possible reductions. \\

\subcase{ \textsc{E-MethCall1}. We also know $e_1 \longrightarrow e_1'~|~\varepsilon$ and $e_1.m_i(e_2) \longrightarrow e_1'.m_i(e_2)~|~\varepsilon$. By inductive assumption, $\hat e_1 \longrightarrow \hat e_1'~|~\varepsilon$, and $\keywadj{label}(e_1') = \hat e_1'$. Applying definitions $\hat e_A = \keywadj{label}(e_1.m_i(e_2)) = (\keywadj{label}(e_1)).m_i(\keywadj{label}(e_2)) = \hat e_1.m_i(\hat e_2)$. Because $\hat e_1 \longrightarrow \hat e_1'~|~\varepsilon$, we may apply the reduction \textsc{E-MethCall1} to obtain $\hat e_1.m_i(\hat e_2) \longrightarrow \hat e_1'.m_i(\hat e_2)~|~\varepsilon$. Lastly, $\hat e_B = \keywadj{label}(e_1'.m_i(\hat e_2)) = (\keywadj{label}(e_1')).m_i(\keywadj{label}(e_2))$, which we know to be $\hat e_1'.m_i(\hat e_2) = \hat e_B$ by assumptions.\\

}

\subcase{ \textsc{E-MethCall2$_\sigma$}. We also know $e_1 = v_1 = \newsig$, and $e_2 \longrightarrow e_2'~|~\varepsilon$ and $v_1.m_i(e_2) \longrightarrow v_1.m_i(e_2')~|~\varepsilon$. By inductive assumption, $\hat e_2 \longrightarrow \hat e_2'~|~\varepsilon$, and $\keywadj{label}(e_2') = \hat e_2'$. Applying definitions, $\hat e_A = \keywadj{label}(v_1.m_i(e_2)) = (\keywadj{label}(v_1)).m_i(\keywadj{label}(e_2)) = \hat v_1.m_i(\hat e_2)$. Because $\hat e_2 \longrightarrow \hat e_2'~|~\varepsilon$, we may apply the reduction \textsc{E-MethCall$_\sigma$} to obtain $\hat v_1.m_i(\hat e_2) \longrightarrow \hat v_1.m_i(\hat e_2')$. Lastly, $\hat e_B = \keywadj{label}(v_1.m_i(e_2')) = (\keywadj{label}(v_1)).m_i(\keywadj{label}(e_2'))$, which we know to be $\hat v_1.m_i(\hat e_2')$ by assumptions. \\
}

\subcase{ \textsc{E-MethCall2$_d$}. Identical to the above subcase, but $e_1 = v_1 = \newd$, and we apply the reduction rule \textsc{E-MethCall$_d$} instead. 
\\}


\subcase{ \textsc{E-MethCall3$_\sigma$}. We also know the following:
\begin{itemize}
	\item $e_1 = v_1 = \newsig$
	\item $e_2 = v_2$
	\item $\keywadj{def~} m_i(y : \tau_2) : \type{\tau_3}{\varepsilon_3} = e_{body} \in \{ \bar \sigma \}$
	\item $v_1.m_i(v_2) \longrightarrow [v_1/x, v_2/y]e_{body}~|~\varnothing$.
\end{itemize}
\noindent
Applying definitions, $\keywadj{label}(v_1.m_i(v_2)) = (\keywadj{label}(v_1)).m_i(\keywadj{label}(v_2)) = \hat v_1.m_i(\hat v_2)$, where we define $\hat v_1 = \kwa{label}(v_1)$ and $\hat v_2 = \kwa{label}(v_2)$. Before labeling, the object $v_1$ has method $m_i$ with body $e_{body}$. The labeled version, $\hat v_1$, has method $m_i$ with body $\keywadj{label}(e_{body}) = \hat e_{body}$. Because $v_1$ and $v_2$ are values, so are $\hat v_1$ and $\hat v_2$. Therefore we can apply \textsc{E-MethCall3$_\sigma$} to $\hat v_1.m_i(\hat v_2)$, giving us $\hat v_1.m_i(\hat v_2) \longrightarrow [\hat v_1 / x, \hat v_2 / y]\hat e_{body}~|~\varnothing$. Because $\keywadj{label}$ and $\keywadj{sub}$ commute, $\keywadj{label}(e_B) = \keywadj{label}([v_1/x, v_2/y]e_{body}) = [\keywadj{label}(v_1)/x, \keywadj{label}(v_2)/y](\keywadj{label}(e_{body})))$, which is $[\hat v_1/x, \hat v_2/y] \hat e_{body} = \hat e_B$, by how we defined $\hat v_1$, $\hat v_2$, and $\hat e_{body}$.\\
}


\subcase{ \textsc{E-MethCall3$_d$}.
This case is identical to the previous one, except $e_1 = v_1 = \newd$. The same reasoning applies though.
}

}~\\
}



\thm{Theorem 4.7. (Refinement Theorem)}
{If $\Gamma \vdash e : \tau~\keyw{with} \varepsilon$ and $\keywadj{label}(e) = \hat e$, then one of the following is true:
\begin{itemize}
	\item $\Gamma \vdash \hat e : \hat \tau~\keyw{with} \hat \varepsilon$, where $\hat \varepsilon \subseteq \varepsilon$ and $\hat \tau <: \tau$
		\item $e$ has the form $\newd$ and $\Gamma \vdash \hat e : \overline{d_i ~\kw{with}\varepsilon_i = e_i}$, where $\varepsilon_i = \kw{effects}(\Gamma \cap \kwa{freevars}(e_i))$
\end{itemize}

\noindent
\fbox{Intuition.}~~~Labels can only make the static effects more precise; never less precise.
\\\\
}
{~\\
}

\thm{Lemma 4.8. (Extension Lemma)}
{If $\Gamma\vdash e : \tau$ and $\hat e = \kwa{label}(e, \Gamma)$ then $\Gamma \vdash e : \type{\hat \tau}{\hat \varepsilon}$, where $\hat \tau <: \tau$. If $e \longrightarrow e'~|~\varepsilon$, then $\varepsilon \subseteq \hat \varepsilon$.\\

\noindent
\fbox{Intuition.}~~~If $\Gamma$ can type $e$ without an effect, there is a way to label $e$ with $\hat \varepsilon$ which contains the possible runtime effects of $e$  (so $\hat \varepsilon$ is an upper-bound).\\\\
}
{~\\
}

\thm{Theorem 4.9. (Soundness Theorem)}
{If $\Gamma \vdash e_A : \tau_A~\keyw{with} \varepsilon_A$ and $e_A \longrightarrow e_B~|~\varepsilon$ then $\Gamma \vdash e_B : \tau_B~\keyw{with} \varepsilon_B$, where:
\begin{enumerate}
	\item $\tau_B <: \tau_A$ and $\varepsilon_B \subseteq \varepsilon_A$
	\item $\varepsilon \subseteq \varepsilon_A$
\end{enumerate}
~\\}
{
}



\end{document}
