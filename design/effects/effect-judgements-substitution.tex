\documentclass{llncs}

\usepackage{listings}
\usepackage{proof}
\usepackage{amssymb}
\usepackage[margin=.9in]{geometry}
\usepackage{amsmath}
\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage{enumitem}
\usepackage{filecontents}
\usepackage{calc}
\usepackage[linewidth=0.5pt]{mdframed}
\usepackage{changepage}
\allowdisplaybreaks

\usepackage{fancyhdr}
\renewcommand{\headrulewidth}{0pt}
\pagestyle{fancy}
 \fancyhf{}
\rhead{\thepage}

\lstset{tabsize=3, basicstyle=\ttfamily\small, commentstyle=\itshape\rmfamily, numbers=left, numberstyle=\tiny, language=java,moredelim=[il][\sffamily]{?},mathescape=true,showspaces=false,showstringspaces=false,columns=fullflexible,xleftmargin=5pt,escapeinside={(@}{@)}, morekeywords=[1]{objtype,module,import,let,in,fn,var,type,rec,fold,unfold,letrec,alloc,ref,application,policy,external,component,connects,to,meth,val,where,return,group,by,within,count,connect,with,attr,html,head,title,style,body,div,keyword,unit,def}}
\lstloadlanguages{Java,VBScript,XML,HTML}


\newcommand{\keywadj}[1]{\mathtt{#1}}
\newcommand{\keyw}[1]{\keywadj{#1}~}
\newcommand{\reftt}{\mathtt{ref}~}
\newcommand{\Reftt}{\mathtt{Ref}~}
\newcommand{\inttt}{\mathtt{int}~}
\newcommand{\Inttt}{\mathtt{Int}~}
\newcommand{\stepsto}{\leadsto}
\newcommand{\todo}[1]{\textbf{[#1]}}
\newcommand{\intuition}[1]{#1}
%\newcommand{\intuition}[1]{}

\newlist{pcases}{enumerate}{1}
\setlist[pcases]{
  label=\fbox{\textit{Case}}\protect\thiscase\textit{:}~,
  ref=\arabic*,
  align=left,
  labelsep=0pt,
  leftmargin=0pt,
  labelwidth=0pt,
  parsep=0pt
}
\newcommand{\pcase}[1][]{

  \if\relax\detokenize{#1}\relax
    \def\thiscase{}
  \else
    \def\thiscase{~\fbox{#1:}}
  \fi
  \item
}

\newcommand{\thm}[3]{
	\begin{large}
		\bf{#1}
	\end{large} \\\\
	\fbox{Statement.} ~ #2
	\fbox{Proof.}~ #3 \qed
}

\newcommand{\proofcase}[2]{
	\begin{adjustwidth}{1.5em}{0pt}
		\fbox{Case.}~~#1. \\ ~#2
	\end{adjustwidth}
}

\newcommand{\subcase}[1] {
	\begin{adjustwidth}{2.2em}{0pt}
		\underline{Subcase.} #1
	\end{adjustwidth}
}

\newcommand{\stmt}[1] {

\begin{adjustwidth}{2.5em}{0pt}
	#1
\end{adjustwidth}

}



\begin{document}

\today
\section{Effects}

\paragraph{}
Fix some set of resources $R$. A resource is some language primitive that has the authority to directly perform I/O operations. Elements of the set $R$ are denoted by $r$. $\Pi$ is a fixed set of operations on resources. Its members are denoted $\pi$. An effect is a member of the set of pairs $R \times \Pi$. A set of effects is denoted by $\varepsilon$. In this system we cannot dynamically create resources or resource-operations.

\paragraph{}
Throughout we refer to the notions of effects and captures. A piece of code $C$ has the effect $(r, \pi)$ if operation $\pi$ is performed on resource $r$ during execution of $C$. $C$ captures the effect $(r, \pi)$ if it has the authority to perform operation $\pi$ on resource $r$ at some point during its execution.

\paragraph{}
We use $r.\pi$ as syntactic sugar for the effect $(r,\pi)$. For example, $FileIO.append$ instead of $(FileIO, append)$.

\paragraph{}
Types are either resources or structural. Structural types have a set of method declarations. An object of a particular structural type $\{ \bar \sigma \}$ can have any of the methods defined by $\sigma$ invoked on it. The structural type $\varnothing$ with no methods is called $\keywadj{Unit}$.

\paragraph{}
We assume there are constructions of the familiar types using the basic structural type $\varnothing$ and method declarations (for example, $\mathbb{N}$ could be made using $\varnothing$ and a $\keywadj{successor}$ function, Peano-style).

\paragraph{}
Note the distinction between methods (usually denoted $m$) and operations (usually denoted $\pi$). An operation can only be invoked on a resource; resources can only have operations invoked on them. A method can only be invoked on an object; objects can only have methods invoked on them.

\paragraph{}
We make a simplifying assumption that every method/lambda takes exactly one argument. Invoking some operation $\pi$ on a resource returns $\varnothing$.



\newpage

\section{Static Semantics For Fully-Annotated Programs}

\paragraph{}
In this first system every method in the program is explicitly annotated with its set of effects.

\subsection{Grammar}

\[
\begin{array}{lll}
\begin{array}{lllr}

	e & ::= & x & expressions \\
  		& | & r \\
  		& | & \keywadj{new}~x \Rightarrow \overline{\sigma = e} \\
  		& | & e.m(e)\\
  		& | & e.\pi(e)\\
		&&\\

	\tau & ::= & \{ \bar \sigma \} ~ | ~ \{ \bar r \} & types \\
		&&\\

	\sigma & ::= &  \keyw{def} m(x:\tau):\tau~\keyw{with}\varepsilon  & labeled~ decls.\\
		&&\\
		
	\Gamma & ::= & \varnothing \\
		& | & \Gamma,~x : \tau\\
		&&\\

\end{array}
& ~~~~~~
&
\end{array}
\]


\noindent \textbf{Notes:}

\begin{itemize}
	\item Declarations ($\sigma$-terms) are annotated by what effects they have.
	\item $d$-terms do not appear in programs, except as part of $\sigma$-terms.
	\item All methods (and lambda expressions) take exactly one argument. If a method specifies no argument, then the argument is implicitly of type $\keywadj{Unit}$.
	\item Although $e_1.\pi(e_2)$ is a syntactically valid expression, it is only well-formed under the static semantics if $e_1$ has a resource-type (remembering that $\pi$ operations can only be performed on resources). 
\end{itemize}

\subsection{Rules}

\fbox{$\Gamma \vdash e : \tau~\keyw{with} \varepsilon$}

\[
\begin{array}{c}
\infer[\textsc{($\varepsilon$-Var)}]
  {\Gamma,~x:\tau \vdash x:\tau~ \keyw{with} \varnothing}
  {} 
~~~~~~~~~~
\infer[\textsc{($\varepsilon$-Resource)}]
  {\Gamma,~r :\{r\} \vdash r:\{ r \} ~ \keyw{with} \varnothing}
  {r \in R} \\[5ex]

\infer[\textsc{($\varepsilon$-NewObj)}]
	{\Gamma \vdash \keywadj{new}~x \Rightarrow \overline{\sigma = e} : \{ \bar \sigma \}~\keyw{with} \varnothing}
	{\Gamma,~x : \{ \bar \sigma \} \vdash \overline{\sigma = e}~\keywadj{OK}} \\[5ex]

\infer[\textsc{($\varepsilon$-OperCall)}]
	{\Gamma \vdash e_1.\pi(e_2) : \keyw{Unit} \keyw{with} \{ \bar r.\pi \} \cup \varepsilon_1 \cup \varepsilon_2}
	{\Gamma \vdash e_1 : \{ \bar r \}~ \keyw{with} \varepsilon_1 & \Gamma \vdash e_2:\tau_2~\keyw{with} \varepsilon_2 & \pi \in \Pi} \\[5ex]
	
\infer[\textsc{($\varepsilon$-MethCallObj)}]
	{\Gamma \vdash e_1.m_i(e_2):\tau~\keyw{with} \varepsilon_1 \cup \varepsilon_2 \cup \varepsilon}
	{\Gamma \vdash e_1 : \{ \bar \sigma \}~\keyw{with} \varepsilon_1 & \Gamma \vdash e_2 : \tau_2~\keyw{with} \varepsilon_2 & \sigma_i = \keyw{def} m_i(y:\tau_2):\tau~\keyw{with} \varepsilon}

\end{array}
\]

$\fbox{$\Gamma \vdash \sigma = e~\keyw{OK}$}$

\[
\begin{array}{c}
\infer[\textsc{($\varepsilon$-ValidImpl$_\sigma$)}]
	{\Gamma \vdash \sigma = e~\keywadj{OK}}
	{\Gamma,~x:\tau \vdash e: \tau'~\keyw{with} \varepsilon & \sigma = \keyw{def} m(x:\tau):\tau'~\keyw{with} \varepsilon} \\[5ex]
\end{array}
\]

\noindent \textbf{Notes:}

\begin{itemize}
	\item The rules \textsc{$\varepsilon$-Var}, \textsc{$\varepsilon$-Resource}, and \textsc{$\varepsilon$-NewObj} have in their consequents an expression typed with no effect: merely having an object or resource is not an effect; you must do something with it, like a call a method on it, in order for it to have an effect.
	\item \textsc{$\varepsilon$-ValidImpl} says that the return type and effects of the body of a method must agree with what its signature says.
\end{itemize}



% ========================================
% Partially-Annotated Programs
% ========================================

\newpage

\section{Static Semantics For Partly-Annotated Programs}

\paragraph{}
What happens if we relax the requirement that all methods in an object must be effect-annotated? In the next system we allow objects which have no effect-annotated methods. When an object is annotated we can use the rules from the previous section. When an object has no annotations we use the additional rules introduced here, which give an upper bound on the effects of a program.

\subsection{Grammar}

\[
\begin{array}{lll}

\begin{array}{lllr}

e & ::= & x & expressions \\
  		& | & r \\
		& | & \keywadj{new}_\sigma~x \Rightarrow \overline{\sigma = e} \\
 		& | & \keywadj{new}_d~x \Rightarrow \overline{d = e} \\
 		& | & e.m(e)\\
 		& | & e.\pi(e)\\
		&&\\

\tau & ::= & \{ \bar \sigma \} & types \\
		& | & \{ \bar r \} \\
		& | & \{ \bar d \} \\
		& | & \{ \bar d ~\keyw{captures} \varepsilon \} \\
		&&\\
		
\sigma & ::= & d~\keyw{with}\varepsilon  & labeled~ decls.\\
		&&\\

d & ::= & \keyw{def} m(x:\tau):\tau & unlabeled~decls.\\
		&&\\

\end{array}
& ~~~~~~
&
\end{array}
\]

\noindent \textbf{Notes:}
\begin{itemize}
	\item $\sigma$ denotes a declaration with effect labels. $d$ denotes a declaration without effect labels.
	\item There are two new expressions: $\keywadj{new}_\sigma$ for objects whose methods are annotated; $\keywadj{new}_d$ for objects whose methods aren't.
	\item $\{ \bar \sigma \}$ is the type of an annotated object. $\{ \bar d \}$ is the type of an unannotated object.
	\item $\{ \bar d ~\keyw{captures} \varepsilon \}$ is a special kind of type that doesn't appear in source programs but may be assigned as a consequence of the capture rules. $\varepsilon$ is an upper-bound on the possible effects of the object $\{ \bar d \}$.
\end{itemize}

\subsection{Rules}

$\fbox{$\Gamma \vdash e : \tau$}$

\[
\begin{array}{c}
\infer[\textsc{(T-Var)}]
	{\Gamma,~x : \tau \vdash x : \tau}
	{}
~~~~~~~~~~
\infer[\textsc{(T-Resource)}]
	{\Gamma,~r : \{ \bar r \} \vdash r : \{ \bar r \}}
	{} \\[5ex]
~~~~~~~~~~
\infer[\textsc{(T-MethCall$_r$)}]
	{\Gamma \vdash r.\phi(e_1) : \keywadj{Unit}}
	{\Gamma \vdash r : \{ \bar r \} & \Gamma \vdash e : \tau & m \in M} \\[5ex]
~~~~~~~~~~
\infer[\textsc{(T-MethCall$_\sigma$)}]
	{\Gamma \vdash e_1.m(e_2) : \tau_2}
	{\Gamma \vdash e_1 : \{ \bar \sigma \},~\keyw{def} m(x : \tau_1) : \tau_2~\keyw{with} \varepsilon \in \{ \bar \sigma \} &  \Gamma \vdash e_2 : \tau_1 }\\[5ex]
~~~~~~~~~~
\infer[\textsc{(T-MethCall$_d$)}]
	{\Gamma \vdash e_1.m(e_2) : \tau_2}
	{\Gamma \vdash e_1 : \{ \bar d\},~\keyw{def} m(x : \tau_1) : \tau_2 \in \{ \bar d \} &  \Gamma \vdash e_2 : \tau_1 }\\[5ex]
~~~~~~~~~~

~~~~~~~~~~
\infer[\textsc{(T-New$_\sigma$)}]
	{\Gamma \vdash~\keywadj{new}_\sigma~x \Rightarrow \overline{\sigma = e} : \{ \bar \sigma \}}
	{\Gamma \vdash \sigma_i = e_i~\keywadj{OK}}
~~~~~~~~~~
\infer[\textsc{(T-New$_d$)}]
	{\Gamma \vdash~\keywadj{new}_d~x \Rightarrow \overline{d = e} : \{ \bar d \}}
	{\Gamma \vdash d_i = e_i~\keywadj{OK}}\\[5ex]
\end{array}
\]

$\fbox{$\Gamma \vdash d = e~\keyw{OK}$}$
\[
\begin{array}{c}
\infer[\textsc{($\varepsilon$-ValidImpl$_d$)}]
	{\Gamma \vdash d = e~\keywadj{OK}}
	{d = \keyw{def} m(x : \tau_1) : \tau_2 & \Gamma \vdash e : \tau_2}
	\\[5ex]
\end{array}
\]

\fbox{$\Gamma \vdash e : \tau~\keyw{with} \varepsilon$}

\[
\begin{array}{c}
\infer[\textsc{(C-NewObj)}]
	{\Gamma \vdash~\keywadj{new}_d~x \Rightarrow \overline{d = e} : \{  \bar d~\keyw{captures} \varepsilon \} ~\keyw{with} \varnothing }
	{\varepsilon = \keywadj{effects}(\Gamma') & \Gamma' \subseteq \Gamma & \Gamma', x : \{ \bar d~\keyw {captures} \varepsilon \} \vdash \overline{d = e}~\keyw{OK}} \\[5ex]
\end{array}
\]

\[
\begin{array}{c}
\infer[\textsc{(C-MethCall)}]
	{\Gamma \vdash e_1.m_i(e_2) : \tau~ \keyw{with} \varepsilon_1 \cup \varepsilon_2 \cup effects(\tau_2) \cup \varepsilon}
	{\Gamma \vdash e_1 : \{ \bar d~\keyw{captures} \varepsilon \}~\keyw{with} \varepsilon_1 & \Gamma \vdash e_2:\tau_2~\keyw{with} \varepsilon_2&d_i :=~\keyw{def} m_i(y:\tau_2):\tau } \\[5ex]
\end{array}
\]


\noindent \textbf{Notes:}

\begin{itemize}
	\item Rules with the judgement form $\Gamma \vdash e : \tau$ do standard typing judgements on structural objects, without any effect analysis. These rules are needed to apply the $\varepsilon$-ValidImpl$_d$ rule.
	\item The \textsc{$\varepsilon$} judgements from the previous section are to be applied to annotated parts of the program; the \textsc{C} from this section are for unannotated parts.
	\item In applying \textsc{C-NewObj} the variable $\Gamma$ is the current context. The variable $\Gamma'$ is some sub-context. A good choice of sub-context is $\Gamma$ restricted to the free variables in the method-body being typechecked. This means we only consider the effects used in the method-body, giving a tighter upper bound on the effects.
	\item To perform effect analysis on an unannotated object $\{ \bar d \}$ we give it the type $\{ \bar d~\keyw{captures} \varepsilon \}$ by the rule $\textsc{C-NewObj}$, where $\varepsilon$ is an upper-bound on the possible effects that object can have. If a method is called on that object, $\textsc{C-NewObj}$ concludes the effects to be those captured in $\varepsilon$.
\end{itemize}

\subsection{Effects Function}

\noindent
The $\keywadj{effects}$ function returns the set of effects in a particular context. \\

\noindent
A method $m$ can return a resource $r$ (directly or via some enclosing object). Returning a resource isn't an effect but it means any unannotated program using $m$ also captures $r$. To account for this, when the $\keywadj{effects}$ function is operating on a type $\tau$ it must analyse the return type of the method declarations in $\tau$. Since the resource might be itself enclosed by an object, we do a recursive analysis.

\begin{itemize}
	\item $\keywadj{effects}(\varnothing) = \varnothing$
	\item $\keywadj{effects}(\Gamma, x : \tau) = \keywadj{effects}(\Gamma) \cup \keywadj{effects}(\tau)$
	\item $\keywadj{effects}(\{\bar r\}) = \{ (r, \pi) \mid r \in \bar r, \pi \in \Pi \}$
	\item $\keywadj{effects}(\{\bar \sigma\}) = \bigcup_{\sigma \in \bar \sigma}~\keywadj{effects}(\sigma)$
	\item $\keywadj{effects}(\{\bar d\}) = \bigcup_{d \in \bar d}~\keywadj{effects}(d)$
	\item $\keywadj{effects}(d~\keyw{with} \varepsilon) = \varepsilon \cup \keywadj{effects}(d)$
	\item $\keywadj{effects}(\keywadj{def~m}(x : \tau_1) : \tau_2) = \keywadj{effects}(\tau_2)$
\end{itemize}

\noindent
QUESTION: to make $\keywadj{effects}$ total over the set of types we should define it on types of the form $\{ \bar d~\keyw{captures} \varepsilon\}$. Otherwise we might be in trouble, since the input $\Gamma$ could theoretically have these types in it (although I think with these rules it never will in practice). The definition should probably be $\keywadj{effects}(\{ \bar d~\keyw{captures} \varepsilon\}) = \varepsilon$, because if it is already annotated with what it captures then we must have previously called $\keywadj{effects}$ on it.

\newpage


\section{Dynamic Semantics}

\subsection{Terminology}

\begin{itemize}
	\item If $e$ is an expression, then $[e_1/x_1, ..., e_n/x_n]e$ is a new expression, the same as e, but with every free occurrence of $x_i$ replaced by $e_i$.
	\item $\varnothing$ is the empty set. The empty type is denoted $\keywadj{Unit}$. Its single instance is $\keywadj{unit}$.
	\item A configuration is a pair $e~|~\varepsilon$.
	\item To execute a program $e$ is to perform reduction steps starting from the configuration $e~|~\varnothing$.
	\item $e_1~|~\varepsilon_1 \longrightarrow_* e_2~|~\varepsilon_2$ if $e_2~|~\varepsilon_2$ can be obtained by applying one or more reduction rules to $e_1~|~\varepsilon_1$.
	\item If $e_1~|~\varepsilon_1 \longrightarrow_* v~|~\varepsilon_2$, for some value $v$ then we say that $e_1~|~\varepsilon_1$ terminates.
\end{itemize}

\subsection{Grammar}

\[
\begin{array}{lll}
\begin{array}{lllr}
	e & ::= & x & expressions \\
  		& | & e.m(e)\\
  		& | & e.\pi(e)\\
		& | & v \\
		&&\\
		
	v & ::= & r & values \\
  		& | & \keywadj{new}_{\sigma}~x \Rightarrow \overline{\sigma = e} \\
  		& | & \keywadj{new}_d~x \Rightarrow \overline{d = e} \\
		&&\\

	d & ::= & \keyw{def} m(x:\tau):\tau & unlabeled~decls.\\		&&\\
		
	\sigma & ::= & d~\keyw{with}\varepsilon  & labeled~ decls.\\
		&&\\
\end{array}
& ~~~~~~
&

\begin{array}{lllr}

	\tau & ::= & \{ \bar \sigma \}  & types \\
		& | & \{ \bar r \} \\
		&&\\

	\Gamma & :: = & \varnothing & contexts\\
		& | & \Gamma,~x : \tau\\
		&&\\

&&\\

\end{array}
\end{array}
\]

\subsection{Rules}

\fbox{$e~|~\varepsilon \longrightarrow e~|~\varepsilon$}

\[
\begin{array}{lll}
	\infer[\textsc{(E-MethCall1)}]
		{e_1.m(e_2)~|~\varepsilon \longrightarrow e_1'.m(e_2)~|~\varepsilon'}
		{e_1~|~\varepsilon \longrightarrow e_1'~|~\varepsilon'}\\[5ex]

	\infer[\textsc{(E-MethCall2$_{\sigma}$)}]
		{v_1.m(e_2)~|~\varepsilon \longrightarrow v_1.m(e_2')~|~\varepsilon'}
		{v_1 = \keywadj{new}_{\sigma}~x \Rightarrow \overline{\sigma = e} & e_2~|~\varepsilon \longrightarrow e_2'~|~\varepsilon'}
				
		~~~~~~
	\infer[\textsc{(E-MethCall2$_d$)}]
		{v_1.m(e_2)~|~\varepsilon \longrightarrow v_1.m(e_2')~|~\varepsilon'}
		{v_1 = \keywadj{new}_{d}~x \Rightarrow \overline{d = e} & e_2~|~\varepsilon \longrightarrow e_2'~|~\varepsilon'}
		\\[5ex]
		
	\infer[\textsc{(E-MethCall3$_{\sigma}$)}]
		{v_1.m(v_2)~|~\varepsilon
			\longrightarrow
		 [v_1/x, v_2/y]e'~|~\varepsilon}
  		{v_1 = \keywadj{new}_{\sigma}~x \Rightarrow \overline{\sigma = e} & \keywadj{def~m}(y: \tau_1) : \tau_2~\keyw{with} \varepsilon' = e' \in \overline {\sigma = e}} \\[5ex]

	\infer[\textsc{(E-MethCall3$_{d}$)}]
		{v_1.m(v_2)~|~\varepsilon
			\longrightarrow
		 [v_1/x, v_2/y]e'~|~\varepsilon}
  		{v_1 = \keywadj{new}_{d}~x \Rightarrow \overline{d = e} & \keywadj{def~m}(y: \tau_1) : \tau_2 = e' \in \overline {d = e}} \\[5ex]
			
	\infer[\textsc{(E-OperCall1)}]
		{e_1.\pi(e_2)~|~\varepsilon
			\longrightarrow
		 e_1'.\pi(e_2)~|~\varepsilon'}
		{e_1~|~\varepsilon \longrightarrow e_1'~|~\varepsilon'}
~~~~~~
			\infer[\textsc{(E-OperCall2)}]
		{r.\pi(e_2)~|~\varepsilon
			\longrightarrow
		 r.\pi(e_2')~|~\varepsilon'}
		{e_2~|~\varepsilon \longrightarrow e_2'~|~\varepsilon'} \\[5ex]
			
			\infer[\textsc{(E-OperCall3)}]
		{r.\pi(v)~|~\varepsilon
			\longrightarrow
		 \keywadj{unit}~|~\varepsilon \cup \{(r, \pi)\}}
		{r \in R & \pi \in \Pi} \\[5ex]
			
		
\end{array}
\]

\newpage

\section{Theorems}

\ 
\thm{Lemma 5.1. (Atom)}
{Suppose $e$ is a value. The following are true:
	\begin{itemize}
	\item If $e : \{ \bar r \}~\keyw{with} \varepsilon$, then $e = r$ for some resource $r \in R$.
	\item If $e : \{ \bar \sigma \} \keyw{with} \varepsilon$, then $e = \keywadj{new}_{\sigma}~x \Rightarrow \overline{\sigma = e}$.
	\item If $e : \{ \bar d~\keyw{captures} \} \keyw{with} \varepsilon$, then $e = \keywadj{new}_{d}~x \Rightarrow \overline{ d = e }$.
	\end{itemize}
Furthermore, $\varepsilon = \varnothing$ in each case. \\\\
}
{ These typing judgements each appear exactly once, in the conclusion of different rules. The result follows by inversion of \textsc{$\varepsilon$-Resource}, \textsc{$\varepsilon$-NewObj}, and \textsc{C-NewObj} respectively.
}


%\thm{Lemma 5.2. (Component)}
%{The following are true.
%\begin{itemize}
%	\item If $e_1 = \keywadj{new}_{\sigma}~x %\Rightarrow \{ \overline{\sigma = e} \}$ and %$e_1 : \{ \bar \sigma \}~\keyw{with} %\varepsilon$, then for any $\keywadj{def~m_i}(y : \tau_1) : \tau_2~ \keyw{with} \varepsilon_i = e_i \in \overline {\sigma = e}$, $e_i : \tau_2~\keyw{with} \varepsilon_i$.
%	\item If $e_1 = \keywadj{new}_{d}~x \Rightarrow \{ \overline{d = e} \}$ and $e_1 : \{ \bar d \}~\keyw{with} \varepsilon$, then for any $\keywadj{def~m_i}(y : \tau_1) : \tau_2~ \keyw{with} \varepsilon_i = e_i \in \overline {\sigma = e}$, $e_i : \tau_2~\keyw{with} \varepsilon_i$
%\end{itemize}
%}
%{hi}

\ 

\thm{Theorem 5.1. (Progress)}
{If $e_A : \tau~\keyw{with} \varepsilon$, then for any configuration $e_A~|~\varepsilon_A$, either $e_A$ is a value or $e_A~|~\varepsilon \longrightarrow e_B~|~\varepsilon_B$. \\\\}
{By structural induction on possible derivations of $e_A : \tau~\keyw{with} \varepsilon$. We consider every rule which could have made this typing judgement. \\

	\proofcase{\textsc{$\varepsilon$-Var}} {
		Then $e_A = x$ is a value. \\
	}
	
	\proofcase{\textsc{$\varepsilon$-Resource}} {
		Then $e_A = r$ is a value. \\
	}
	
	\proofcase{\textsc{$\varepsilon$-NewObj}} {
		Then $e_A = new_\sigma~x \Rightarrow \overline{ \sigma = e }$ is a value. \\
	}
	
	\proofcase{\textsc{C-NewObj}} {
		Then $e_A = x$ is a value. \\
	}
		
	\proofcase{\textsc{$\varepsilon$-MethCall}} {
		Then $e_A = e_1.m_i(e_2)$ and the following are known:
		\begin{itemize}
			\item~$e_1  : \{ \overline \sigma \}~ \keyw{with} \varepsilon_1$
			\item~$e_2 : \tau_2~\keyw{with} \varepsilon_2$
			\item~$\sigma_i = \keyw{def} m_i(y : \tau_2) : \tau~ \keyw{with} \varepsilon_3$
		\end{itemize}
		We look at the cases for when $e_1$ and $e_2$ are values.
		
			\subcase{ $e_1$ is not a value. The derivation of $e_A : \tau~\keyw{with} \varepsilon$ includes the subderivation $e_1 : \{ \bar \sigma \}~\keyw{with} \varepsilon_1$, so by the inductive hypothesis. Then $e_1~ ~\varepsilon_A \longrightarrow e_1'~|~\varepsilon_B$. Then applying \textsc{E-MethCall1} to $e~|~\varepsilon_A$, we have $e_A~|~\varepsilon_A \longrightarrow e_1'.m_i(e_2)~|~\varepsilon_B$. }
	
			\subcase{ $e_2$ is not a value. Then without loss of generality, $e_1 = v_1$ is a value. Also,
		$e_2 : \tau_2~\keyw{with} \varepsilon_2$ is a subderivation. By the inductive hypothesis, $e_2~|
		~\varepsilon_A \longrightarrow e_2'~|~\varepsilon_B$. Then applying \textsc{E
		MethCall2$_{\sigma}$} to $e_A~|~\varepsilon_A$, we have $e_A~|~\varepsilon_A \longrightarrow
		v_1.m_i(e_2')~|~\varepsilon_B$.}
		
			\subcase{ $e_1 = v_1$ and $e_2 = v_2$ are values. By the Atom lemma, $e_1 = \keywadj{new}_{\sigma}~x \Rightarrow \overline{\sigma = e}$. Also, $\keyw{def} m_i(y: \tau_2)  \tau~\keyw{with} \varepsilon_3 = e_i \in \overline{ \sigma = e }$. Then applying \textsc{E-MethCall3$_{\sigma}$} to $e_A~|~\varepsilon_A$, we have $e_A~|~\varepsilon_A \longrightarrow [v_1/x, v_2/y]e_i~|~\varepsilon_A$\\}

	}
	
	\proofcase{\textsc{$\varepsilon$-OperCall}} {
Then $e_A = e_1.\pi(e_2) : \keyw{Unit~with} \{ r. \pi \} \cup \varepsilon_1 \cup \varepsilon_2$ and the following are known:
\begin{itemize}
	\item~$e_1 : \{ \bar r \}~\keyw{with} \varepsilon_1$
	\item~$e_2 : \tau_2~\keyw{with} \varepsilon_2$
	\item~$\pi \in \Pi$
\end{itemize}
We look at the cases for when $e_1$ and $e_2$ are values.
	
		\subcase { $e_1$ is not a value. $e_1 : \{ \bar r \}~\keyw{with} \varepsilon_1$ is a subderivation, so applying the inductive assumption, we have $e_1~|~\varepsilon_A \longrightarrow e_1'~|~\varepsilon_B$. Then applying \textsc{E-OperCall1} to $e_A~|~\varepsilon_A$ we have $e_1.\pi(e_2)~|~\varepsilon_A \longrightarrow e_1'.\pi(e_2)~|~\varepsilon_B$.
		}
		
		\subcase { $e_2$ is not a value. Without loss of generality, $e_1 = v_1$ is a value. $e_2 : \tau_2~\keyw{with} \varepsilon_2$ is a subderivation, so applying the inductive assumption, we have $e_2~|~\varepsilon_A \longrightarrow e_2'~|~\varepsilon_B$. Then applying \textsc{E-OperCall2} to $e_A~|~\varepsilon_A$ we have $v_1.\pi(e_2)~|~\varepsilon_A \longrightarrow v_1.\pi(e_2')$. }
		
		\subcase { $e_1$ and $e_2$ are values. By the Atom lemma, $e_1 = r$ for some $r \in R$. Then applying \textsc{E-OperCall3} to $e_A~|~\varepsilon_A$, we have $r.\pi(v_2)~|~\varepsilon_A \longrightarrow \keywadj{unit}~|~\varepsilon_A \cup \{ r.\pi \}$.\\}
		
	}
	
	\proofcase{\textsc{C-MethCall}} {
Then $e_A = e_1.m_i(e_2)~\keyw{with} \varepsilon_1 \cup \varepsilon_2 \cup~\keywadj{effects}(\tau_2) \cup \varepsilon$ and the following are known:

\begin{itemize}
	\item ~$e_1 : \{ \bar d~\keyw{captures} \varepsilon \}~\keywadj{with}~\varepsilon_1$
	\item ~$e_2 : \tau_2~\keyw{with} \varepsilon_2$
	\item ~$d_i = \keyw{def} m_i(y : \tau_2) : \tau$
\end{itemize}
	We look at the cases for when $e_1$ and $e_2$ are values.
	
		\subcase { $e_1$ is not a value. $e_1 : \{ \bar d~\keyw{captures} \varepsilon \}~\keywadj{with}~\varepsilon_1$ is a subderivation. By the inductive hypothesis, $e_1~|~\varepsilon_A \longrightarrow e_1'~|~\varepsilon_B$. Then applying \textsc{E-MethCall1} to $e_A~|~\varepsilon_A$, we have $e_1.m_i(e_2)~|~\varepsilon_A \longrightarrow e_1'.m_i(e_2)~|~\varepsilon_B$.}
		
		\subcase { $e_2$ is not a value. Without loss of generality, $e_1 = v_1$ is a value. Also, $e_2 : \tau_2~\keyw{with} \varepsilon_2$ is a subderivation. By the inductive hypothesis, $e_2~|~\varepsilon_A \longrightarrow e_2'~|~\varepsilon_B$. Then applying \textsc{E-MethCall2$_d$} to $e_A~|~\varepsilon_A$, we have $v_1.m_i(e_2)~|~\varepsilon_A \longrightarrow v_1.m_i(e_2')~|~\varepsilon_B$. }
		
		\subcase{ $e_1$ and $e_2$ are values. By the Atom lemma, $e_1 = \keywadj{new}_d~x \Rightarrow \overline{ d = e }$. Also, $\keyw{def} m_i(y : \tau_2) : \tau = e_i \in \overline {d = e}$. Then applying \textsc{E-MethCall3$_d$} to $e_A~|~\varepsilon_A$, we have $v_1.m_i(v_2)~|~\varepsilon_A \longrightarrow [v_1/x, v_2/y]e_i~|~\varepsilon_A$ }
	}
}







\thm{Theorem 5.2. (Effect Preservation)}
{If $e_A~|~\varepsilon_A \longrightarrow e_B~|~\varepsilon_B$, then $\varepsilon_A \subseteq \varepsilon_B$. \\\\}
{We can divide reduction rules into three classes of rules based on what they do to the effect-set of a configuration. We consider each.\\

\proofcase{\textsc{E-MethCall3$_d$}, \textsc{E-MethCall3$_{\sigma}$}}{
In these rules $\varepsilon_A = \varepsilon_B$.
}

\proofcase{\textsc{E-MethCall1}, \textsc{E-MethCall2$_{\sigma}$}, \textsc{E-MethCall2$_{d}$}, \textsc{E-OperCall1}, \textsc{E-OperCall2}}{
In these rules the antecedent contains a subreduction of the form $e~|~\varepsilon_A \longrightarrow e'~|~\varepsilon_B$. By the inductive assumption, $\varepsilon_A \subseteq \varepsilon_B$.
}

\proofcase{\textsc{E-OperCall3}}{
We have $\varepsilon_B = \varepsilon_A \cup \{ r.\pi \}$, so $\varepsilon_A \subseteq \varepsilon_B$.
}
}









\thm{Theorem 5.3. (Type Preservation)}
{If $e_A : \tau~\keyw{with} \varepsilon$ and $e_A~|~\varepsilon_A \longrightarrow e_B~|~\varepsilon_B$, then $e_B : \tau~\keyw{with} \varepsilon$. \\\\}
{We first induct on possible derivations of $e_A : \tau ~\keyw{with} \varepsilon$, and then on the rule used to reduce $e_A~|~\varepsilon_A$ to $e_B~|~\varepsilon_B$.\\

	\proofcase{ \textsc{$\varepsilon$-Resource}, \textsc{$\varepsilon$-Var}, \textsc{$\varepsilon$-NewObj}, \textsc{C-NewObj}} {
		$e_A$ is a value, so no reduction rules can be applied to it. The theorem statement is vacuously satisfied.\\ }
	
	\proofcase{\textsc{$\varepsilon$-MethCall$_{\sigma}$}}
	{Then $e_A = e_1.m_i(e_2) : \tau~\keyw{with} \varepsilon_1 \cup \varepsilon_2 \cup \varepsilon$ and the following are true:
\begin{itemize}
	\item $e_A : \tau~\keyw{with} \varepsilon_1 \cup \varepsilon_2 \cup \keywadj{effects}(\tau_2) \cup \varepsilon$
	\item $e_1  : \{ \overline \sigma \}~ \keyw{with} \varepsilon_1$
	\item $e_2 : \tau_2~\keyw{with} \varepsilon_2$
	\item $\sigma_i = \keyw{def} m_i(y : \tau_2) : \tau~ \keyw{with} \varepsilon_3$
\end{itemize}
We do a case analysis on the reduction rules applicable to $e_1.m_i(e_2)$, for $m_i$ an annotated method.

		\subcase{ \textsc{E-MethCall1} Then $e_1~|~\varepsilon_A \rightarrow e_1'~|~\varepsilon_B$. By the inductive assumption $e_1' : \{ \bar \sigma \}~\keyw{with} \varepsilon$. Then by \textsc{$\varepsilon$-MethCall} we have $e_B = e_1'.m_i(e_2) : \tau~\keyw{with} \varepsilon$. }
		
		\subcase{ \textsc{E-MethCall2$_\sigma$} 	Then $e_1 = v_1 = \keywadj{new}_{\sigma}~x \Rightarrow \overline{\sigma = e}$, and $e_2~|~\varepsilon_A \longrightarrow e_2'~|~\varepsilon_B$. By the inductive assumption $e_2' : \tau_2~\keyw{with} \varepsilon_2$. Then by \textsc{$\varepsilon$-MethCall} we have $e_B = v_1.m_i(e_2) : \tau~\keyw{with} \varepsilon$.
		}
		
		\subcase{ \textsc{E-MethCall3$_\sigma$} Then $e_1 = v_1 = \keywadj{new}_{\sigma} \Rightarrow \overline{\sigma = e}$, and $\keyw{def} m_i(y : \tau_2) : \tau~\keyw{with} \varepsilon_3 = e' \in \overline{\sigma = e}$, and $e_2 = v_2$ is a value. 
	
	\noindent	
Now, since we know $e_1  : \{ \overline \sigma \}~ \keyw{with} \varepsilon_1$, the only rule with this conclusion is \textsc{$\varepsilon$-NewObj}. Then the premises of that rule must hold. So $\overline{ \sigma = e }~\keywadj{OK}$. The only rule with this conclusion is \textsc{$\varepsilon$-ValidImpl$_{\sigma}$}. The premises of that rule must hold, so $e' : \tau~\keyw{with} \varepsilon_3$.
		\\ \noindent
			Now, $e_B = [v_1/x, v_2/y]e'$, since the rule \textsc{E-MethCall3} was used. We know $v_1 = e_1$ and $x$ have the same type $\{ \overline \sigma \}~ \keyw{with} \varepsilon_1$. $v_2 = e_2$ and $y$ have the same type $\tau_2~\keyw{with} \varepsilon_2$. So the type of $e'$, which is $\tau~\keyw{with} \varepsilon_3$, is preserved by the substitution. So $e_B : \tau~\keyw{with} \varepsilon_3$. \\ }
}


	\proofcase{\textsc{$\varepsilon$-OperCall$_{\sigma}$}} {Then $e_A = e_1.\pi(e_2) : \keyw{Unit~with} \{ r, \pi \} \cup \varepsilon_1 \cup \varepsilon_2$, and we know:
	\begin{itemize}
		\item $e_1 : \{ \bar r \}~\keyw{with} \varepsilon_1$
		\item $e_2 : \tau_2~\keyw{with} \varepsilon_2$
		\item $\pi \in \Pi$
	\end{itemize}
There are three reduction rules applicable to terms of the form $e_1.\pi(e_2)$ for $\pi$ an operation. We consider each.

	\subcase { \textsc{E-OperCall}. Then $e_1~|~\varepsilon_A \longrightarrow e_1'~|~\varepsilon_B$. By the inductive assumption, $e_1' : \{ \bar r \} ~ \keyw{with} \varepsilon_1$. From these we can apply \textsc{$\varepsilon$-OperCall}, giving $e_B = e_1'.\pi(e_2) : \keyw{Unit~with} \{ r.\pi \} \cup \varepsilon_1 \cup \varepsilon_2$.
	}
	
	\subcase{ \textsc{E-OperCall2}. Then $e_1 = r$ for some $r \in R$ and $e_2~|~\varepsilon_A \longrightarrow e_2'~|~\varepsilon_B$. By the inductive assumption $e_2' : \tau_2~\keyw{with} \varepsilon_2$. From these we can apply \textsc{$\varepsilon$-OperCall}, giving $e_B = r.\pi(e_2')~\keyw{with} \varepsilon$.
		}
	
	\subcase{ \textsc{E-OperCall3}. Then $r.\pi(v)~|~\varepsilon_A \longrightarrow \keywadj{unit}~|~\varepsilon_A \cup \{ r.\pi \}$. By the Atom lemma, $\varepsilon_1 = \varepsilon_2 = \varnothing$, so $e_A : \keyw{Unit~with} \{ r.\pi \}$. By a degenerate case of \textsc{$\varepsilon$-NewObj}, $\keywadj{unit} : \keyw{Unit~with} \varnothing$. \textbf{But this isn't the same type as $e_A$. After performing an operation you lose the effect from the type information, but gain it in the runtime information. Should the statement really be reworded to say that you don't lose effect annotations as you reduce, except when performing an operation at which point the runtime gains something from the type info (and that type info is allowed to be discarded). We can use the fact that once you call an operation, evaluation (on this particular configuration) must stop, so the only time we discard effect annotations for a configuration is when it's about to terminate} \\}	
}
	
	\proofcase{\textsc{C-MethCall}} { Then $e_A = e_1.m_i(e_2)$ and the following are known:
	\begin{itemize}
		\item $e_A : \tau~\keyw{with} \varepsilon_1 \cup \varepsilon_2 \cup \keywadj{effects}(\tau_2) \cup \varepsilon$
		\item $e_1 : \{ \bar d~\keyw{captures} \varepsilon \}~\keyw{with} \varepsilon_1$
		\item $e_2 : \tau_2~\keyw{with} \varepsilon_2$
		\item $d_i = \keyw{def} m_i(y : \tau_2) : \tau$
	\end{itemize}
	
	We do a case analysis on the reduction rules applicable to $e_1.m(e_2)$, for $m_i$ an unannotated method.
	
	\subcase{ \textsc{E-MethCall1}
		Then $e_1.m_i(e_2)~|~\varepsilon_A \longrightarrow e_1'.m_i(e_2)~|~\varepsilon_B$. By the inductive assumption $e_1'$ types to the same as $e_1$. Then applying $\textsc{C-MethCall}$ we get $\keywadj{type}(e_B) = \keywadj{type}(e_A)$.
	}
	
	\subcase{ \textsc{E-MethCall2$_d$}
		Then $e_1 = v_1$ some value and $v_1.m_i(e_2)~|~\varepsilon_A \longrightarrow v_1.m_i(e_2')$. By the inductive assumption $\keywadj{type}(e_2') = \keywadj{type}(e_2)$. Then applying \textsc{C-MethCall} we get $\keywadj{type}(e_B) = \keywadj{type}(e_A)$.
	}		
	
	\subcase{ \textsc{E-MethCall3$_d$} Then $v_1.m_i(v_2)~|~\varepsilon_A \longrightarrow [v_1/x, v_2/y]e_i~|~\varepsilon_B$, where $e_i$ is the body of method $m_i$. Now $e_1$ has the type $\{ \bar d~\keyw{captures} \varepsilon \}~\keyw{with} \varepsilon_1$, and the only rule matching this judgement is \textsc{C-NewObj}. So the premises of that rule, applied to $e_1$, must be true.
	\\ \noindent
Firstly this means $\overline{d = e}~\keywadj{OK}$, so $d_i = e_i~\keywadj{OK}$.
	\\ \noindent
\textbf{But what happens to the effects? $e_i$ and $\tau$ could be anything and there are no rules for effect-checking isolated expressions. Is there a smarter way than proceeding by case analysis on $e_i$ and $\tau$?}
}
		
	}
}


\thm{Theorem 5.4 (Soundness Of Effects).}
{If $e_A : \tau~\keyw{with} \varepsilon$ and $e_A~|~\varepsilon_A \longrightarrow e_B~|~\varepsilon_B$, then $\varepsilon_B \setminus \varepsilon_A \subseteq \varepsilon$. \\ \\}
{By the Effect Preservation Theorem, $\varepsilon_A \subseteq \varepsilon_B$. Now proceed by structural induction on the evaluation rule.\\

	\proofcase{\textsc{E-MethCall3$_d$}, \textsc{E-MethCall3$_\sigma$}} {
	In these rules $e_A = e_B$. Then $e_B \setminus e_A = \varnothing$, so $e_B \setminus e_A \subseteq \varepsilon$ is vacuously true.
	}
	
	\proofcase{\textsc{E-OperCall1}} {
		Then $e_1~|~\varepsilon_A \longrightarrow e_1'~|~\varepsilon_B$. Theorem holds by the inductive assumption.
}
	
	\proofcase{\textsc{E-OperCall2}} {
		Then $\exists r \in R \mid e_1 = r$ and $r.\pi(e_2) \longrightarrow r.\pi(e_2')$ and $e_2~|~\varepsilon_A \longrightarrow e_2'~|~\varepsilon_B$. Theorem holds by the inductive assumption.
	}

	\proofcase{\textsc{E-OperCall3}} {
		Then $\varepsilon_B = \varepsilon_A \cup \{ r.\pi \}$, so we have to show $r.\pi \in \varepsilon$. From the Atom lemma, $r : \{ r \}~ \keyw{with} \varnothing$ and $v : \tau_2~ \keyw{with} \varnothing$, for some $\tau_2$. By applying \textsc{$\varepsilon$-OperCall} then $r.m(\pi) : \{ r.\pi \} \cup \varnothing \cup \varnothing$. So $\varepsilon = \{ r.\pi \}$.
	}
	
	\proofcase{\textsc{E-MethCall1}} {
		Then $e_1~|~\varepsilon_A \longrightarrow e_1'~|~\varepsilon_B$. Theorem holds by the inductive assumption.
	}

	\proofcase{\textsc{E-MethCall2$_\sigma$}} {
		Then $e_1 = v$ some value and $e_2~|~\varepsilon_A \longrightarrow e_2'~|~\varepsilon_B$. Theorem holds by the inductive assumption.
	}
	
	\proofcase{\textsc{E-MethCall2$_d$}} {
		Then $e_1 = v = \keywadj{new}_d~x \Rightarrow \overline {d = e}$ and $e_2~|~\varepsilon \longrightarrow e_2'~|~\varepsilon_B$. Theorem holds by inductive assumption.
	}
}

\end{document}
