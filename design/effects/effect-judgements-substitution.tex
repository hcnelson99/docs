\documentclass{llncs}

\usepackage{listings}
\usepackage{proof}
\usepackage{amssymb}
\usepackage[margin=.9in]{geometry}
\usepackage{amsmath}
\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage{enumitem}
\usepackage{filecontents}
\usepackage{calc}
\usepackage[linewidth=0.5pt]{mdframed}
\usepackage{changepage}
\allowdisplaybreaks

\usepackage{fancyhdr}
\renewcommand{\headrulewidth}{0pt}
\pagestyle{fancy}
 \fancyhf{}
\rhead{\thepage}

\lstset{tabsize=3, basicstyle=\ttfamily\small, commentstyle=\itshape\rmfamily, numbers=left, numberstyle=\tiny, language=java,moredelim=[il][\sffamily]{?},mathescape=true,showspaces=false,showstringspaces=false,columns=fullflexible,xleftmargin=5pt,escapeinside={(@}{@)}, morekeywords=[1]{objtype,module,import,let,in,fn,var,type,rec,fold,unfold,letrec,alloc,ref,application,policy,external,component,connects,to,meth,val,where,return,group,by,within,count,connect,with,attr,html,head,title,style,body,div,keyword,unit,def}}
\lstloadlanguages{Java,VBScript,XML,HTML}

\newcommand{\keywadj}[1]{\mathtt{#1}}
\newcommand{\keyw}[1]{\keywadj{#1}~}
\newcommand{\reftt}{\mathtt{ref}~}
\newcommand{\Reftt}{\mathtt{Ref}~}
\newcommand{\inttt}{\mathtt{int}~}
\newcommand{\Inttt}{\mathtt{Int}~}
\newcommand{\stepsto}{\leadsto}
\newcommand{\todo}[1]{\textbf{[#1]}}
\newcommand{\intuition}[1]{#1}
\newcommand{\hyphen}{\hbox{-}}

%\newcommand{\intuition}[1]{}

\newlist{pcases}{enumerate}{1}
\setlist[pcases]{
  label=\fbox{\textit{Case}}\protect\thiscase\textit{:}~,
  ref=\arabic*,
  align=left,
  labelsep=0pt,
  leftmargin=0pt,
  labelwidth=0pt,
  parsep=0pt
}
\newcommand{\pcase}[1][]{

  \if\relax\detokenize{#1}\relax
    \def\thiscase{}
  \else
    \def\thiscase{~\fbox{#1:}}
  \fi
  \item
}

\newcommand{\thm}[3]{
	\begin{large}
		\bf{#1}
	\end{large} \\\\
	\fbox{Statement.} ~ #2
	\fbox{Proof.}~ #3 \qed
}

\newcommand{\proofcase}[2]{
	\begin{adjustwidth}{1.5em}{0pt}
		\fbox{Case.}~~#1. \\ ~#2
	\end{adjustwidth}
}

\newcommand{\subcase}[1] {
	\begin{adjustwidth}{2.2em}{0pt}
		\underline{Subcase.} #1
	\end{adjustwidth}
}

\newcommand{\stmt}[1] {

\begin{adjustwidth}{2.5em}{0pt}
	#1
\end{adjustwidth}

}



\begin{document}

\today
\section{Effects}

\paragraph{}
Fix some set of resources $R$. A resource is some language primitive that has the authority to directly perform I/O operations. Elements of the set $R$ are denoted by $r$. $\Pi$ is a fixed set of operations on resources. Its members are denoted $\pi$. An effect is a member of the set of pairs $R \times \Pi$. A set of effects is denoted by $\varepsilon$. In this system we cannot dynamically create resources or resource-operations.

\paragraph{}
Throughout we refer to the notions of effects and captures. A piece of code $C$ has the effect $(r, \pi)$ if operation $\pi$ is performed on resource $r$ during execution of $C$. $C$ captures the effect $(r, \pi)$ if it has the authority to perform operation $\pi$ on resource $r$ at some point during its execution.

\paragraph{}
We use $r.\pi$ as syntactic sugar for the effect $(r,\pi)$. For example, $FileIO.append$ instead of $(FileIO, append)$.

\paragraph{}
Types are either resources or structural. Structural types have a set of method declarations. An object of a particular structural type $\{ \bar \sigma \}$ can have any of the methods defined by $\sigma$ invoked on it. The structural type $\varnothing$ with no methods is called $\keywadj{Unit}$.

\paragraph{}
We assume there are constructions of the familiar types using the basic structural type $\varnothing$ and method declarations (for example, $\mathbb{N}$ could be made using $\varnothing$ and a $\keywadj{successor}$ function, Peano-style).

\paragraph{}
Note the distinction between methods (usually denoted $m$) and operations (usually denoted $\pi$). An operation can only be invoked on a resource; resources can only have operations invoked on them. A method can only be invoked on an object; objects can only have methods invoked on them.

\paragraph{}
We make a simplifying assumption that every method/lambda takes exactly one argument. Invoking some operation $\pi$ on a resource returns $\varnothing$.



\newpage

\section{Static Semantics For Fully-Annotated Programs}

\paragraph{}
In this first system every method in the program is explicitly annotated with its set of effects.

\subsection{Grammar}

\[
\begin{array}{lll}
\begin{array}{lllr}

	e & ::= & x & expressions \\
  		& | & r \\
  		& | & \keywadj{new}~x \Rightarrow \overline{\sigma = e} \\
  		& | & e.m(e)\\
  		& | & e.\pi(e)\\
		&&\\

	\tau & ::= & \{ \bar \sigma \} ~ | ~ \{ \bar r \} & types \\
		&&\\

	\sigma & ::= &  \keyw{def} m(x:\tau):\tau~\keyw{with}\varepsilon  & labeled~ decls.\\
		&&\\
		
	\Gamma & ::= & \varnothing \\
		& | & \Gamma,~x : \tau\\
		&&\\

\end{array}
& ~~~~~~
&
\end{array}
\]


\noindent \textbf{Notes:}

\begin{itemize}
	\item All declarations ($\sigma$-terms) are annotated by what effects they have.
	\item All methods (and lambda expressions) take exactly one argument. If a method specifies no argument the argument is assumed to be of type $\keywadj{Unit}$.
	\item $\pi$ is the name of an operation from the set $\Pi$; $m$ is the name of a method.
	\item The type $\{ \bar r \}$ is an (indeterminate) set of resources; there will only be one actual resource at run-time, and it will be one of the resources in the set.
\end{itemize}

\subsection{Rules}

\fbox{$\Gamma \vdash e : \tau~\keyw{with} \varepsilon$}

\[
\begin{array}{c}
\infer[\textsc{($\varepsilon$-Var)}]
  {\Gamma,~x:\tau \vdash x:\tau~ \keyw{with} \varnothing}
  {} 
~~~~~~~~~~
\infer[\textsc{($\varepsilon$-Resource)}]
  {\Gamma,~r :\{r\} \vdash r:\{ r \} ~ \keyw{with} \varnothing}
  {r \in R} \\[5ex]

\infer[\textsc{($\varepsilon$-NewObj)}]
	{\Gamma \vdash \keywadj{new}~x \Rightarrow \overline{\sigma = e} : \{ \bar \sigma \}~\keyw{with} \varnothing}
	{\Gamma,~x : \{ \bar \sigma \} \vdash \overline{\sigma = e}~\keywadj{OK}} \\[5ex]

\infer[\textsc{($\varepsilon$-OperCall)}]
	{\Gamma \vdash e_1.\pi(e_2) : \keyw{Unit} \keyw{with} \{ \bar r.\pi \} \cup \varepsilon_1 \cup \varepsilon_2}
	{\Gamma \vdash e_1 : \{ \bar r \}~ \keyw{with} \varepsilon_1 & \Gamma \vdash e_2:\tau_2~\keyw{with} \varepsilon_2 & \pi \in \Pi} \\[5ex]
	
\infer[\textsc{($\varepsilon$-MethCall$_\sigma$)}]
	{\Gamma \vdash e_1.m_i(e_2):\tau_3~\keyw{with} \varepsilon_1 \cup \varepsilon_2 \cup \varepsilon_3}
	{\Gamma \vdash e_1 : \{ \bar \sigma \}~\keyw{with} \varepsilon_1 & \Gamma \vdash e_2 : \tau_2~\keyw{with} \varepsilon_2 & \sigma_i = \keyw{def} m_i(y:\tau_2):\tau_3~\keyw{with} \varepsilon_3}

\end{array}
\]

$\fbox{$\Gamma \vdash \sigma = e~\keyw{OK}$}$

\[
\begin{array}{c}
\infer[\textsc{($\varepsilon$-ValidImpl$_\sigma$)}]
	{\Gamma \vdash \sigma = e~\keywadj{OK}}
	{\Gamma,~y:\tau_2 \vdash e: \tau_3~\keyw{with} \varepsilon_3 & \sigma = \keyw{def} m(y:\tau_2):\tau_3~\keyw{with} \varepsilon_3} \\[5ex]
\end{array}
\]

\noindent \textbf{Notes:}

\begin{itemize}
	\item In \textsc{$\varepsilon$-Var}, \textsc{$\varepsilon$-Resource}, and \textsc{$\varepsilon$-NewObj} the consequent has an expression typed with no effect; merely possessing a (transitive) capability for an object is not a effect. You must do something with it in order to possibly have an effect.
	\item \textsc{$\varepsilon$-ValidImpl} says that the return type and effects of the body of a method must agree with what its signature says.
\end{itemize}



% ========================================
% Partially-Annotated Programs
% ========================================

\newpage

\section{Static Semantics For Partly-Annotated Programs}

\paragraph{}
In the next system we allow objects which have no effect-annotated methods. If an object has no annotations on its methods, the extra rules below can give a conservative effect inference on what it captures. If an object is fully annotated, the rules from the previous section can be used. There is no inbetween; partially-annotated objects are not allowed.

\subsection{Grammar}

\[
\begin{array}{lll}

\begin{array}{lllr}

e & ::= & x & expressions \\
  		& | & r \\
		& | & \keywadj{new}_\sigma~x \Rightarrow \overline{\sigma = e} \\
 		& | & \keywadj{new}_d~x \Rightarrow \overline{d = e} \\
 		& | & e.m(e)\\
 		& | & e.\pi(e)\\
		&&\\

\tau & ::= & \{ \bar \sigma \} & types \\
		& | & \{ \bar r \} \\
		& | & \{ \bar d \} \\
		& | & \{ \bar d ~\keyw{captures} \varepsilon \} \\
		&&\\
		
\sigma & ::= & d~\keyw{with}\varepsilon  & labeled~ decls.\\
		&&\\

d & ::= & \keyw{def} m(x:\tau):\tau & unlabeled~decls.\\
		&&\\

\end{array}
& ~~~~~~
&
\end{array}
\]

\noindent \textbf{Notes:}
\begin{itemize}
	\item $\sigma$ denotes a declaration with effect labels; $d$ a declaration without effect labels.
	\item $\keywadj{new}_\sigma$ is for creating annotated objects; $\keywadj{new}_d$ for unannotated objects.
	\item $\{ \bar \sigma \}$ is the type of an annotated object. $\{ \bar d \}$ is the type of an unannotated object.
	\item $\{ \bar d ~\keyw{captures} \varepsilon \}$ is a special kind of type that doesn't appear in source programs but may be assigned by the new rules in this section. Intuitively, $\varepsilon$ is an upper-bound on the effects captured by $\{ \bar d \}$.
\end{itemize}

\subsection{Rules}

$\fbox{$\Gamma \vdash e : \tau$}$

\[
\begin{array}{c}
\infer[\textsc{(T-Var)}]
	{\Gamma,~x : \tau \vdash x : \tau}
	{}
~~~~~~~~~~
\infer[\textsc{(T-Resource)}]
	{\Gamma,~r : \{ \bar r \} \vdash r : \{ \bar r \}}
	{r \in R} \\[5ex]
~~~~~~~~~~
\infer[\textsc{(T-MethCall$_r$)}]
	{\Gamma \vdash r.\pi(e_1) : \keywadj{Unit}}
	{\Gamma \vdash r : \{ \bar r \} & \Gamma \vdash e : \tau & m \in M} \\[5ex]
~~~~~~~~~~
\infer[\textsc{(T-MethCall$_\sigma$)}]
	{\Gamma \vdash e_1.m(e_2) : \tau_3}
	{\Gamma \vdash e_1 : \{ \bar \sigma \},~\keyw{def} m(y : \tau_2) : \tau_3~\keyw{with} \varepsilon_3 \in \{ \bar \sigma \} &  \Gamma \vdash e_2 : \tau_2 }\\[5ex]
~~~~~~~~~~
\infer[\textsc{(T-MethCall$_d$)}]
	{\Gamma \vdash e_1.m(e_2) : \tau_3}
	{\Gamma \vdash e_1 : \{ \bar d\},~\keyw{def} m(y : \tau_2) : \tau_3 \in \{ \bar d \} &  \Gamma \vdash e_2 : \tau_2 }\\[5ex]
~~~~~~~~~~

~~~~~~~~~~
\infer[\textsc{(T-New$_\sigma$)}]
	{\Gamma \vdash~\keywadj{new}_\sigma~x \Rightarrow \overline{\sigma = e} : \{ \bar \sigma \}}
	{\Gamma \vdash \sigma_i = e_i~\keywadj{OK}}
~~~~~~~~~~
\infer[\textsc{(T-New$_d$)}]
	{\Gamma \vdash~\keywadj{new}_d~x \Rightarrow \overline{d = e} : \{ \bar d \}}
	{\Gamma \vdash d_i = e_i~\keywadj{OK}}\\[5ex]
\end{array}
\]

$\fbox{$\Gamma \vdash d = e~\keyw{OK}$}$
\[
\begin{array}{c}
\infer[\textsc{($\varepsilon$-ValidImpl$_d$)}]
	{\Gamma \vdash d = e~\keywadj{OK}}
	{d = \keyw{def} m(y : \tau_2) : \tau_3 & \Gamma, y : \tau_2 \vdash e : \tau_3}
	\\[5ex]
\end{array}
\]

\fbox{$\Gamma \vdash e : \tau~\keyw{with} \varepsilon$}

\[
\begin{array}{c}
\infer[\textsc{(C-NewObj)}]
	{\Gamma \vdash~\keywadj{new}_d~x \Rightarrow \overline{d = e} : \{  \bar d~\keyw{captures} \varepsilon_x \} ~\keyw{with} \varnothing }
	{\varepsilon_x = \keywadj{effects}(\Gamma') & \Gamma' \subseteq \Gamma & \Gamma', x : \{ \bar d~\keyw {captures} \varepsilon_x \} \vdash \overline{d = e}~\keyw{OK}} \\[5ex]
\end{array}
\]

\[
\begin{array}{c}
\infer[\textsc{(C-MethCall)}]
	{\Gamma \vdash e_1.m_i(e_2) : \tau_3~ \keyw{with} \varepsilon_1 \cup \varepsilon_2 \cup effects(\tau_2) \cup \varepsilon_c}
	{\Gamma \vdash e_1 : \{ \bar d~\keyw{captures} \varepsilon_c \}~\keyw{with} \varepsilon_1 & \Gamma \vdash e_2:\tau_2~\keyw{with} \varepsilon_2&d_i =~\keyw{def} m_i(y:\tau_2):\tau_3 } \\[5ex]
\end{array}
\]

\[
\begin{array}{c}
\infer[\textsc{(C-ConservativeTyping)}]
	{\Gamma \vdash e : \tau ~\keyw{with} \keywadj{effects}(\Gamma') }
	{\Gamma' \subseteq \Gamma & \Gamma \vdash e : \tau } \\[5ex]
\end{array}
\]

\noindent \textbf{Notes:}

\begin{itemize}
	\item The system includes the rules from the fully-annotated system.
	\item Rules with the judgement form do standard typing of objects, without any effect analysis. Their sole use is in the $\varepsilon$-ValidImpl$_d$ rule.
	\item In applying \textsc{C-NewObj}, $\Gamma$ is the current context. The variable $\Gamma'$ is some sub-context. A good choice of sub-context is $\Gamma$ restricted to the free variables in the method-body being typechecked. This tightens the upper-bound to exclude resources never used in the program.
	\item To perform effect analysis on an unannotated object $\{ \bar d \}$, figure out what it captures using $\textsc{C-NewObj}$, yielding the type $\{ \bar d~\keyw{captures} \varepsilon \}$. Then, when a method is called on that object, \textsc{C-MethCall} can be applied.
	\item \textsc{C-ConservativeTyping} is used to effect-type unannotated portions of code. It essentially says that in the absence of any effect information, you can assume its effects as $\keywadj{effects(Gamma')}$, a safe upper-bound for some relevant choice of $\Gamma'$.
\end{itemize}

\subsection{Effects Function}

\noindent
The $\keywadj{effects}$ function returns the set of effects in a particular context. \\

\noindent
A method $m$ can return a resource $r$ (directly or via some enclosing object). Returning a resource isn't an effect but it means any unannotated program using $m$ also captures $r$. To account for this, when the $\keywadj{effects}$ function is operating on a type $\tau$ it must analyse the return type of the method declarations in $\tau$. Since the resource might be itself enclosed by an object, we do a recursive analysis.

\begin{itemize}
	\item $\keywadj{effects}(\varnothing) = \varnothing$
	\item $\keywadj{effects}(\Gamma, x : \tau) = \keywadj{effects}(\Gamma) \cup \keywadj{effects}(\tau)$
	\item $\keywadj{effects}(\{\bar r\}) = \{ (r, \pi) \mid r \in \bar r, \pi \in \Pi \}$
	\item $\keywadj{effects}(\{\bar \sigma\}) = \bigcup_{\sigma \in \bar \sigma}~\keywadj{effects}(\sigma)$
	\item $\keywadj{effects}(\{\bar d\}) = \bigcup_{d \in \bar d}~\keywadj{effects}(d)$
	\item $\keywadj{effects}(d~\keyw{with} \varepsilon) = \varepsilon \cup \keywadj{effects}(d)$
	\item $\keywadj{effects}(\keywadj{def~m}(x : \tau_1) : \tau_2) = \keywadj{effects}(\tau_2)$
	\item $\keywadj{effects}(\{\bar d ~\keyw{captures} \varepsilon\}) = \varepsilon$
\end{itemize}

\noindent \textbf{Notes:}
\begin{itemize}
	\item In the last case, it is not necessary to recurse to sub-declarations; the type $\{ \bar d~\keyw{captures} \varepsilon \}$ can only result from \textsc{C-NewObj}. In that case, $\varepsilon$ is already an estimate of what the object captures in some context $\Gamma_0$; furthermore, the current $\Gamma$ may be bigger than $\Gamma_0$, in which case re-annotating the object would introduce more effects and lose precision.
\end{itemize}
\newpage


\section{Dynamic Semantics}

\subsection{Terminology}

\begin{itemize}
	\item The runtime effects are what actually happens when the program is executed; the static effect annotations are an estimate of what will happen at runtime (our eventual aim is to show the static annotations are safe).
	\item If $e$ is an expression then $[e_1/x_1]e$ is a new expression, the same as e, with every free occurrence of $x_1$ replaced by $e_1$. $[e_1/x_1, ..., e_n/x_n]e$ is syntactic sugar for repeated one-variable substitution: $[e_1/x_1]...[e_n/x_n]e$.
	\item $\varnothing$ is the empty set. The empty type is denoted $\keywadj{Unit}$. Its single instance is $\keywadj{unit}$.
\end{itemize}

\subsection{Grammar}

\[
\begin{array}{lll}
\begin{array}{lllr}
	e & ::= & x & expressions \\
  		& | & e.m(e)\\
  		& | & e.\pi(e)\\
		& | & v \\
		&&\\
		
	v & ::= & r & values \\
  		& | & \keywadj{new}_{\sigma}~x \Rightarrow \overline{\sigma = e} \\
  		& | & \keywadj{new}_d~x \Rightarrow \overline{d = e} \\
		&&\\

\end{array}
& ~~~~~~
&

\begin{array}{lllr}

	d & ::= & \keyw{def} m(x:\tau):\tau & unlabeled~decls.\\		&&\\
		
	\sigma & ::= & d~\keyw{with}\varepsilon  & labeled~ decls.\\
		&&\\
	\tau & ::= & \{ \bar \sigma \}  & types \\
		& | & \{ \bar r \} \\
		&&\\

	\Gamma & :: = & \varnothing & contexts\\
		& | & \Gamma,~x : \tau\\
		&&\\

&&\\

\end{array}
\end{array}
\]

\subsection{Rules}


\fbox{$e \longrightarrow e~|~\varepsilon$}


\[
\begin{array}{lll}

	\infer[\textsc{(E-MethCall1)}]
		{e_1.m(e_2) \longrightarrow e_1'.m(e_2)~|~\varepsilon}
		{e_1 \longrightarrow e_1'~|~\varepsilon}\\[5ex]

	\infer[\textsc{(E-MethCall2$_{\sigma}$)}]
		{v_1.m(e_2) \longrightarrow v_1.m(e_2')~|~\varepsilon}
		{v_1 = \keywadj{new}_{\sigma}~x \Rightarrow \overline{\sigma = e} & e_2 \longrightarrow e_2'~|~\varepsilon}
				
		~~~~~~
	\infer[\textsc{(E-MethCall2$_d$)}]
		{v_1.m(e_2) \longrightarrow v_1.m(e_2')~|~\varepsilon}
		{v_1 = \keywadj{new}_{d}~x \Rightarrow \overline{d = e} & e_2 \longrightarrow e_2'~|~\varepsilon}
		\\[5ex]
		
	\infer[\textsc{(E-MethCall3$_{\sigma}$)}]
		{v_1.m(v_2)
			\longrightarrow
		 [v_1/x, v_2/y]e~|~\varnothing}
  		{v_1 = \keywadj{new}_{\sigma}~x \Rightarrow \overline{\sigma = e} & \keywadj{def~m}(y: \tau_1) : \tau_2~\keyw{with} \varepsilon = e \in \overline {\sigma = e}} \\[5ex]

	\infer[\textsc{(E-MethCall3$_{d}$)}]
		{v_1.m(v_2)
			\longrightarrow
		 [v_1/x, v_2/y]e~|~\varnothing}
  		{v_1 = \keywadj{new}_{d}~x \Rightarrow \overline{d = e} & \keywadj{def~m}(y: \tau_1) : \tau_2 = e \in \overline {d = e}} \\[5ex]
			
	\infer[\textsc{(E-OperCall1)}]
		{e_1.\pi(e_2)
			\longrightarrow
		 e_1'.\pi(e_2)~|~\varepsilon}
		{e_1 \longrightarrow e_1'~|~\varepsilon}
~~~~~~
			\infer[\textsc{(E-OperCall2)}]
		{r.\pi(e_2)
			\longrightarrow
		 r.\pi(e_2')~|~\varepsilon}
		{e_2 \longrightarrow e_2'~|~\varepsilon} \\[5ex]
			
			\infer[\textsc{(E-OperCall3)}]
		{r.\pi(v)
			\longrightarrow
		 \keywadj{unit}~|~\{r.\pi\}}
		{r \in R & \pi \in \Pi} \\[5ex]
			
\end{array}
\]



\fbox{$e \longrightarrow_* e~|~\varepsilon$}

\[
\begin{array}{lll}

	\infer[\textsc{(E-MultiStep1)}]
	{e \longrightarrow_* e~|~\varnothing}
	{} ~~~~~~~~
	
	\infer[\textsc{(E-MultiStep2)}]
	{e \longrightarrow_* e'~|~\varepsilon}
	{e \longrightarrow e'~|~\varepsilon} \\[5ex]

	\infer[\textsc{(E-MultiStep3)}]
	{e \longrightarrow_* e''~|~\varepsilon_1 \cup \varepsilon_2}
	{e \longrightarrow_* e'~|~\varepsilon_1 & e' \longrightarrow_* e''~|~\varepsilon_2}

\end{array}
\]

\noindent \textbf{Notes:}
\begin{itemize}
	\item A multi-step involves \textit{zero} or more applications of a small-step.
	\item Multi-step rules accumulate the run-time effects produced by the individual small-steps.
	\item The only rule which produces effects is \textsc{E-OperCall3} (the rule for evaluating operations on resources).
	\item Method calls are evaluated by performing substitution on the body of the method, and evaluating that.
\end{itemize}

\newpage

\newpage

\section{Theorems}

\ 
\thm{Lemma 5.1. (Canonical Forms)}
{Suppose $e$ is a value. The following are true:
	\begin{itemize}
	\item If $\Gamma \vdash e : \{ \bar r \}~\keyw{with} \varepsilon$, then $\exists r \in R \mid e = r$.
	\item If $\Gamma \vdash e : \{ \bar \sigma \} \keyw{with} \varepsilon$, then $e = \keywadj{new}_{\sigma}~x \Rightarrow \overline{\sigma = e}$.
	\item If $\Gamma \vdash e : \{ \bar d~\keyw{captures} \varepsilon_1 \}~ \keyw{with} \varepsilon$, then $e = \keywadj{new}_{d}~x \Rightarrow \overline{ d = e }$.
	\end{itemize}
Furthermore, $\varepsilon = \varnothing$ in each case. \\\\
}
{ These typing judgements each appear exactly once, in the conclusion of different rules. The result follows by inversion of \textsc{$\varepsilon$-Resource}, \textsc{$\varepsilon$-NewObj}, and \textsc{C-NewObj} respectively. \\
}


%\thm{Lemma 5.2. (Component)}
%{The following are true.
%\begin{itemize}
%	\item If $e_1 = \keywadj{new}_{\sigma}~x %\Rightarrow \{ \overline{\sigma = e} \}$ and %$e_1 : \{ \bar \sigma \}~\keyw{with} %\varepsilon$, then for any $\keywadj{def~m_i}(y : \tau_1) : \tau_2~ \keyw{with} \varepsilon_i = e_i \in \overline {\sigma = e}$, $e_i : \tau_2~\keyw{with} \varepsilon_i$.
%	\item If $e_1 = \keywadj{new}_{d}~x \Rightarrow \{ \overline{d = e} \}$ and $e_1 : \{ \bar d \}~\keyw{with} \varepsilon$, then for any $\keywadj{def~m_i}(y : \tau_1) : \tau_2~ \keyw{with} \varepsilon_i = e_i \in \overline {\sigma = e}$, $e_i : \tau_2~\keyw{with} \varepsilon_i$
%\end{itemize}
%}
%{hi}

\begin{large}
	\bf{Definition. (Substitution)}
\end{large}

$[e'/z]e$ means 'substitute every free occurrence of $x$ in $e$ for $e'$. A definition over the grammar is as follows.

\begin{itemize}
	\item $[e'/z]z = e'$
	\item $[e'/z]r = r$
	\item $[e'/z](e_1.m(e_2)) = ([e'/z]e_1).m([e'/z]e_2)$
	\item $[e'/z](e_1.\pi(e_2)) = ([e'/z]e_1).\pi([e'/z]e_2)$
	\item $[e'/z](\keyw{new_\sigma} x \Rightarrow \overline {\sigma = e}) = ...$
\end{itemize}

(But that last one----if z and x happen to be the same variables we don't want to sub out x because it's the 'this' variable. Needs a bit more thought, consult the almighty TAPL) \\

\thm{Lemma 5.2. (Substitution)}
{If $\Gamma, z : \tau' \vdash e : \tau~\keyw{with} \varepsilon$, and $\Gamma \vdash e' : \tau'~\keyw{with} \varepsilon'$, then $\Gamma \vdash [e'/z]e : \tau~\keyw{with} \varepsilon$. \\\\}
{By structural induction on possible derivations of $\Gamma \vdash e : \tau_1~\keyw{with} \varepsilon_1$. First, if $z$ does not appear in $e$ then $[e'/z]e = e$, so the statement holds vacuously. So without loss of generality we assume $z$ appears somewhere in $e$ and consider the last rule used in the derivation, and then the location of $z$. \\

	\proofcase{\textsc{$\varepsilon$-Var}} {
		Then $[e'/z]z = e_1$. By assumption $\Gamma \vdash e' : \tau~\keyw{with} \varepsilon$, so $\Gamma \vdash [e'/z]z = e$. \\
	}
		
	\proofcase{\textsc{$\varepsilon$-Resource}} {
		Then $\exists r \in R \mid e = r$, however $\keywadj{freevars}(r) = \varnothing$, so the statement holds vacuously.\\
	}
		
	\proofcase{\textsc{$\varepsilon$-NewObj}} {
		Then $e = \keyw{new} x \Rightarrow \overline{\sigma =e}$. \\
		
		\noindent
		 $z$ appears in some method body $e_i$. By inversion we know $\Gamma, x : \{ \bar \sigma \} \vdash \overline {\sigma = e}~\keywadj{OK}$. The only rule with this conclusion is \textsc{$\varepsilon$-ValidImpl$_\sigma$}; by inversion on that we have:
		 \begin{itemize}
		 	\item $\Gamma, y : \tau_1 \vdash e_i : \tau_2~\keyw{with} \varepsilon$
		 	\item $\sigma = \keyw{def} m_i(y : \tau_1) : \tau_2~\keyw{with} \varepsilon$
		\end{itemize}
	$\Gamma, z : \tau$ can be used to prove $\sigma_i = e_i~\keywadj{OK}$ via the inductive assumption. By an application of \textsc{$\varepsilon$-ValidImpl$_\sigma$} we may type the substituted object declaration. Then by \textsc{$\varepsilon$-NewObj} we type $[e'/z]e$ to the same as the original.\\
	}
	
	\proofcase{\textsc{$\varepsilon$-OperCall}} {
		Then $e = e_1.\pi(e_2)$. The variable $z$ must appear in $e_1$ or $e_2$. By rule inversion we have a sub-derivation for the type of both sub-expressions. If we perform substitution on both, the inductive assumption applies, yielding the same types for $[e'/z]e_1$ and $[e'/z]e_2$. Then \textsc{$\varepsilon$-OperCall} types the substituted operation call to the same as the original. \\
	}

	\proofcase{\textsc{$\varepsilon$-MethCall$_\sigma$}} {
		Then $e =e _1.m_i(e_2)$. The variable $z$ must appear in $e_1$ or $e-2$. By rule inversion we have a sub-derivation for both; we may type the substituted sub-expressions to the same as the original. Then by applying \textsc{$\varepsilon$-MethCall} on the substituted sub-expressions we type $[e'/z]e_2$ to the same as the original. \\
	}
		
	\proofcase{\textsc{C-MethCall}} {
		Same as above case; it's not important that the receiver's declarations are unannotated because substitution only applies to expressions. \\
	}
	
	\proofcase{\textsc{C-NewObj}} {
		Same as for the rule \textsc{$\varepsilon$-NewObj}; it's not important that the receiver's declarations are unannotated because substitution only applies to expressions.
	}
}

\noindent
\fbox{Corollary.} If $\Gamma, z_i : \tau'_i \vdash e : \tau~\keyw{with} \varepsilon$, and $\Gamma \vdash e'_i : \tau'_i~\keyw{with} \varepsilon'_i$, then $\Gamma \vdash [e'_1/z_1, ..., e'_n/z_n]e : \tau~\keyw{with} \varepsilon$. This follows by the definition $[e'_1/z_1, ..., e'_n/z_n]e = [e'_1]...[e'_n]e$ and induction on the length $n$. \\














\thm{Theorem 5.3. (Progress)}
{If $\Gamma \vdash e_A : \tau_A~\keyw{with} \varepsilon_A$, either $e_A$ is a value or a small-step $e_A \longrightarrow e_B~|~\varepsilon$ can be applied. \\\\}
{By structural induction on possible derivations of $\Gamma \vdash e_A : \tau_A~\keyw{with} \varepsilon_A$. We consider the last rule used. \\

	\proofcase{\textsc{$\varepsilon$-Var}, \textsc{$\varepsilon$-Resource}, \textsc{$\varepsilon$-NewObj}, \textsc{C-NewObj}} {
		Then $e_A$ is a value. \\
	}
		
	\proofcase{\textsc{$\varepsilon$-MethCall}} {
		Then $e_A = e_1.m_i(e_2)$ and the following are known:
		\begin{itemize}
			\item~$e_A : \tau_3~\keyw{with} \varepsilon_1 \cup \varepsilon_2 \cup \varepsilon_3$
			\item~$e_1  : \{ \overline \sigma \}~ \keyw{with} \varepsilon_1$
			\item~$e_2 : \tau_2~\keyw{with} \varepsilon_2$
			\item~$\sigma_i = \keyw{def} m_i(y : \tau_2) : \tau_3~ \keyw{with} \varepsilon_3$
		\end{itemize}
		We look at the cases for when $e_1$ and $e_2$ are values.
		
			\subcase{ $e_1$ is not a value. The derivation of $e_A : \tau~\keyw{with} \varepsilon_A$ includes the subderivation $e_1 : \{ \bar \sigma \}~\keyw{with} \varepsilon_1$. By the inductive hypothesis $e_1 \longrightarrow e_1'~|~\varepsilon$. Then \textsc{E-MethCall1} gives the reduction $e_A \longrightarrow e_1'.m_i(e_2)~|~\varepsilon$. }
	
			\subcase{ $e_2$ is not a value. Without loss of generality, $e_1 = v_1$ is a value. Also,
		$e_2 : \tau_2~\keyw{with} \varepsilon_2$ is a subderivation. By inductive hypothesis, $e_2 \longrightarrow e_2'~|~\varepsilon$. Then \textsc{E
		MethCall2$_{\sigma}$} gives the reduction $e_A \longrightarrow
		v_1.m_i(e_2')~|~\varepsilon$.}
		
			\subcase{ $e_1 = v_1$ and $e_2 = v_2$ are values. By Canonical Forms, $e_1 = \keywadj{new}_{\sigma}~x \Rightarrow \overline{\sigma = e}$. Also, $\keyw{def} m_i(y: \tau_2) : \tau_3~\keyw{with} \varepsilon_3 = e_i \in \overline{ \sigma = e }$. By the assumption of the typing rule used, the receiver and argument are well-typed for the method $m_i$. Then \textsc{E-MethCall3$_{\sigma}$} gives the reduction $e_1.m_i(e_2) \longrightarrow [v_1/x, v_2/y]e_i~|~\varnothing$.\\}

	}
	
	\proofcase{\textsc{$\varepsilon$-OperCall}} {
Then $e_A = e_1.\pi(e_2)$ and the following are known:
\begin{itemize}
	\item~$e_A : \keyw{Unit~with} \{ r.\pi \} \cup \varepsilon_1 \cup \varepsilon_2$
	\item~$e_1 : \{ \bar r \}~\keyw{with} \varepsilon_1$
	\item~$e_2 : \tau_2~\keyw{with} \varepsilon_2$
	\item~$\pi \in \Pi$
\end{itemize}
We look at the cases for when $e_1$ and $e_2$ are values.
	
		\subcase { $e_1$ is not a value. $e_1 : \{ \bar r \}~\keyw{with} \varepsilon_1$ is a subderivation. Applying inductive assumption, we have $e_1 \longrightarrow e_1'~|~\varepsilon$. Then \textsc{E-OperCall1} gives the reduction $e_1.\pi(e_2) \longrightarrow e_1'.\pi(e_2)~|~\varepsilon$.
		}
		
		\subcase { $e_2$ is not a value. Without loss of generality, $e_1 = v_1$ is a value. Also, $e_2 : \tau_2~\keyw{with} \varepsilon_2$ is a subderivation, so applying inductive assumption we get $e_2 \longrightarrow e_2'~|~\varepsilon$. Then \textsc{E-OperCall2} gives the reduction $v_1.\pi(e_2) \longrightarrow v_1.\pi(e_2')~|~\varepsilon$. }
		
		\subcase { $e_1$ and $e_2$ are values. By Canonical Forms, $\exists r \in R \mid e_1 = r$. Then \textsc{E-OperCall3} gives the reduction $r.\pi(v_2) \longrightarrow \keywadj{unit}~|~\{ r.\pi \}$.\\}
		
	}
	
	\proofcase{\textsc{C-MethCall}} {
Then $e_A = e_1.m_i(e_2)$ and the following are known:

\begin{itemize}
	\item ~$e_A : \tau_3~\keyw{with} \varepsilon_1 \cup \varepsilon_2 \cup \keywadj{effects}(\tau_2) \cup \varepsilon_c$
	\item ~$e_1 : \{ \bar d~\keyw{captures} \varepsilon_c \}~\keywadj{with}~\varepsilon_1$
	\item ~$e_2 : \tau_2~\keyw{with} \varepsilon_2$
	\item ~$d_i = \keyw{def} m_i(y : \tau_2) : \tau_3$
\end{itemize}
	We look at the cases for when $e_1$ and $e_2$ are values.
	
		\subcase { $e_1$ is not a value. Also, $e_1 : \{ \bar d~\keyw{captures} \varepsilon_c \}~\keywadj{with}~\varepsilon_1$ is a subderivation. By inductive hypothesis, $e_1 \longrightarrow e_1'~|~\varepsilon$. Then \textsc{E-MethCall1} gives the reduction $e_1.m_i(e_2) \longrightarrow e_1'.m_i(e_2)~|~\varepsilon$.}
		
		\subcase { $e_2$ is not a value. Without loss of generality, $e_1 = v_1$ is a value. Also, $e_2 : \tau_2~\keyw{with} \varepsilon_2$ is a subderivation. By inductive hypothesis, $e_2 \longrightarrow e_2'~|~\varepsilon$. Then \textsc{E-MethCall2$_d$} gives the reduction $v_1.m_i(e_2) \longrightarrow v_1.m_i(e_2')~|~\varepsilon$. }
		
		\subcase{ $e_1$ and $e_2$ are values. By Canonical Forms, $e_1 = \keywadj{new}_d~x \Rightarrow \overline{ d = e }$. Also, $\keyw{def} m_i(y : \tau_2) : \tau_3 = e_i \in \overline {d = e}$. By assumption of the typing rule used, the receiver and argument are well-typed for method $m_i$. Then \textsc{E-MethCall3$_d$} gives the reduction $v_1.m_i(v_2) \longrightarrow [v_1/x, v_2/y]e_i~|~\varnothing$ }
	}
}

\thm{Theorem 5.4. (Preservation for Mini Calculus)}
{Work in the mini calculus for fully-annotated programs. Suppose the following hold:
	\begin{itemize}
		\item $\Gamma_A \vdash e_A : \tau_A~\keyw{with} \varepsilon_A$
		\item $e_A \longrightarrow e_B~|~\varepsilon$
		\item $\Gamma_B \vdash e_B : \tau_B~\keyw{with} \varepsilon_B$
	\end{itemize}
Then $\varepsilon_B \subseteq \varepsilon_A$ and $\forall r.\pi \in \varepsilon_A \setminus \varepsilon_B \mid r.\pi \in \varepsilon$. Furthermore, if $e_A$ is not of the form $e_1.\pi(e_2)$, then $\tau_A = \tau_B$.\\

\noindent
Intuitively: during reduction, effects are only lost from the static information when they are added to the runtime information, so every effect gets ``accounted for''. You cannot gain static information after reducing an expression. \\\\
}
{ By structural induction on the derivation of $\Gamma_A \vdash e_A : \tau_A~\keyw{with} \varepsilon_A$ and then on the reduction rule used. \\

	\proofcase{ \textsc{$\varepsilon$-Resource}, \textsc{$\varepsilon$-Var}, \textsc{$\varepsilon$-NewObj}, \textsc{C-NewObj}} {
		$e_A$ is a value, so no reduction rules can be applied to it. The theorem statement is vacuously satisfied.\\ }
	
	\proofcase{\textsc{$\varepsilon$-MethCall$_{\sigma}$}}
	{Then $e_A = e_1.m_i(e_2)$ and the following are true:
\begin{itemize}
	\item $e_A : \tau~\keyw{with} \varepsilon_1 \cup \varepsilon_2 \cup \varepsilon_3$
	\item $e_1  : \{ \overline \sigma \}~ \keyw{with} \varepsilon_1$
	\item $e_2 : \tau_2~\keyw{with} \varepsilon_2$
	\item $\sigma_i = \keyw{def} m_i(y : \tau_2) : \tau~ \keyw{with} \varepsilon_3$
\end{itemize}
We do a case analysis on the reduction rules applicable to $e_1.m_i(e_2)$, for $m_i$ an annotated method.

		\subcase{ \textsc{E-MethCall1} Then $e_1 \longrightarrow e_1'~|~\varepsilon$. By inductive assumption $e_1' : \{ \bar \sigma \}~\keyw{with} \varepsilon_1'$. Then by \textsc{$\varepsilon$-MethCall} we have $e_B = e_1'.m_i(e_2) : \tau_3~\keyw{with} \varepsilon_1' \cup \varepsilon_2 \cup \varepsilon_3$. Then $\varepsilon_B = \varepsilon_1' \cup \varepsilon_2 \cup \varepsilon_3$ and $\varepsilon_B \setminus \varepsilon_A = \varepsilon_1' \setminus \varepsilon_1$. Any lost effect info is accounted for by inductive assumption.}
		
		\subcase{ \textsc{E-MethCall2$_\sigma$} 	Then $e_1 = v_1 = \keywadj{new}_{\sigma}~x \Rightarrow \overline{\sigma = e}$, and $e_2 \longrightarrow e_2'~|~\varepsilon$. By inductive assumption $e_2' : \tau_2~\keyw{with} \varepsilon_2$. Then by \textsc{$\varepsilon$-MethCall} we have $e_B = v_1.m_i(e_2) : \tau_3~\keyw{with} \varepsilon_1 \cup \varepsilon_2' \cup \varepsilon_3$. Then $\varepsilon_B = \varepsilon_1 \cup \varepsilon_2' \cup \varepsilon_3$ and $\varepsilon_B \setminus \varepsilon_A = \varepsilon_2' \setminus \varepsilon_2$. Any lost effect info is accounted for by inductive assumption.}
		
		\subcase{ \textsc{E-MethCall3$_\sigma$} Then $e_1 = v_1 = \keywadj{new}_{\sigma} \Rightarrow \overline{\sigma = e}$, and $\keyw{def} m_i(y : \tau_2) : \tau_3~\keyw{with} \varepsilon_3 = e' \in \overline{\sigma = e}$, and $e_2 = v_2$ is a value, and $v_1.m_i(v_2) \longrightarrow [v_1/x, v_2/y]e'~|~\varnothing$.
	
	\noindent	
We already know $e_1  : \{ \overline \sigma \}~ \keyw{with} \varepsilon_1$. The only rule with this conclusion is \textsc{$\varepsilon$-NewObj}. By inversion, $\overline{ \sigma = e }~\keywadj{OK}$. The only rule with this conclusion is \textsc{$\varepsilon$-ValidImpl$_{\sigma}$}. By inversion, $e' : \tau_3~\keyw{with} \varepsilon_3$.

		\noindent
Now $e_B = [v_1/x, v_2/y]e'$, since the rule \textsc{E-MethCall3} was used. We know $v_1 = e_1$ and $x$ have the same type, which is $\{ \overline \sigma \}~ \keyw{with} \varepsilon_1$. We also know $v_2 = e_2$ and $y$ have the same type, which is $\tau_2~\keyw{with} \varepsilon_2$. By the substitution lemma, the type of $e'$ is preserved under substitution. So $e_B : \tau_3~\keyw{with} \varepsilon_3$. 

		\noindent
Since $e_1 = v_1$ and $e_2 = v_2$ are values, by Canonical Forms $\varepsilon_1 = \varepsilon_2 = \varnothing$. So $\varepsilon_A = \varepsilon_3$. Then $\varepsilon_B \setminus \varepsilon_A = \varnothing$ and there are no lost effects to account for.
\\ }
}


	\proofcase{\textsc{$\varepsilon$-OperCall$_{\sigma}$}} {Then $e_A = e_1.\pi(e_2) : \keyw{Unit}$, and we know:
	\begin{itemize}
		\item $e_A :  \{ r, \pi \} \cup \varepsilon_1 \cup \varepsilon_2$
		\item $e_1 : \{ \bar r \}~\keyw{with} \varepsilon_1$
		\item $e_2 : \tau_2~\keyw{with} \varepsilon_2$
		\item $\pi \in \Pi$
	\end{itemize}
There are three reduction rules applicable to terms of the form $e_1.\pi(e_2)$ for $\pi$ an operation. We consider each.

	\subcase { \textsc{E-OperCall}. Then $e_1 \longrightarrow e_1'~|~\varepsilon$. By inductive assumption, $e_1' : \{ \bar r \} ~ \keyw{with} \varepsilon_1'$. From these we can apply \textsc{$\varepsilon$-OperCall}, giving $e_B = e_1'.\pi(e_2) : \keyw{Unit~with} \{ r.\pi \} \cup \varepsilon_1' \cup \varepsilon_2$. Then $\varepsilon_B = \{ r.\pi \} \cup \varepsilon_1' \cup \varepsilon_2$ and $\varepsilon_A \setminus \varepsilon_B = \varepsilon_1'$. Any lost effect info from $\varepsilon_1'$ is accounted for by inductive hypothesis.
	}
	
	\subcase{ \textsc{E-OperCall2}. Then $e_1 = r$ for some $r \in R$ and $e_2 \longrightarrow e_2'~|~\varepsilon$. By inductive assumption $e_2' : \tau_2~\keyw{with} \varepsilon_2'$. From these we can apply \textsc{$\varepsilon$-OperCall}, giving $e_B = r.\pi(e_2')~\keyw{with} \varepsilon$. Then $\varepsilon_B = r.\pi \cup \varepsilon_1 \cup \varepsilon_2'$ and $\varepsilon_A \setminus \varepsilon_B = \varepsilon_2'$. Any lost effect info from $\varepsilon_2'$ is accounted for by inductive hypothesis.
		}
	
	\subcase{ \textsc{E-OperCall3}. Then $r.\pi(v) \longrightarrow \keywadj{unit}~|~\{ r.\pi \}$. By Canonical Forms, $\varepsilon_1 = \varepsilon_2 = \varnothing$, so $e_A : \keyw{Unit~with} \{ r.\pi \}$. By a degenerate case of \textsc{$\varepsilon$-NewObj}, $\varepsilon_B = \keywadj{unit} : \keyw{Unit~with} \varnothing$. Then $\varepsilon_A \setminus \varepsilon_B = \{ r.\pi \}$. We can see that this is exactly the set of runtime effects $\varepsilon$, so we have accounted for the only lost effect.\\}	
}
}






















\thm{Theorem 5.5. (Small-Step Soundness For Mini Calculus)}
{Work in the mini calculus for fully-annotated programs. If $\Gamma \vdash e_A : \tau_A~\keyw{with} \varepsilon_A$ and $e_A \longrightarrow e_B~|~\varepsilon$, then $\varepsilon \subseteq \varepsilon_A$. \\\\}
{By structural induction on the rule used to derive $\Gamma \vdash e_A : \tau~\keyw{with} \varepsilon_A$, and then on the reduction rule used.\\

	\proofcase{ \textsc{$\varepsilon$-Resource}, \textsc{$\varepsilon$-Var}, \textsc{$\varepsilon$-NewObj}} {
		$e_A$ is a value, so no reduction rules can be applied to it. The theorem statement is vacuously satisfied.\\}
		
	\proofcase{\textsc{$\varepsilon$-MethCall$_\sigma$}} {
		Then $e_A = e_1.m_i(e_2)$ and the following are known:

			\begin{itemize}
				\item $e_A : \tau_A~\keyw{with} \varepsilon_1 \cup \varepsilon_2 \cup \varepsilon_3$
				\item $e_1 : \{ \bar \sigma \}~\keyw{with} \varepsilon_1$
				\item $e_2 : \tau_2~\keyw{with} \varepsilon_2$
				\item $\sigma_i = ~\keyw{def} m_i(y : \tau_2) : \tau_3~\keyw{with} \varepsilon_3$
			\end{itemize}
			
	\noindent
	Consider the possible reduction rules.

	\subcase{ \textsc{E-MethCall1}. 
		Then $e_1 \longrightarrow e_1'~|~\varepsilon$. By inductive assumption, $\varepsilon \subseteq \varepsilon_1 \subseteq \varepsilon_A$.
	}
	
	\subcase{ \textsc{E-MethCall2}. 
		Then $e_2 \longrightarrow e_2'~|~\varepsilon$. By inductive assumption, $\varepsilon \subseteq \varepsilon_2 \subseteq \varepsilon_A$.
	}
	
	\subcase{ \textsc{E-MethCall3}. Then $v_1.m_i(v_2) \longrightarrow [v_1/x, v_2/y]e'~|~\varnothing$. We're done as $\varnothing \subseteq e_A$. \\
	}
	}

	\proofcase{\textsc{$\varepsilon$-OperCall}} {
		Then $e_A = e_1.m_i(e_2)$ and the following are known:
		\begin{itemize}
			\item $e_A : \keyw{unit~with} \varepsilon_1 \cup \varepsilon_2 \cup \{ r.\pi \}$
			\item $e_1 : \{ \bar r \}~\keyw{with} \varepsilon_1$
			\item $e_2 : \tau_2~\keyw{with} \varepsilon_2$
			\item $\pi \in \Pi$
		\end{itemize}
		Consider the possible reduction rules.

	\subcase{\textsc{E-OperCall1}  Then $e_1 \longrightarrow e_1'~|~\varepsilon$. By induction assumption $\varepsilon \subseteq \varepsilon_1 \subseteq \varepsilon_A$.
	}		
	\subcase{\textsc{E-OperCall2} Then $e_2 \longrightarrow e_2'~|~\varepsilon$. By induction assumption $\varepsilon \subseteq \varepsilon_2 \subseteq \varepsilon_A$.
	}
	\subcase{\textsc{E-OperCall3} Then $\exists r \mid e_1 = r$ and $e_2 = v_2$ for some value and $r.\pi_i(v_2) \longrightarrow \keywadj{unit}~|~\{ r.\pi \}$. By Canonical Forms, $\varepsilon_1 = \varepsilon_2 = \varnothing$. Then $\varepsilon_A = \{ r.\pi \}$. We can see this is exactly the set of runtime effects.
	}

	}
}

\thm{Theorem 5.6. (Multi-Step Soundness For Mini Calculus)}
{Work in the mini calculus for fully-annotated programs. If $\Gamma \vdash e_A : \tau_A~\keyw{with} \varepsilon_A$ and $e \longrightarrow_* e_B~|~\varepsilon$ then $\varepsilon \subseteq \varepsilon_A$.\\\\}
{If the multi-step involves zero steps then the theorem is vacuously satisfied. Otherwise the multi-step involves more than one step. Induct on the number of steps. \\

\begin{adjustwidth}{1.5em}{0pt}
	\fbox{Base Case.}~ The length is 1. The theorem holds by Small-Step Soundness For Mini Calculus. \\
\end{adjustwidth}

\begin{adjustwidth}{1.5em}{0pt}
	\fbox{Inductive Case.}~ If there is a big-step of length n+1 then by \textsc{E-MultiStep3} it can be decomposed into a multi-step of length n; $e_1 \longrightarrow_* e_n~|~\varepsilon_n$; and a multi-step of length 1; $e_n \longrightarrow_* e_{n+1}~|~\varepsilon$. Then $e_1 \longrightarrow_* e_{n+1}~|~\varepsilon_n \cup \varepsilon$ is the entire multi-step. \\
	
	\noindent
	Let the type derivations be $\Gamma \vdash e_1 : \tau_1~\keyw{with} \varepsilon_1$ and $\Gamma \vdash e_{n}~\keyw{with} \varepsilon_{n}$ \\
	
	\noindent
	 By inductive assumption on the smaller multi-steps, we have that $\varepsilon \subseteq \varepsilon_n$ and $\varepsilon_n \subseteq \varepsilon_1$. Then $\varepsilon_1 \cup \varepsilon_n \subseteq \varepsilon_1$. $\varepsilon_1$ is the static effect information at the start of the multi-step, so we're done.
\end{adjustwidth}
}




\thm{Theorem 5.7. (Single-Method Extension)}
{If the following are true:
	\begin{itemize}
		\item $v_1 = \keyw{new} x \Rightarrow d_i = e_i$
		\item $d_i = \keyw{def} m_i(y: \tau_2) : \tau_3$
		\item $\Gamma \vdash d_i = e_i~\keywadj{OK}$
		\item $\Gamma \vdash v_2 : \tau_2~\keyw{with} \varepsilon_2$
		\item $[v_1/x, v_2/y]e_i \longrightarrow_* v~|~\varepsilon$
	\end{itemize}
Then $\exists \varepsilon_i \mid \varepsilon \subseteq \varepsilon_i \subseteq \keywadj{effects}(\Gamma)$. Letting $\sigma_i = d_i~\keyw{with} \varepsilon_i$, then also $\sigma_i = e_i~\keywadj{OK}$.\\

\noindent
\fbox{Note.} In this theorem we only consider objects with a single method $m_i$. Later we generalise the result to objects with any number of methods.\\\\
}
{Let $\Gamma' = \keywadj{freevars}(e_i) \cap \Gamma$. Let $\varepsilon_i = \keywadj{effects}(\Gamma)$. Let $\sigma_i = d_i~\keyw{with} \varepsilon_i$. \\

\noindent
With this choice of $\Gamma'$ and the assumption $\Gamma \vdash d_i = e_i~\keywadj{OK}$ we may type $e_i$ using \textsc{C-ConservativeTyping}. Then $e_i : \tau_i~\keyw{with} \varepsilon_i$, where $\varepsilon_i = \keywadj{effects}(\Gamma')$. Then \textsc{$\varepsilon$-ValidImpl$_\sigma$} gives $\sigma_i = e_i~\keywadj{OK}$. \\

\noindent
By the substitution lemma, $[v_1/x, v_2/y]e_i : \tau_i~\keyw{with} \varepsilon_i$. By application of multi-step soundness to the assumed multi-step reduction we have $\varepsilon \subseteq \varepsilon_i = \keywadj{effects}(\Gamma') \subseteq \keywadj{effects}(\Gamma)$.

}



\thm{Theorem 5.8. (Extension)}
{If  $v_1 = \keyw{new} x \Rightarrow \overline{d = e}$ and $\forall i$ the following are true:
	\begin{itemize}
		\item $d_i = \keyw{def} m_i(y: \tau_2) : \tau_3$
		\item $\Gamma \vdash d_i = e_i~\keywadj{OK}$
		\item $\Gamma \vdash v_2 : \tau_2~\keyw{with} \varepsilon_2$
		\item $[v_1/x, v_2/y]e_i \longrightarrow_* v~|~\varepsilon$
	\end{itemize}
	Then $\exists \varepsilon_1, ..., \varepsilon_n \mid \varepsilon \subseteq \bigcup\limits_{i=1}^{n} \varepsilon_i \subseteq \keywadj{effects}(\Gamma)$. Letting $\sigma_i = d_i~\keyw{with} \varepsilon_i$ then also $\Gamma \vdash \keyw{new} x \Rightarrow \overline{\sigma = e}~\keyw{with~\varnothing}$ \\\\}
{From Single-Method Extension we know that  $\forall i \exists \varepsilon_i \mid \varepsilon \subseteq \varepsilon_i \subseteq \keywadj{effects}(\Gamma')$. Let $\Gamma' = \bigcup\limits_{i=1}^{n} \Gamma_i'$. Then $\bigcup\limits_{i=1}^{n} \varepsilon_i \subseteq \keywadj{effects}(\Gamma') \subseteq \keywadj{effects}(\Gamma)$. \\
	
\noindent
From Single-Method Extension we know $\sigma_i = e_i~\keywadj{OK}$, so $\overline{\sigma = e}~\keywadj{OK}$. Then by \textsc{$\varepsilon$-NewObj} we have the claimed typing judgement.
	
	}

\begin{large}
\bf{Definition. (Label)}
\end{large}

\noindent
Using the results of the previous theorem we define a program-transforming function called $\keywadj{label}$, which transforms an unannotated program into an annotated one.

\begin{itemize}
	\item $\keywadj{label}(r)$ = r
	\item $\keywadj{label}(x)$ = x
	\item $\keywadj{label}(e_1.m(e_2)) = \keywadj{label}(e_1).m(\keywadj{label}(e_2))$
	\item $\keywadj{label}(e_1.\pi(e_2)) = \keywadj{label}(e_1).\pi(\keywadj{label}(e_2))$
	\item $\keywadj{label}(\keyw{new_\sigma} x \Rightarrow \overline{\sigma = e}) = \keywadj{new}_\sigma x \Rightarrow \keywadj{label \hyphen helper}(\overline{\sigma = e})$
	\item $\keywadj{label}(\keyw{new_d} x \Rightarrow \overline{d = e}) = \keyw{new_\sigma} x \Rightarrow \keywadj{label \hyphen helper}(\overline{d = e})$
	\item $\keywadj{label \hyphen helper}(\sigma = e) = \sigma = \keywadj{label}(e)$
	\item $\keywadj{label \hyphen helper}(\keywadj{def}~m(y : \tau_2) : \tau_3 = e) = \keywadj{def}~m(y : \tau_2) : \tau_3~\keyw{with} \Gamma \cap \keywadj{freevars}(e) = \keywadj{label}(e)$
\end{itemize}

\noindent \textbf{Notes:}
\begin{itemize}
\item $\keywadj{label}$ is defined on expressions; $\keywadj{label \hyphen helper}$ on declarations. This is just for clarity; everywhere other than this section we'll only use $\keywadj{label}$.
\item Initially it seems like $\keywadj{label}$ on a $\keywadj{new_\sigma}$ object should just be the identity function; but the body of the methods of such an object may instantiate unlabeled objects and/or call methods on unlabeled objects, so we must recursively label those.
\item From here on out we will use $\hat e$ to refer to a fully-labeled program. We may sometimes say $\keywadj{labels}(e) = \hat e$, and from then on refer to $\hat e$ as the labeled program. Likewise, we will use $\hat \tau$ and $\hat \varepsilon$ to refer to the type and effects of $\hat e$.
\end{itemize}






\thm{Theorem 5.9. (Refinement)}
{If $e : \tau~\keyw{with} \varepsilon$ and $\keywadj{label}(e) = \hat e$ and $\hat e : \hat \tau~\keyw{with} \hat \varepsilon$, then $\hat \varepsilon \subseteq \varepsilon$.\\\\}
{We show the property holds for each case of the $\keywadj{label}$ function by inducting on the complexity of $e$.

\proofcase{$\keywadj{label}(r),~\keywadj{label}(x)$}{
	Then $e = \hat e$ so it holds immediately.
}
	
\proofcase{$\keywadj{label}(\keyw{new_d} x \Rightarrow \overline{d = e}), \keywadj{label}(\keyw{new_\sigma} x \Rightarrow \overline{\sigma = e})$}{
Typing judgements for objects only give $\varnothing$ as the set of effects so we're done automatically. Although an object can have capabilities for effects bu those are encoded in its methods (in the case of a labeled object) or in its type (in the case of an unlabeled object having type $\{ \bar d~\keyw{captures} \varepsilon_c\}$).
}	
	
\proofcase{$\keywadj{e_1.m(e_2)}$}{Then $\keywadj{label}(e_1.m(e_2)) = \hat e_1 . m(\hat e_2)$ and the inductive assumption holds for $\hat e_1$ and $\hat e_2$. Since $\hat e_1 . m(\hat e_2)$ is a labeled object we may type it with \textsc{$\varepsilon$-MethCall$_\sigma$}. By inspecting that rule we see the set of effects after labeling is $\hat \varepsilon = \hat \varepsilon_1 \cup \hat \varepsilon_2 \cup \hat \varepsilon_3$. By inductive assumption on subexpressions, each $\hat \varepsilon_i \subseteq \varepsilon_i$. \\

\noindent
Now what is the form of $e_1.m(e_2)$? If $e_i$ is already labeled then $\hat \varepsilon_i = \varepsilon$. So without loss of generality, let's assume $e_1$ and $e_2$ are both unlabeled. There are two judgments that might have typed $e_1.m(e_2)$ so let's examine them.



	\subcase{\textsc{C-ConservativeTyping}
	Then $\varepsilon = \keywadj{effects}(\Gamma')$. Any effect in $\hat \varepsilon$ must be captured in the environment at large; therefore $\hat \varepsilon \subseteq \varepsilon$.
	}

	\subcase{\textsc{C-MethCall}. Then $\varepsilon = \varepsilon_1 \cup \varepsilon_2 \cup \keywadj{effects}(\tau_2) \cup \keywadj{effects}(\Gamma')$ for some sub-context. Since $\hat \varepsilon_i \subseteq \varepsilon_i$, we just need to show that $\hat \varepsilon_3 \subseteq \varepsilon$. \\\\ Note that $\hat \varepsilon_3$ represents the effects captured by executing method $m$. Let $r.\pi \in \hat \varepsilon_3$. If $r.\pi$ is captured then someone must be able to call $r.\pi$ from somewhere as a result of the method call. From the perspective of the method call $e_1.m(e_2)$ there are two ways $r.\pi$ could be invoked:
\begin{itemize}
	\item During execution of method $m$ the operation $r.\pi$ is invoked, either directly or indirectly, before control-flow returns to the call-site.
	\item As a result of executing method $m$ a capability for $r$ is gained at the call-site. $r$ may then be passed back up the call-chain and someone later may invoke $r.\pi$, after $e_1.m(e_2)$ has finished executing.
\end{itemize}	
	
~\\In the first case, the resource $r$ must be visible in the current environment, i.e. $r \in \Gamma'$. Then $r.\pi \in \keywadj{effects}(\Gamma') \subseteq \varepsilon$.
	\\\\
	In the second case, if $r$ is currently in the environment then $r.\pi \in \keywadj{effects}(\Gamma')$ again. Otherwise $r$ might not be in the environment; the only way for the call-site to gain a capability then is for the method $m$ to have returned it. Therefore $r \in \keywadj{effects}(\tau_2) \subseteq \varepsilon$, where $\tau_2$ is the return type of $m$.
}
\proofcase{$\keywadj{e_1.\pi(e_2)}$}{
	Then $\hat e = \hat e_1.\pi(\hat e_2)$. By inductive assumption the labeled expressions will be $\hat \varepsilon_1$ and $\hat \varepsilon_2$. The only rule which can be used to type $\hat e$ and $e$ is \textsc{$\varepsilon$-OperCall}; then the effect-set for $e$ is $\varepsilon = \{ r.\pi \} \cup \varepsilon_1 \cup \varepsilon_2$ and for $\hat e$ is $\hat \varepsilon = \{ r.\pi \} \cup \hat \varepsilon_1 \cup \hat \varepsilon_2$. $\hat \varepsilon \subseteq \varepsilon$ by inductive assumption on each $\varepsilon_i$.
}
}
}

\noindent
\\\fbox{Intuition.} This theorem says that labeling a program can only make the effect inference more precise (never less precise).\\






\thm{Theorem 5.10. (Preservation Under Labeling)}
{If $\Gamma \vdash e : \tau$ then $\Gamma \vdash \hat e : \tau$. \\\\}
{By induction on the complexity of the expression $e$ and considering the possible forms of $e$. If $e = r$ or $e = x$ then it holds trivially. Consider the other cases.

\proofcase{$e_1.m(e_2)$}{ 
By induction we know $\keywadj{type}(e_1) = \keywadj{type}(\hat e_1)$ and $\keywadj{type}(e_2) = \keywadj{type}(\hat e_2)$. The result holds by applying \textsc{T-MethCall$_\sigma$}.
}

\proofcase{$e_1.\pi(e_2)$}{
Same as above but use \textsc{T-MethCall$_r$}.
}

\proofcase{$\keyw{new_\sigma} x \Rightarrow \overline{\sigma = e}$}{ From induction we know that since $\Gamma \vdash \overline{\sigma = e}~\keywadj{OK}$ then $\Gamma \vdash \overline{\sigma = \hat e}~ \keywadj{OK}$. The result holds by applying \textsc{T-NewObj$_\sigma$}.
}

\proofcase{$\keyw{new_d} x \Rightarrow \overline{d = e}$}{ Same as above, but $\Gamma \vdash \overline{d = \hat e}$ lets us apply \textsc{T-NewObj$_d$}.
}
}

\thm{Theorem 5.11. (Small-Step Soundness Of Labeled Programs)}
{If $e_A \longrightarrow e_B~|~\varepsilon_B$ and $e_A : \tau_A$ then $\hat e_A : \hat \tau~\keyw{with ~\hat \varepsilon}$ where $\varepsilon_B \subseteq \hat \varepsilon$.\\\\}
{By induction on the evaluation rule used. In all cases, the type of $\hat e_A$ is the same as $e_A$ by the previous theorem so we omit its derivation.

\proofcase{\textsc{E-MethCall1}}
{Then the following are known.
\begin{itemize}
	\item $e_A = e_1.m(e_2)$
	\item $e_1 \rightarrow e_1'~|~\varepsilon$
	\item $e_B = e_1'.m(e_2)~|~\varepsilon$
\end{itemize}
By inductive assumption $\hat e_1 : \tau~ \keyw{with} \hat \varepsilon_1$ where $\varepsilon \subseteq \hat \varepsilon_1$. By applying the rule \textsc{$\varepsilon$-MethCall$_\sigma$} we type $\hat e_A$ to something with the effect-set $\hat \varepsilon = \hat \varepsilon_1 \cup \hat \varepsilon_2 \cup \hat \varepsilon_3 \supseteq \hat \varepsilon_1 \supseteq \varepsilon$.
}

\proofcase{ \textsc{E-OperCall1}}
{
	Same as previous case, but use the rule \textsc{$\varepsilon$-OperCall}.
}

\proofcase{\textsc{E-MethCall2$_\sigma$}, \textsc{E-MethCall2$_d$}}
{Then the following are known.
\begin{itemize}
	\item $e_A = v_1.m(e_2)$
	\item $e_2 \longrightarrow e_2'~|~\varepsilon$
\end{itemize}
By inductive assumption $\hat e_2 : \tau~ \keyw{with} \hat \varepsilon_2$ where $\varepsilon \subseteq \hat \varepsilon_2$. By applying the rule \textsc{$\varepsilon$-MethCall$_\sigma$} we type $\hat e_1.m(\hat e_2)$ to something with the effect-set $\hat \varepsilon = \hat \varepsilon_1 \cup \hat \varepsilon_2 \cup \hat \varepsilon_3 \supseteq \hat \varepsilon_2 \supseteq \varepsilon$.
}

\proofcase{\textsc{E-OperCall2}} {
	Same as previous case, but use the rule
}

\proofcase{\textsc{E-MethCall3$_\sigma$}, \textsc{E-MethCall3$_d$}}
{In this case $\varepsilon = \varnothing$ so the statement holds trivially.
}

\proofcase{\textsc{E-OperCall3}}
{Then $e_A = r.\pi(v)$. $\hat r = r$ so $\hat e_A = r.\pi(\hat v)$. By application of \textsc{$\varepsilon$-OperCall} we have $\hat e_A : \keyw{Unit~with} \{ r.\pi \} \cup \hat \varepsilon_1 \cup \hat \varepsilon_2$, where $\hat \varepsilon_2$ is the set of effects for $\hat v$ and $\hat \varepsilon_1 = \varnothing$ for $\hat r = r$. By inspection of the rule for $\textsc{E-OperCall3}$, $\varepsilon = r.\pi \subseteq \{ r.\pi \} \cup \hat \varepsilon_2 = \hat \varepsilon_A$.
}
}


\thm{Theorem 5.12. (Soundness Theoerm)}
{If $\Gamma \vdash e_A : \tau_A~\keyw{with} \varepsilon_A$ and $e_A \longrightarrow e_B~|~\varepsilon$ then $\Gamma \vdash e_B : \tau_B~\keyw{with} \varepsilon_B$ and $\varepsilon \subseteq \varepsilon_A$.\\\\}
{Induct on the typing judgement for $\Gamma \vdash e_A : \tau_A~\keyw{with} \varepsilon_A$ and then on the evaluation rule used for $e_A \longrightarrow e_B~|~\varepsilon$. First note that the theorem statement has already been proven for typing judgements from the calculus for fully-labeled programs. Therefore we'll only consider the extra typing rules in the calculus that allows unlabeled objects.

\proofcase{\textsc{C-NewObj}}
{Then $e_A$ is of the form $\keywadj{new}_d$ so it is a value. Then no reduction can be applied; the theorem statement holds vacuously.
}

\proofcase{\textsc{C-MethCall}}
{
Then $e_A = e_1.m(e_2)$ where $e_1 = \keyw{new_d} x \Rightarrow \overline{d = e} : \{ \bar d~\keyw{captures} \varepsilon_c \}~ \keyw{with} \varnothing$, where $\varepsilon_c = \keywadj{effects}(\Gamma_A')$, for $\Gamma_A' \subseteq \Gamma_A$. Consider the extension $\hat e_A = \keywadj{label}(e_A)$. Since $\keywadj{label}$ only changes type-information, the runtime effects of $e_A$ are invariant under the $\keywadj{label}$ function. Furthermore, $e_A$ is a value if and only if $\hat e_A$ is a value.\\

\noindent
Now, $\hat e_A$ is not a value because $e_A$ is not a value. Therefore we can reduce $\hat e_A$. Then $\hat e_A \longrightarrow \hat e_B~|~\varepsilon$, the same $\varepsilon$ we get when reducing $e_A$. \\

\noindent
By small-step soundness of labeled programs, $\varepsilon \subseteq \hat \varepsilon_A$. By refinement, $\hat \varepsilon_A \subseteq \varepsilon_A$. So $\varepsilon \subseteq \varepsilon_A$.
}

\proofcase{\textsc{C-ConservativeTyping}}
{
Then $\varepsilon_A = \keywadj{effects}(\Gamma')$ for some $\Gamma'$. Runtime effects must be captured by the environment; therefore $\varepsilon \subseteq \varepsilon_A$.
}
}



\end{document}
