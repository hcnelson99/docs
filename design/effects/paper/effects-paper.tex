\documentclass[a4paper,UKenglish]{lipics-v2016}
%This is a template for producing LIPIcs articles. 
%See lipics-manual.pdf for further information.
%for A4 paper format use option "a4paper", for US-letter use option "letterpaper"
%for british hyphenation rules use option "UKenglish", for american hyphenation rules use option "USenglish"
% for section-numbered lemmas etc., use "numberwithinsect"
 
\usepackage{microtype} %if unwanted, comment out or use option "draft"
\usepackage{proof}

\bibliographystyle{plainurl}% the recommended bibstyle

% For keywords in math-mode.
\newcommand{\kw}[1]{\mathtt{ #1 }~}
\newcommand{\kwa}[1]{\mathtt{ #1 }}


\newcommand{\newbasic}[0]{
	\kwa{new}~x \Rightarrow \overline{\sigma = e}
}

\newcommand{\singlestep}[0]{ \longrightarrow }
\newcommand{\multistep}[0]{ \longrightarrow^{*}}
\newcommand{\rctx}[0]{ \langle R, \Pi \rangle }

%\graphicspath{{./graphics/}}%helpful if your graphic files are in another directory

\bibliographystyle{plainurl}% the recommended bibstyle

% Author macros::begin %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\title{A Sample Article for the LIPIcs series\footnote{This work was partially supported by someone.}}
\titlerunning{A Sample LIPIcs Article} %optional, in case that the title is too long; the running title should fit into the top page column

%% Please provide for each author the \author and \affil macro, even when authors have the same affiliation, i.e. for each author there needs to be the  \author and \affil macros
\author[1]{John Q. Open}
\author[2]{Joan R. Access}
\affil[1]{Dummy University Computing Laboratory, Address/City, Country\\
  \texttt{open@dummyuniversity.org}}
\affil[2]{Department of Informatics, Dummy College, Address/City, Country\\
  \texttt{access@dummycollege.org}}
\authorrunning{J.\,Q. Open and J.\,R. Access} %mandatory. First: Use abbreviated first/middle names. Second (only in severe cases): Use first author plus 'et. al.'

\Copyright{John Q. Open and Joan R. Access}%mandatory, please use full first names. LIPIcs license is "CC-BY";  http://creativecommons.org/licenses/by/3.0/

\subjclass{TODO -- see \url{http://www.acm.org/about/class/ccs98-html}}% mandatory: Please choose ACM 1998 classifications from http://www.acm.org/about/class/ccs98-html . E.g., cite as "F.1.1 Models of Computation". 
\keywords{capability safety, effects, modules}% mandatory: Please provide 1-5 keywords
% Author macros::end %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%Editor-only macros:: begin (do not touch as author)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\EventEditors{John Q. Open and Joan R. Acces}
\EventNoEds{2}
\EventLongTitle{42nd Conference on Very Important Topics (CVIT 2016)}
\EventShortTitle{CVIT 2016}
\EventAcronym{CVIT}
\EventYear{2016}
\EventDate{December 24--27, 2016}
\EventLocation{Little Whinging, United Kingdom}
\EventLogo{}
\SeriesVolume{42}
\ArticleNo{23}
% Editor-only macros::end %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\maketitle

\begin{abstract}
Lorem ipsum dolor sit amet, consectetur adipiscing elit. Praesent convallis orci arcu, eu mollis dolor. Aliquam eleifend suscipit lacinia. Maecenas quam mi, porta ut lacinia sed, convallis ac dui. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Suspendisse potenti. 
 \end{abstract}

\section{Introduction}

Modern software is developed according to principles of encapsulation and re-use \textbf{[PRINCIPLE OF LEAST AUTHORITY; SALTZER `74]}, in which all code relating to one piece of functionality is grouped into a logically coherent module or component. In order to work these components must often manipulate certain resources passed around the system, such as files or sockets. Malicious code can leverage insecurities in these components to gain unintended access to resources. For example, if a logging component exposes the file to which it is writing, then any client of that component gains unrestricted access to the file. In the presence of software components of external origin, it can be a real challenge for developers to guarantee internal restrictions about which resources are to be used, by whom, and how.

Effect systems extend type systems with the notion of an $\textit{effect}$. Effects describe intensional information about what happens during the execution of a program \textbf{[Nielson and Nielson, Type and Effect systems]}. For example, if a program $e$ opens a specific file $\kwa{File}$ during execution, we can say it has the effect $\kwa{File.write}$. We call $\kwa{File}$ the resource and $\kwa{write}$ the operation. In an effect system, code typechecks with both a type and an effect-set. Effects are often taken to represent imperative or stateful updates, or I/O operations. The effect-set of a program gives us an approximate description of any impure behaviour.

\textbf{[CAPABILITIES; MILLER PHD THESIS; 65 PAPER]}

The contribution of this paper is to develop an effect-system for a simple, pure object calculus. The design of the calculus is based on Wyvern, a safe-by-default, pure object-oriented programming language, designed for web and mobile development. Importantly, Wyvern is \textit{capability-safe}, meaning that components cannot obtain capabilities for resources and objects they haven't been explicitly given. Modules in Wyvern are first-class, meaning they are equivalent to regular objects.

This gives developers a means to quickly and easily reason about the ways in which a component is usnig its resources. At a coarse-grained level it can signify that a component lacks encapsulation: for example, that the logger module also requires access to networking capabilities, and thus might be doing more than just logging. At a fine-grained level it can tell us the way in which certain resources are used: that the logger only appends to files, and never opens or closes them. A practical effect system makes use of both where appropriate.

We first develop the epsilon calculus, in which all sub-components of a program are labelled with their effects to show the basic idea of how effect-labels propagate information throughout the system. This is then extended to the epsilon* calculus, where a programmer may freely mix labelled and unlabelled code. The benefit of this is to allow the developer to (safely) omit labelling in parts of the system which do not require fine-grained reasoning, giving a more usable system. Overall, our system illustrates a novel way in which capability and effect-based reasoning combined yield a practical means of reasoning about the safe manipulation of resources in complex systems.

\section{Capabilities \& Modules}

\textbf{REWORK SECTION}

\begin{definition}
A resource is a capability for some primitive I/O operations.
\end{definition}

\begin{definition}
An operation is an invocation of a primitive I/O operation on a resource.
\end{definition}

\noindent
Resources and operations are drawn from fixed sets $R$ and $\Pi$ respectively. They cannot be created during runtime. For simplicity we assume all operations are null-ary; the precise nature of \textit{what} an effect is doing is not of interest to our system, but rather \textit{where} those effects are being used throughout the program.

\begin{definition}
An effect $r.\pi$ is a member of $R \times \Pi$.
\end{definition}

\begin{definition}
An effect-set $\varepsilon$ is a subset of $R \times \Pi$.
\end{definition}

\noindent
We usually refer to $(r, \pi)$ as $r.\pi$. For example: $\kwa{File.append}$ and $\kwa{Socket.open}$ instead of $\kwa{(File, append)}$ and $\kwa{(Socket, open)}$. For simplicity we assume every operation is defined on every resource, so $\kwa{Socket.append}$ would be a valid effect (even though externally you mightn't be able to append to a socket).

Generally, we say a program $e$ has the runtime effect $r.\pi$ if $r.\pi$ is called during the execution of $e$. We say $e$ captuers the runtime effect $r.\pi$ if it has the authority to call $r.\pi$ at some point during execution.

[DISCUSS CAPABILITY-SAFETY: EMILY, E, JOE-E, WYVERN]

[FIRST-CLASS MODULES: SCALA, NEWSPEAK, WYVERN]

\section{Motivating Examples}

When a module requires access to a particular capability we often want to restrict how that capability is used. For example, when we pass a file to a logger, we only expect it to be appending to that file. In a non-effect system, such behaviour cannot be enforced, because access to a capability implies access to its encapsulating operations. Figure 1 shows an example of a logging module which violates this sort of fine-grained restriction on capability use, by writing rather than appending.

\begin{figure}[h]
\vspace{-5pt}
\begin{lstlisting}[mathescape]
module Logger
require FileIO

def log(errMsg: String): Unit =
  f.write(errMsg)
\end{lstlisting}

\begin{lstlisting}
module Main
require FileIO
instantiate Logger(FileIO)
instantiate Client

def main(): Unit =
  Client.run(Logger)
\end{lstlisting}


\begin{lstlisting}
module Client

type Logger =
  def log(err: String): Unit

def run(logger : Logger) =
  logger.log(``test message'')
\end{lstlisting}

\vspace{-7pt}
\caption{A short program consisting of three modules. Main instantiates the capabilities needed to run the program and passes the Logger to the Client's run method. }
\label{f-resource-modules}
\end{figure}

From the perspective of the client, it is not immediately clear that its logging capability should have the $\kwa{File.write}$ effect. The existence of this behaviour could be for several reasons: it could be a bug on the behalf of a well-intentioned programmer; this particular logging module may be making assumptions different from those of the client; or it may be an intentionally malicious third-patry library. Whatever the case, establishing whether this behaviuor exists would require the client to manually examine the source code of the logger. An effect system can embed this time-consuming process into the type system. Consider the above example, amended to include effect annotations.

\begin{figure}[h]
\vspace{-5pt}
\begin{lstlisting}[mathescape]
module Logger
require FileIO

def log(errMsg: String): Unit with {File.write} =
  f.write(errMsg)
\end{lstlisting}

\begin{lstlisting}
module Main
require FileIO
instantiate Logger(FileIO)
instantiate Client

def main(): Unit with {File.log} =
  Client.run(Logger)
\end{lstlisting}

\begin{lstlisting}
module Client

type Logger =
  def log(err: String): Unit

def run(logger : Logger) with {File.log} =
  logger.log(``test message'')
\end{lstlisting}

\vspace{-7pt}
\caption{The same program now annotates each method with the effects it may invoke, whether directly or indirectly. }
\label{f-resource-modules}
\end{figure}

An effect-system will now reject this program: $\kwa{main}$ declares its effects as being no more than the set $\kwa{ \{File.log\} }$, but its implementation typechecks as having $\kwa{ \{File.write\} }$.

This solution is cumbersome in that it requires every part of the system to be annotated with its effects. If we consider each module as being ``owned'' by a different team of developers, a local change in the effects produced by one module requires a global refactoring. Maintaining the effect annotations is a considerable overhead; some have cited this heavyweight feel as a point against the practical use of effect systems \textbf{[CITATION NEEDED]}. Ideally, developers would only have to annotate the portions of code directly involved in using effects. Modules such as $\kwa{Main}$, which in this case are only involved in the transfer of capabilities, would not require annotations.

Because a capability-safe system disallows ambient authority, the only effects possible in $\kwa{Main}$ are those in its signature. A summary of the potential effects can be inferred by the type system, leaving manual annotations for the maintainres of the $\kwa{Client}$ and $\kwa{Logging}$ modules. This is the basic idea underlying our system: we allow the omission of effect annotations in sections of code where the set of effects is not widened.

We shall begin with a formalism for a system where every method is fully-labelled. Although such systems are cumbersome, this process will help introduce the notation and concepts needed to describe the generalised effect-system which allows the mixing of labelled and unlabelled code.

\section{Epsilon Calculus}

The first system is called the epsilon calculus. Its principal unit is the object, and the system is entirely pure. This simplifies reasoning and keeps our system simple and extensible. Importantly, this system is capability-safe: the only effectful capabilities are those passed into the program at the start of the execution, and an object may only gain or access capability by being given them by another object possessing that capability. The objects of the epsilon calculus can also encode the modules of a capability-safe language where these are treated as first-class objects.

\subsection{Grammar}

The epsilon calculus operates on very simple programs $e$, where every declaration $\sigma$ has programmer-annotated labels specifying their effect.
\[
\begin{array}{lll}

\begin{array}{lllr}

e & ::= & x & expressions \\
  		& | & r \\
		& | & \kwa{new}~x \Rightarrow \overline{\sigma = e} \\
 		& | & e.m(e)\\
 		& | & e.\pi\\
		&&\\

\tau & ::= & \{ \bar \sigma \} & types \\
		& | & \{ r \} \\
		&&\\
		
\sigma & ::= & \kw{def} m(y:\tau):\tau~\kw{with}\varepsilon  & decls. \\
		&&\\

\end{array}
\end{array}
\]

\noindent
 The fundamental construct is the object, modelled as a record of methods. An object's ``this'' variable is usually denoted by $x$. Every method declaration $\sigma$ is annotated with an upper-bound $\varepsilon$ on the effects that may happen as a result of executing the method. This upper-bound is not necessarily tight; it may contain effects which don't happen on certain execution paths.
 
Note that resources and objects are considered distinct, although they work somewhat similarly: methods are invoked on a method, and operations on a resource. A simplifying assumption we make is that every operation takes zero arguments and every method takes one argument. We consider this without loss of generality; in a later section we shall see how multiple-argument methods may be encoded as single-argument methods.

Types in the epsilon calculus are structural. The type with no methods is called $\kwa{Unit}$, and it has a single instance called $\kwa{unit}$. It is used to convey the absence of information (often called $\kwa{Void}$ in other languages).

When a method takes $\kwa{Unit}$ as its parameter, we shall often omit this information fro brevity. That is, $\kw{def} m(y: \kwa{Unit}: \tau$ and $\kw{def} m(): \tau$ are the same declaration.

\subsection{Static Semantics}

A context $\Gamma$ is a mapping from variables to types. In our calculus, $\Gamma$ can prove two sorts of static judgements. The first, $\Gamma \vdash \sigma = e~\kw{OK}$, confirms that the type and effect of $e$ cohere to those of the declaration $\sigma$. The other, $\Gamma \vdash e: \tau~\kw{with} \varepsilon$, says that $e$ evaluates to something of type $\tau$, and that during execution it will have at most the set $\varepsilon$ as its runtime effects.\\

\noindent
$\fbox{$\Gamma \vdash e: \tau~\kw{with} \varepsilon$}$

\[
\begin{array}{c}
\infer[\textsc{($\varepsilon$-Var)}]
	{\Gamma, x:\tau \vdash x:\tau ~\kw{with} \varnothing}
	{}

~~~~~~

\infer[\textsc{($\varepsilon$-Resource)}]
	{\Gamma, r: \{r \} \vdash r : \{ r \} ~\kw{with} \varnothing}
	{}\\[4ex]
	
\infer[\textsc{($\varepsilon$-NewObj)}]
	{\Gamma \vdash \newbasic : \{ \bar \sigma \}~\kw{with} \varnothing}
	{\Gamma, x: \{ \bar \sigma \} \vdash \overline{\sigma = e}~\kw{OK}}
	
~~~~~~

\infer[\textsc{($\varepsilon$-OperCall)}]
	{\Gamma \vdash e_1.\pi : \kw{Unit} \kw{with} \{ r.\pi \} \cup \varepsilon_1 }
	{\Gamma \vdash e_1 : \{ r \}~\kw{with} \varepsilon_1} \\[4ex]
	
\infer[\textsc{($\varepsilon$-MethCall)}]
	{\Gamma \vdash e_1.m_i(e_2) : \tau_3~\kw{with} \varepsilon_1 \cup \varepsilon_2 \cup \varepsilon_3}
	{\Gamma \vdash e_1: \{ \bar \sigma \}~\kw{with} \varepsilon_1 & \Gamma \vdash e_2: \tau_2~\kw{with} \varepsilon_2 & \sigma_i = \kw{def} m_i(y: \tau_2): \tau_3~\kw{with} \varepsilon_3}
	
\end{array}
\]

\noindent
$\fbox{$\Gamma \vdash \sigma = e~ \kwa{OK}$}$

\[
\begin{array}{c}

~~~~~~~~~~~

\infer[\textsc{($\varepsilon$-ValidImpl)}]
	{\Gamma \vdash \sigma = e~\kwa{OK}}
	{\Gamma, y: \tau_2 \vdash e: \tau_3~\kw{with} \varepsilon_3 & \sigma = \kw{def} m(y: \tau_2):\tau_3 ~\kw{with} \varepsilon_3}

\end{array}
\]

\noindent
In the rules \textsc{$\varepsilon$-Var}, \textsc{$\varepsilon$-Resource}, and \textsc{$\varepsilon$-NewObj}, the result types with no effect. Although these forms may nest capabilities for some resource, it is not an effect nuless something is done with them, such as invoking a method or an operation; these situations are, respectively, the rules and \textsc{$\varepsilon$-MethCall} and \textsc{$\varepsilon$-OperCall}.

Our rules make some simplifying assumptions. In practice, some effects allow a program to obtain data from an external source during runtime. An example of such an effect might be $\kwa{File.read}$ or $\kwa{Socket.read}$. Because our motivating examples do not require such effects, we will assume $r.\pi$ always returns $\kwa{unit}$. Lastly, this system has no subtyping rules. Although this makes programs less tractable, for expository purposes we will not need them yet. Later on the epsilon* calculus will introduce subtyping rules.

\subsection{Dynamic Semantics}

The notation for a single-step reduction is $e \longrightarrow e'~|~\varepsilon$. This should be read as $e$ being reduced to $e'$, during which all the effects in $\varepsilon$ take place. For now, because it is a single small-step reduction, $\varepsilon$ will be either a singleton or empty. It should be noted that the $\varepsilon$ in $e \longrightarrow e'~|~\varepsilon$ is the \textit{true} set of runtime effects. Compare this with a static judgement like $\Gamma \vdash e: \tau~\kw{with} \varepsilon$, where $\varepsilon$ is a conservative approximation to the runtime effects.

For a program to perform operation calls it must know what resources and operations are available to use. These are enumerated in a resource context $ \langle R, \Pi \rangle$. These lists are fixed throughout the runtime. A valid operation is a pair $r.\pi \in R \times \Pi$. We use the notation $\langle R, \Pi \rangle \vdash e \longrightarrow e'~|~\varepsilon$ to mean the reduction on the right-hand side is true in a particular resource context. If $e$ is closed under $\Gamma$, then $\rctx$ is a \textit{corresponding runtime} if every operation call $\pi$ appearing in $e$ is in $\Pi$ and every resource $r$ appearing in $e$ is in $R$.

If a non-variable expression cannot be reduced under the dynamic semantics it is called a \textit{value}. If we know an expression is a value then we usually denote it by $v$ instead of $e$.
\[
\begin{array}{lll}

\begin{array}{lllr}

v & ::= & r & values \\
		& | & \kwa{new}~x \Rightarrow \overline{\sigma = e} \\

\end{array}
\end{array}
\]

\noindent
Our notation for variable substitution is $[v/z]e$. This yields an expression with the same structure as $e$, where every free occurrence of $z$ has been replaced by the value $v$. Substitution on non-values is undefined. A precise definition is given in appendix \textbf{A.1.} The short-hand $[v_1/y_1, v_2/y_2]e$ is the same as $[v_2/y]([v_1/x]e)$. Note the order of the variables has been. This means the substitutions occur left-to-right, as they appear in the short-hand.

We are ready to provide the dynamic semantics for the epsilon calculus. It is given in a small-step style.\\

\noindent
$\fbox{$\rctx \vdash e \singlestep e~|~\varepsilon$}$

\[
\begin{array}{c}
\infer[\textsc{(E-MethCall1)}]
	{\rctx \vdash e_1.m(e_2) \singlestep e_1'.m(e_2)~|~\varepsilon}
	{\rctx \vdash e_1 \singlestep e_1'~|~\varepsilon} \\[4ex]

\infer[\textsc{(E-MethCall2)}]
	{\rctx \vdash v_1.m(e_2) \singlestep v_1.m(e_2')~|~\varepsilon}
	{\rctx \vdash v_1 = \newbasic & e_2 \singlestep e_2'~|~\varepsilon}\\[4ex]
	
\infer[\textsc{(E-MethCall3)}]
	{\rctx \vdash v_1.m(v_2) \singlestep [v_1/x, v_2/y]e~|~\varnothing}
	{\rctx \vdash v_1 = \newbasic & \kw{def} m(y: \tau_1): \tau_2~\kw{with} \varepsilon = \varepsilon \in \overline{\sigma = e}}\\[4ex]
	
\infer[\textsc{(E-OperCall1)}]
	{\rctx \vdash e_1.\pi \singlestep e_1'.\pi~|~\varepsilon}
	{\rctx \vdash e_1 \singlestep e_1'~|~\varepsilon}
	
~~~~~~

\infer[\textsc{(E-OperCall2)}]
	{\rctx \vdash r.\pi \singlestep \kwa{unit}~|~\{ r.\pi \}}
	{r \in R  & \pi \in \Pi}
	
	
\end{array}
\]

\noindent
Since programs contain no mutable state, we perform method execution by substituting the formal parameters of a method body for the actual values supplied to it by a method call. This is what happens in \textsc{E-MethCall3}. Furthermore, because \textsc{E-MethCall2} requires the receiver to have been reduced to a value, this enforces a left-to-right evaluation order.

When an operation is performed on a resource literal it is reduced to $\kwa{unit}$, per our convention. This is the only case in which a runtime effect occurs.\\

\noindent
We are only interested in reduction of programs which are well-formed according to a particular typing context $\Gamma$. $\Gamma$ can prove that $e$ is well-formed if every name occurring free in $e$ is defined in $\Gamma$. 

\begin{definition}[Closed Expression]
$e$ is \textit{closed} under $\Gamma$ if $z \in \kwa{freevars}(e) \implies z \in \Gamma$.
\end{definition}

\noindent
A precise definition may be found in the appendix. Closedness of programs is invariant under reduction. From this point onwards we only consider the reduction of programs which are well-typed in some $\Gamma$, and implicitly assume they are also closed under $\Gamma$.

\begin{lemma}[Closedness]
Suppose $e_A$ is closed under $\Gamma$ and $\rctx$ is a corresponding runtime. If $\rctx \vdash e_A \longrightarrow e_B~|~\varepsilon$ then $e_B$ is closed under $\Gamma$.
\end{lemma}
\begin{proof}
By induction on $\rctx \vdash e \longrightarrow e'~|~\varepsilon$.
\end{proof}

\noindent
Using single-step reductions we can define multi-step reduction. The notation is $\rctx \vdash e \longrightarrow^{*} e'~|~\varepsilon$, which means $e$ can be reduced to $e'$ via \textit{zero} or more transitive applications of the single-step reductions; their cumulative effects are the set $\varepsilon$. \\

\noindent
$\fbox{$\rctx \vdash e \multistep e~|~\varepsilon$}$

\[
\begin{array}{c}
\infer[\textsc{(E-MultiStep1)}]
	{\rctx \vdash e \multistep e~|~\varnothing}
	{}
	
~~~~~~

\infer[\textsc{(E-MultiStep2)}]
	{\rctx \vdash e \multistep e'~|~\varepsilon}
	{\rctx \vdash e \singlestep e'~|~\varepsilon} \\[4ex]
	
\infer[\textsc{(E-MultiStep3)}]
	{\rctx \vdash e \multistep e''~|~\varepsilon_1 \cup \varepsilon_2}
	{\rctx \vdash e \multistep e'~|~\varepsilon_1 & \rctx \vdash e' \multistep e''~|~\varepsilon_2}
	
\end{array}
\]

\subsection{Soundness of Epsilon Calculus}

In proving soundness we go down the traditional route of proving progress and a form of preservation which guarantees that types and effects both are preserved under reduction. Our first lemma is canonical forms, which follows by inversion on the typing rules.

\begin{lemma}[Canonical Forms]
If $v$ is a value then the following are true.
\begin{enumerate} 
	\item If $\Gamma \vdash v:\{ r \}~\kw{with} \varepsilon$, then $v = r$ for a resource $r \in \Gamma$ and $\varepsilon = \varnothing$.
	\item If $\Gamma \vdash v: \{ \bar \sigma \}~\kw{with} \varepsilon$, then $v = \newbasic$ and $\varepsilon = \varnothing$.
\end{enumerate}
\end{lemma}

\noindent
The most useful result here is that a value necessarily types as having no effect. From canonical forms we can prove the progress theorem.

\begin{theorem}[Progress]
If $\Gamma \vdash e_A: \tau_A~\kw{with} \varepsilon_A$, either $e_A$ is a value or a single-step $\rctx \vdash e_A \longrightarrow e_B~|~\varepsilon$ can be applied in a corresponding runtime.
\end{theorem}

\begin{proof}
By induction on $\Gamma \vdash e_A: \tau_A~\kw{with} \varepsilon_A$ and then by considering which subexpressions are values. If $e_A$ is a value it holds immediately, otherwise $e_A$ is a method call or an operation call. In either case, if it contains a reducible subexpression, we may apply a reduction to that subexpression. If we assume it contains no reducible subexpressions, then we are left with two cases.

Case 1: $e_A = v_1.\pi$. \textsc{E-OperCall2} gives the reduction $\rctx \vdash v_1.\pi \longrightarrow \kwa{unit}~|~\{ r.\pi \}$.

Case 2: $e_A = v_1.m_i(v_2)$. As this expression types, $v_1$ contains a declaration $\sigma_i = e_i$ for method $m_i$. Then \textsc{E-MethCall3} gives the reduction $\rctx \vdash v_1.m_i(v_2) \longrightarrow e_i~|~\varnothing$. 
\end{proof}

\noindent
To prove preservation we need the type of an expression to be preserved under reduction. Since the epsilon calculus has no subtyping, this means the type before reduction will be the same as the type after reduction.

We also need the preservation of static-effects under reduction.

If $\Gamma \vdash e_A: \tau~\kw{with} \varepsilon_A$ and $\rctx \vdash e_A \longrightarrow e_B~|~\varepsilon$ and $\Gamma \vdash e_B: \tau_B~\kw{with} \varepsilon_B$, we say the static-effects are preserved if $\varepsilon_A = \varepsilon \cup \varepsilon_B$. If we interpret $\varepsilon$ as the effects which happened during the small-step, and $\varepsilon_B$ as the effects which have yet to happen, then together these form the effects $\varepsilon_A$, which are those which were yet to happen before the reduction. Our last lemma states that an expression's type and static-effects are preserved when substituting a variable for an appropriate value.

\begin{lemma}[Substitution Lemma]
If $v$ is a value and $\Gamma, y: \tau' \vdash e: \tau ~\kw{with} \varepsilon$ and $\Gamma \vdash v: \tau'~\kw{with} \varnothing$ then $\Gamma \vdash [v/z]e : \tau~\kw{with} \varepsilon$.
\end{lemma}

\begin{proof}
By induction on $\Gamma, z: \tau' \vdash e: \tau~\kw{with} \varepsilon$.
\end{proof}

\begin{theorem}[Preservation Theorem]
If $\Gamma \vdash e_A: \tau_A~\kw{with} \varepsilon_A$ and $\rctx \vdash e_A \longrightarrow e_B~|~\varepsilon$ in a corresponding runtime, then the following are true:

\begin{itemize}
	\item $\Gamma \vdash e_B: \tau_B~\kw{with} \varepsilon_B$
	\item $\tau_B = \tau_A$
	\item $\varepsilon_A = \varepsilon_B \cup \varepsilon$
\end{itemize}

\end{theorem}

\begin{proof}

By induction on $\Gamma \vdash e_A: \tau_A~\kw{with} \varepsilon_A$ and then on $\rctx \vdash e_A \longrightarrow e_B~|~\varepsilon$. If $e_A$ is a value the result holds vacuously. Otherwise $e_A$ is a non-value, and therea re two typing rules to consider.

The first rule is \textsc{$\varepsilon$-OperCall}. Then $e_A = e_1.\pi$. If the reduction used was $\rctx \vdash e_1.\pi \longrightarrow e_1'.\pi~|~\varepsilon$, then the result follows by applying the induction hypothesis to the subreduction. Otherwise the reduction was $\rctx \vdash r.\pi \longrightarrow \kwa{unit}~|~\varnothing$, in which case the reduction follows by using \textsc{$\varepsilon$-NewObj} to type $\Gamma \vdash \kwa{unit} : \kw{Unit} \kw{with} \varnothing$.

The second rule is \textsc{$\varepsilon$-MethCall}. Then $e_A = e_1.m_i(e_2)$. If the reduction used involved reducing a subexpression, the result follows by induction on the appropriate subreduction. Otherwise the reduction used was $\rctx \vdash v_1.m_i(v_2) \longrightarrow [v_1/x, v_2/y]e_i~|~\varnothing$, where $e_i$ is the method body for $m_i$. The result follows by inversion on $\Gamma \vdash e_1: \{ \bar \sigma \}~\kw{with} \varnothing$ to obtain a typing judgement for $e_i$, and then two applications of the substitution lemma to $[v_1/x, v_2/y]e_i$.

\end{proof}

\noindent
Putting together preservation and progress immediately yields soundness for single-step reductions. To obtain soundness for multi-step reductions, we induct on the length of a multi-step erduction and appeal to the soundness of single-step reductions.

\begin{theorem}[Single-Step Soundness]
If $\Gamma \vdash e_A: \tau_A~\kw{with} \varepsilon_A$ and then either $e_A$ is a value or the following are true in a corresponding runtime:
\begin{itemize}
	\item $\rctx \vdash e_A \longrightarrow e_B~|~\varepsilon_B$
	\item $\Gamma \vdash e_B: \tau_B~\kw{with} \varepsilon_B$
	\item $\tau_A = \tau_B$
	\item $\varepsilon_A = \varepsilon \cup \varepsilon_B$
\end{itemize}

\end{theorem}

\begin{theorem}[Multi-Step Soundness]
If $\Gamma \vdash e_A: \tau_A~\kw{with} \varepsilon_A$ and then either $e_A$ is a value or the following are true in a corresponding runtime:
\begin{itemize}
	\item $\rctx \vdash e_A \longrightarrow^{*} e_B~|~\varepsilon_B$
	\item $\Gamma \vdash e_B: \tau_B~\kw{with} \varepsilon_B$
	\item $\tau_A = \tau_B$
	\item $\varepsilon_A = \varepsilon \cup \varepsilon_B$
\end{itemize}
\end{theorem}


\subsection{Desugaring Rules}

The epsilon calculus is able to map to pure, capability-safe object-oriented languages with first-class modules. In this section we show how to encode common language constructs. \\

\noindent
A let expression has the form $\kw{let} z = e_A~\kw{in}~e_B$. If $\Gamma \vdash e_A: \tau_A~\kw{with} \varepsilon_A$ and $\Gamma \vdash e_B: \tau_B~\kw{with} \varepsilon_B$, the let can be desugared as in figure 3.

\begin{figure}[h]
\begin{lstlisting}[mathescape]
let x = $e_1$ in $e_2$
\end{lstlisting}

\begin{lstlisting}[mathescape]
new x $\Rightarrow$ {
   def doIt(y: $\tau_A$): $\tau_B$ with $\varepsilon_B$ = $e_B$
}.doIt($e_A$)
\end{lstlisting}

\vspace{-7pt}
\caption{Let expression desugaring.}
\label{f-resource-modules}
\end{figure}

\noindent
A basic program in one file may be considered as consisting of a single module $\kwa{MainModule}$ with a method $\kwa{main}$. The body of $\kwa{main}$ will contain the expression to be executed in the file, which the desugared program invokes. Any resources used must be defined in the runtime $\rctx$ in which execution takes place.

\begin{figure}[h]

\begin{lstlisting}
FileIO.write
\end{lstlisting}

\begin{lstlisting}[mathescape]
let MainModule = new x $\Rightarrow$ {
   def main(): Unit = FileIO.write
} in MainModule.main()
\end{lstlisting}
\vspace{-7pt}
\caption{A basic program desugared into its implicit ``main module'' form. An appropriate runtime would be $\langle FileIO, write \rangle$}
\end{figure}

\noindent
Where there are multiple modules in a program we must instantiate them before invoking main. This requires resolving module dependencies. In our programs there are two sorts of (impure) capabilities that a module might require.

The first are those drawn from the fixed set of resources $R$. These are assumed to be supplied by some executing environment For example, $\kwa{FileIO}$ could be a file-handle passed to the program via command-line. We assume these capabilities exist in the runtime $\rctx$.

The other sort of impure capabilities are those objects which use a resource, directly or indirectly. If $\kwa{Module}$ depends on $C_1$ and $C_2$, we must instantiate modules $C_1$ and $C_2$ first and then pass them to module $A$ as arguments. If we assume $C_1$ and $C_2$ have already been created, $\kwa{Module}$ can be created by nesting several objects inside each other. Each successive object will have a single method which binds one of the required modules. The inner-most object will have a single method returning an object containing all the methods defined by $\kwa{Module}$. Figure 5 demonstrates how this works. \\

\begin{figure}[h]
\begin{lstlisting}[mathescape]
module Module
require Capability1 as $c_1$
require Capability2 as $c_2$

def method$_1$(): Unit = Capability$_1$.action()
def method$_2$(): Unit = Capability$_2$.action()
\end{lstlisting}

\begin{lstlisting}[mathescape]
let c$_1$ = .... in
let c$_2$ = .... in

let Module = new x $\Rightarrow$ {
   def resolveC$_1$(capability$_1$: Capability$_1$Type) with $\varnothing$ =
      new x $\Rightarrow$ {
         def resolveC$_2$(capability$_2$: Capability$_2$Type) with $\varnothing$ =
            new x $\Rightarrow$ {
               def method$_1$(): Unit =
                  capability$_1$.action()
               def method$_2$(): Unit =
                  capability$_2$.action()
         }
      }
}.resolveC$_1$(c$_1$).resolveC$_2$(c$_2$)

\end{lstlisting}

\vspace{-7pt}
\caption{Desugaring of the initialisation of $\kwa{Module}$, which has dependencies $\kwa{C1}$ and $\kwa{C2}$.}
\end{figure}

\noindent
We are now able to desugar the example from section 2. This example can be written in the epsilon calculus, as in figure 6. It will not typecheck, highlighting the mismatch between specification and implementation. This is because in order to typecheck $\kwa{loggerModule}$ using \textsc{$\varepsilon$-NewObj}, we must first typecheck the implementation of $\kwa{loggerModule.log}$ against its declaration using \textsc{$\varepsilon$-ValidImpl}. This rule cannot be appiled, as $\kwa{FileIO} : \{ \kwa{FileIO} \} \vdash \kwa{FileIO.write} : \kwa{unit} ~\kw{with} \{ \kwa{FileIO.write} \}$, and the effect-set $\{ \kwa{FileIO.write} \}$ is different from $\{ \kwa{FileIO.append} \}$.

\begin{figure}[h]
\vspace{-5pt}
\begin{lstlisting}[mathescape]
type Logger is
   def log(): Unit with {FileIO.append}
in

let loggerModule = new x $\Rightarrow$ {
   def log(): Unit with {FileIO.append} =
      FileIO.write
} in
      
let clientModule = new x $\Rightarrow$ {
   def run(logger: Logger): Unit with {FileIO.append} =
      logger.log()
} in

let mainModule = new x $\Rightarrow$ {
   def main(): Unit with {FileIO.append} =
      clientModule.run(loggerModule)
}

in mainModule.main()

\end{lstlisting}

\vspace{-7pt}
\caption{An effect-annotated version of the logger example wil fail to typecheck, highlighting the discrepancy between the interface of $\kwa{loggerModule.log}$ and its implementation.}
\end{figure}

\newpage

\appendix
\section{Proofs \& Definitions For Epsilon Calculus}

\subsection{Well-Formedness}

\begin{definition}[$\kwa{freevars}$]~
\begin{itemize}
	\item $\kwa{freevars}(r) = \varnothing$
	\item $\kwa{freevars}(x) = \varnothing$
	\item $\kwa{freevars}(e_1.m(e_2)) = \kwa{freevars}(e_1) \cup \kwa{freevars}(e_2)$
	\item $\kwa{freevars}(e_1.\pi) = \kwa{freevars}(e_1)$
	\item $\kwa{freevars}(\newbasic) = \bigcup (\kwa{freevars}(e_i) \setminus \{ y, x \})$, where $\kw{def} m_i(y: \tau_2): \tau_3~\kw{with} \varepsilon$
\end{itemize}
\end{definition}

\begin{lemma}[Closedness]
Suppose $e_A$ is closed under $\Gamma$ and $\rctx$ is a corresponding runtime. If $\rctx \vdash e_A \longrightarrow e_B~|~\varepsilon$ then $e_B$ is closed under $\Gamma$.
\end{lemma}

\begin{proof}
By induction on $\rctx \vdash e_A \longrightarrow e_B~|~\varepsilon$. \\

\noindent
\fbox{Case: $\varepsilon$-MethCall1} By induction $\kwa{freevars}(e_1') \subseteq \Gamma$, so $\kwa{freevars}(e_1'.m(e_2)) \subseteq \Gamma$. \\

\noindent
\fbox{Case: $\varepsilon$-MethCall2} By induction $\kwa{freevars}(e_2') \subseteq \Gamma$, so $\kwa{freevars}(e_1.m(e_2')) \subseteq \Gamma$. \\

\noindent
\fbox{Case: $\varepsilon$-MethCall3} Then $\rctx \vdash v_1.m_i(v_2) \longrightarrow [v_1/x, v_2/y]e_1$. Because $e_A$ is closed under $\Gamma$ so is its subexpression $v_1$, and so $\kwa{freevars(e_i) \setminus {y,x}} \subseteq \Gamma$. Then $\kwa{freevars}([v_1/x, v_2/y]e_i) = \kwa{freevars}(e_i) \setminus \{ x,y \}$, so $[v_1/x, v_2/y]e_i$ is also closed under $\Gamma$. \\

\noindent
\fbox{Case: $\varepsilon$-OperCall1} By induction $e_1'$ is closed under $\Gamma$. Then $e_1'.\pi$ is too.  \\

\noindent
\fbox{Case: $\varepsilon$-OperCall2} Then $e_B = \kwa{unit}$ and $\kwa{freevars}(\kwa{unit}) = \varnothing \subseteq \Gamma$ trivially. \\

\end{proof}

\subsection{Definition of Substitution}

Informally, $[e'/z]e$ produces an expression where every free occurrence of $z$ has been replaced by $e'$. We use the convention of $\alpha$-conversion, which says that free variables may be renamed to avoid accidental capture. [ cite TAPL page 71] \\

$[e'/z]z = e'$

$[e'/z]y = y$, if $y \neq z$

$[e'/z]r = r$

$[e'/z](e_1.m(e_2)) = ([e'/z]e_1).m([e'/z]e_2)$

$[e'/z](e_1.\pi) = ([e'/z]e_1).\pi$

$[e'/z](\newbasic) = \kwa{new}~x\Rightarrow \overline{\sigma = [e'/z]e}$, if $z \neq x$ and $z \notin \kwa{freevars}(e_i)$

\subsection{Canonical Forms}

\begin{lemma}[Canonical Forms]
If $v$ is a value then the following are true.
\begin{enumerate} 
	\item If $\Gamma \vdash v:\{ r \}~\kw{with} \varepsilon$, then $v = r$ for a resource $r \in \Gamma$ and $\varepsilon = \varnothing$.
	\item If $\Gamma \vdash v: \{ \bar \sigma \}~\kw{with} \varepsilon$, then $v = \newbasic$ and $\varepsilon = \varnothing$.
\end{enumerate}
\end{lemma}

\begin{proof}
The first two judgements appear exactly once in the conclusions of \textsc{$\varepsilon$-Resource} and \textsc{$\varepsilon$-NewObj} respectively, yielding \textbf{1} and \textbf{2} directly. The only other rule for typing values is \textsc{$\varepsilon$-Var}, and in the conclusions of all three rules, $\varepsilon = \varnothing$.
\end{proof}

\subsection{Progress Theorem}

\begin{theorem}[Progress]
If $\Gamma \vdash e_A: \tau_A~\kw{with} \varepsilon_A$, either $e_A$ is a value or a single-step $\rctx \vdash e_A \longrightarrow e_B~|~\varepsilon$ can be applied in a corresponding runtime.
\end{theorem}

\begin{proof}

By induction on the derivation of $\Gamma \vdash e_A: \tau_A~\kw{with} \varepsilon_A$. If $e_A$ is not a value then one of two rules could have been used.\\

\noindent
\fbox{Case: $\varepsilon$-MethCall} Then $e_A = e_1.m_i(e_2)$ and the following are known.

\begin{enumerate}
	\item $e_A: \tau_3~\kw{with} \varepsilon_1 \cup \varepsilon_2 \cup \varepsilon_3$
	\item $e_1: \{ \bar \sigma \}~\kw{with} \varepsilon_1$
	\item $e_2: \tau_2~\kw{with} \varepsilon_2$
	\item $\sigma_i = \kwa{def}~m_i(y: \tau_2): \tau_3~\kw{with} \varepsilon_3$
\end{enumerate}

\noindent
We look at the cases for when $e_1$ and $e_2$ are values. If $e_1$ is not a value then by the inductive hypothesis applied to \textbf{2} there is a reduction $\rctx \vdash e_1 \longrightarrow e_1'~|~\varepsilon$. Then \textsc{E-MethCall1} gives the reduction $\rctx \vdash e_1.m_i(e_2) \longrightarrow e_1'.m_i(e_2)~|~\varepsilon$.

If $e_2$ is not a value then by the inductive hypothesis applied to \textbf{3} there is a reduction $\rctx \vdash e_2 \longrightarrow e_2'~|~\varepsilon$. Without loss of generality, $e_1$ is a value. Then \textsc{E-MethCall2} gives the reduction $\rctx \vdash e_1.m_i(e_2) \longrightarrow e_1.m_i(e_2')~|~\varepsilon$.

Otherwise $e_1$ and $e_2$ are values. By canonical forms, $e_1 = \newbasic$. By inversion on \textbf{2}, there is a declaration $\kwa{def}~m_i(y: \tau_2): \tau_3~\kw{with} \varepsilon_3 = e_i \in \overline{\sigma = e}$. Then \textsc{E-MethCall3} gives the reduction $\rctx \vdash e_1.m_i(e_2) \longrightarrow [e_1/x, e_2/y]e_i~|~\varnothing$.

\end{proof}

\subsection{Substitution Lemma}

\begin{lemma}[Substitution Lemma]
If $v$ is a value and $\Gamma \vdash v: \tau'~\kw{with} \varnothing$ and $\Gamma, z: \tau' \vdash e: \tau~\kw{with} \varepsilon$, then $\Gamma \vdash e: [v/z]e: \tau~\kw{with} \varepsilon$.
\end{lemma}

\begin{proof}
By induction on $\Gamma, z: \tau' \vdash e: \tau~\kw{with} \varepsilon$. If $z$ does not occur free in $e$, then $[e'/z]e = e$ and the theorem holds trivially. Therefore in each case we assume $z$ occurs free in $e$. \\

\noindent
\fbox{Case: \textsc{$\varepsilon$-Var}} Then $\Gamma, z: \tau' \vdash z: \tau~\kw{with} \varnothing$ by canonical forms. After substitution, $[v/z]z = v$, so $\Gamma \vdash [v/z]z : \tau~\kw{with} \varepsilon$.\\

\noindent
\fbox{Case: \textsc{$\varepsilon$-Resource}} Since $[e'/z]r = r$ the statement holds vacuously. \\


\noindent
\fbox{Case: \textsc{$\varepsilon$-OperCall}}
Then $e = e_1.\pi$. By inversion on \textsc{$\varepsilon$-OperCall}, we learn $\Gamma, z: \tau' \vdash e_1: \{ r \}~\kw{with} \varepsilon_1$, where $\varepsilon = \varepsilon_1 \cup \{ r.\pi \}$. By inductive assumption, $\Gamma \vdash [v/z]e_1: \{ r \}~\kw{with} \varepsilon_1$. By definition, $[v/z](e_1.\pi) = ([v/z]e_1).\pi$. By application of \textsc{$\varepsilon$-OperCall} we learn $\Gamma \vdash [v/z](e_1.\pi) : \{ r \} ~\kw{with} \varepsilon_1 \cup \{ r.\pi \}$.
\\

\noindent
\fbox{Case: \textsc{$\varepsilon$-MethCall}}
Then $e = e_1.m_i(e_2)$. From inversion on \textsc{$\varepsilon$-MethCall} we learn:

\begin{enumerate}
	\item $\sigma_i = \kwa{def}~m_i(y: \tau_2): \tau_3~\kw{with} \varepsilon_3$
	\item $\Gamma, z:\tau' \vdash e_1 : \tau_1~\kw{with} \varepsilon_1$
	\item $\Gamma, z:\tau' \vdash e_2: \tau_2~\kw{with} \varepsilon_2$
	\item $\tau = \tau_3$ and $\varepsilon = \varepsilon_1 \cup \varepsilon_2 \cup \varepsilon_3$
\end{enumerate}

\noindent
By inductive assumption on \textbf{2} and \textbf{3} we get a pair of judgements $\Gamma \vdash [v/z]e_1: \tau_1~\kw{with} \varepsilon_1$ and $\Gamma \vdash [v/z]e_2: \tau_2~\kw{with} \varepsilon_2$. By definition, $[v/z](e_1.m_i(e_2)) = ([v/z]e_1).m_i([v/z]e_2)$. From the two judgements we just derived and simplification by \textbf{4}, we can apply \textsc{$\varepsilon$-MethCall} to obtain $\Gamma \vdash [v/z](e_1.m_i(e_2)): \tau_3~\kw{with} \varepsilon$.
\\

\noindent
\fbox{Case: $\varepsilon$-NewObj}
Then $e = \newbasic$ and $z$. Consider some method $\sigma_i = e_i$. From canonical forms, the assumption from the theorem statement can be more specifically written as $\Gamma, z: \tau' \vdash e: \{ \bar \sigma \}~\kw{with} \varnothing$.  By inversion on this judgement we know $\Gamma, z: \tau', x: \{ \bar \sigma \} \vdash \overline{\sigma = e}~\kwa{OK}$. The only rule with this conclusion is \textsc{$\varepsilon$-ValidImpl}. By inversion on that rule we learn:

\begin{enumerate}
	\item $\sigma_i = \kw{def} m_i(y: \tau_1): \tau_2~\kw{with} \varepsilon$
	\item $\Gamma, z: \tau', x: \{ \bar \sigma \}, y: \tau_1 \vdash e_i: \tau_2~\kw{with} \varepsilon$
\end{enumerate}

\noindent
By inductive assumption applied to \textbf{2} we get $\Gamma, x: \{ \bar \sigma \}, y: \tau_1 \vdash [v/z]e_i : \tau_2~\kw{with} \varepsilon$. Then by applying \textsc{$\varepsilon$-ValidImpl} we get $\Gamma, x: \{ \bar \sigma \} \vdash \sigma_i = [v/z]e_i~\kwa{OK}$. The method $\sigma_i = e_i$ was arbitrary, so $\Gamma, x: \{ \bar \sigma \} \vdash \overline{\sigma = e}~\kwa{OK}$. Then by applying \textsc{$\varepsilon$-NewObj} we get $\Gamma \vdash [v/z]e: \{ \bar \sigma \}~\kw{with} \varnothing$.
\end{proof}

\subsection{Preservation Theorem}

\begin{theorem}[Preservation Theorem]
If $\Gamma \vdash e_A: \tau_A~\kw{with} \varepsilon_A$ and $\rctx \vdash e_A \longrightarrow e_B~|~\varepsilon$ in a corresponding runtime, then the following are true:

\begin{itemize}
	\item $\Gamma \vdash e_B: \tau_B~\kw{with} \varepsilon_B$
	\item $\tau_B = \tau_A$
	\item $\varepsilon_A = \varepsilon_B \cup \varepsilon$
\end{itemize}

\end{theorem}


\begin{proof}
By induction on $\Gamma \vdash e_A: \tau_A~\kw{with} \varepsilon_A$ and then on $\rctx \vdash e_A \longrightarrow e_B~|~\varepsilon$. If $e_A$ is a value no reduction can be applied so the theorem statement vacuously holds. Otherwise there are two rules to consider.\\

\noindent
\fbox{Case: $\varepsilon$-OperCall}
Then $e_A = e_1.\pi$ and we know:

\begin{enumerate}
	\item $\Gamma \vdash e_A: \kwa{Unit}~\kw{with} \{ r.\pi \} \cup \varepsilon_1$
	\item $e_1: \{ r \}~\kw{with} \varepsilon_1$
\end{enumerate}

\noindent
If the reduction rule used was \textsc{E-OperCall1} then $\rctx \vdash e_1 \longrightarrow e_1'~|~\varepsilon$ and $\rctx \vdash e_1.\pi \longrightarrow e_1'.\pi~|~\varepsilon$. By inductive assumption, $\Gamma \vdash e_1': \{ r \}~\kw{with} \varepsilon_1'$, where $\varepsilon_1 = \varepsilon \cup \varepsilon_1'$. By application of \textsc{$\varepsilon$-OperCall} we have $\Gamma \vdash e_1'.\pi: \kwa{Unit}~\kw{with} \{ r.\pi \} \cup \varepsilon_1'$. Then $\varepsilon_B \cup \varepsilon = \{ r.\pi \} \cup \varepsilon_1' \cup \varepsilon = \{ r.\pi \} \cup \varepsilon_1 = \varepsilon_A$.

If the rule used was \textsc{E-OperCall2} then $\rctx \vdash r.\pi \longrightarrow \kwa{unit}~|~\{r.\pi\}$. By canonical forms, $\varepsilon_1 = \varnothing$, so by \textbf{1} we have $\varepsilon_A = \{ r.\pi \}$. By a degenerate case of \textsc{$\varepsilon$-NewObj}, $\Gamma \vdash \kwa{unit} : \kwa{Unit}~\kw{with} \varnothing$. Then $\varepsilon_B \cup \varepsilon = \varnothing \cup \{ r.\pi \} = \varepsilon_A$. \\

\noindent
\fbox{Case: $\varepsilon$-MethCall}
Then $e_A = e_1.m_i(e_2)$ and the following are true.

\begin{enumerate}
	\item $\Gamma \vdash e_A: \tau_3~\kw{with} \varepsilon_1 \cup \varepsilon_2 \cup \varepsilon_3$
	\item $\Gamma \vdash e_1: \{ \bar \sigma \}~\kw{with} \varepsilon_1$
	\item $\Gamma \vdash e_2: \tau_2~\kw{with} \varepsilon_2$
	\item $\sigma_i = \kw{def} m_i(y: \tau_2): \tau_3~\kw{with} \varepsilon_3$
\end{enumerate}

\noindent
If the reduction rule used was \textsc{E-MethCall1} then $\rctx \vdash e_1 \longrightarrow e_1'~|~\varepsilon$ and $\rctx \vdash e_1.m_i(e_2) \longrightarrow e_1'.m_i(e_2)~|~\varepsilon$. By inductive assumption, $\Gamma \vdash e_1': \{ \bar \sigma \}~\kw{with} \varepsilon_1'$, where $\varepsilon_1 = \varepsilon_1' \cup \varepsilon$. By applying \textsc{$\varepsilon$-MethCall} we have $\Gamma \vdash e_1'.m_i(e_2): \tau_3~\kw{with} \varepsilon_1' \cup \varepsilon_2 \cup \varepsilon_3$. Then $\varepsilon_B \cup \varepsilon = \varepsilon_1' \cup \varepsilon_2 \cup \varepsilon_3 \cup \varepsilon = \varepsilon_1 \cup \varepsilon_2 \cup \varepsilon_3 = \varepsilon_A$.

If the reduction rule used was \textsc{E-MethCall2} then we know $\rctx \vdash e_2 \longrightarrow e_2'~|~\varepsilon$ and $e_1.m_i(e_2) \longrightarrow e_1.m_i(e_2')~|~\varepsilon$. $\Gamma \vdash e_1.m_i(e_2'): \tau_2~\kw{with} \varepsilon_1 \cup \varepsilon_2' \cup \varepsilon_3$. By inductive assumption, $\Gamma \vdash e_2': \tau_2~\kw{with} \varepsilon_2'$, where $\varepsilon_2 = \varepsilon \cup \varepsilon_2'$. By applying \textsc{$\varepsilon$-MethCall} we have $\Gamma \vdash e_1.m_i(e_2): \tau_3~\kw{with} \varepsilon_1 \cup \varepsilon_2' \cup \varepsilon_3$. Then $\varepsilon \cup \varepsilon_B = \varepsilon \cup \varepsilon_1 \cup \varepsilon_2' \cup \varepsilon_3 = \varepsilon_1 \cup \varepsilon_2 \cup \varepsilon_3 = \varepsilon_A$. Additionally, $\varepsilon_1 = \varnothing$ by canonical forms.

If the reduction rule used was \textsc{E-MethCall3} then we know $e_1 = v_1$ and $e_2 = v_2$ are values and $\rctx \vdash v_1.m_i(v_2) \longrightarrow [v_1/x, v_2/y]e_i~|~\varnothing$. By inversion on \textbf{2} there is a typing judgement $\Gamma, x: \{ \bar \sigma \}, y: \tau_2 \vdash e_i: \tau_3~\kw{with} \varepsilon_3$. By two applications of the substitution lemma, $\Gamma \vdash [v_1/x, v_2/y]e_i: \tau_3~\kw{with} \varepsilon_3$. By canonical forms, $\varepsilon_1 = \varepsilon_2 = \varnothing$. Then $\varepsilon_B \cup \varepsilon = \varepsilon_3 \cup \varnothing = \varepsilon_A$.
\end{proof}

\subsection{Soundness Theorems}

\begin{theorem}[Single-Step Soundness]
If $\Gamma \vdash e_A: \tau_A~\kw{with} \varepsilon_A$ and then either $e_A$ is a value or the following are true in a corresponding runtime:
\begin{itemize}
	\item $\rctx \vdash e_A \longrightarrow e_B~|~\varepsilon_B$
	\item $\Gamma \vdash e_B: \tau_B~\kw{with} \varepsilon_B$
	\item $\tau_A = \tau_B$
	\item $\varepsilon_A = \varepsilon \cup \varepsilon_B$
\end{itemize}

\end{theorem}

\begin{proof}
If $e_A$ is not a value then a reduction $\rctx \vdash e_A \longrightarrow e_B~|~\varepsilon_B$ exists by the progress theorem. Type-and-effect soundness holds by the preservation theorem.
\end{proof}

\begin{theorem}[Multi-Step Soundness]
If $\Gamma \vdash e_A: \tau_A~\kw{with} \varepsilon_A$ and then either $e_A$ is a value or the following are true in a corresponding runtime:
\begin{itemize}
	\item $\rctx \vdash e_A \longrightarrow^{*} e_B~|~\varepsilon_B$
	\item $\Gamma \vdash e_B: \tau_B~\kw{with} \varepsilon_B$
	\item $\tau_A = \tau_B$
	\item $\varepsilon_A = \varepsilon \cup \varepsilon_B$
\end{itemize}
\end{theorem}

\begin{proof}
By induction on the number of small-step reductions in $\rctx \vdash e_A \multistep e_B~|~\varepsilon$. If there are no small-steps then $e_B \cup \varepsilon = \varepsilon_B = e_A$ and the result holds trivially. If there is one small-step then the result holds by small-step soundness.

Otherwise there are $n > 1$ small-steps then consider a multi-step reduction $\rctx \vdash e_A \longrightarrow e_C~|~\varepsilon$ of length $n$. This consists of a multi-step reduction of length $n$, $\rctx \vdash e_A \multistep e_B~|~\varepsilon_1$, and a single-step reduction $\rctx \vdash e_B \longrightarrow e_C~|~\varepsilon_2$, where $\varepsilon = \varepsilon_1 \cup \varepsilon_2$. By inductive assumption, $\Gamma \vdash e_B: \tau_B~\kw{with} \varepsilon_B$, where $\varepsilon_1 \cup \varepsilon_B = \varepsilon_A$, and $\tau_B = \tau_A$. By small-step soundness, $\Gamma \vdash e_C: \tau_C~\kw{with} \varepsilon_C$, where $\varepsilon_B = \varepsilon_C \cup \varepsilon_2$ and $\tau_B = \tau_C$. By transitivity, $\tau_A = \tau_C$. By comparing equalities, $\varepsilon_A = \varepsilon_1 \cup \varepsilon_B = \varepsilon_1 \cup \varepsilon_C \cup \varepsilon_2 = \varepsilon \cup \varepsilon_C$.

\end{proof}

%%
%% Bibliography
%%

%% Either use bibtex (recommended), 

\bibliography{lipics-v2016-sample-article}

%% .. or use the thebibliography environment explicitely



\end{document}
