\chapter{Introduction}\label{C:intro}

Good software is distinguished from bad software by design qualities such as security, maintainability, and performance. One of these is the \textit{principle of least authority}: that software components should only have access to the information and resources necessary for their purpose \cite{saltzer74}. For example, a logger module, which need only append to a file, should not have arbitrary read-write access. Another is \textit{privilege separation}, where the division of a program into components is informed by what resources are needed and how they are to be propagated \textbf{[?]}.

Matters get complicated when a program is contains untrustworthy components. Such cases may arise in a development environment which adheres to \textit{code ownership}, whereby groups of developers may function as particular experts over certain components \textbf{[?]}. When they interact with code sourced from outside their domain of expertise, they may make false assumptions or violate the internal constraints of other components. Applications may allow third-party plug-ins, in which case third-party code is sourced from an untrustworthy source. A web mash-up is a particular kind of software that brings together disparate applications into a central service, in which case the disparate applications may be untrustworthy.

When a codebase has untrustworthy code it may be impossible or infeasible for developers to verify that it adequately enforces separation of privileges and POLA. Often they may not have access to the original source code. This leaves developers to make a judgement call on whether this untrusted code should be used or executed based on the type interface and accompanying verbal contracts.

One approach to privilege separation is the \textit{capability} model. A capability is an unforgeable token granting its bearer permission to perform some operation \cite{dennis66}. Resources in a program are only exercised though the capabilities granting them. Although the notion of a capability is an old one, there has been recent interest in the application of the idea to programming language. Miller has identified the ways in which capabilities should proliferate to encourage \textit{robust composition} --- a set of ideas summarised as ``only connectivity begets connectivity'' \cite{miller06}. In his paradigm, the reference graph of a program is the same as the access graph. This eliminates \textit{ambient authority} --- a pervasive enemy in determining by interface what privileges a component might exercise. Building on these ideas, Maffeis et. al. formalised \textit{capability-safety} of a language, showing a subset of Caja (a JavaScript implementation) meets this notion \cite{maffeis10}.

While capabilities adequately separate privileges, understanding the way in which those privileges are exercised has received less attention. This area falls under the domain of effect systems, which extends type systems to include intensional information about the way in which a program executes \cite{nielson99}. For example, a logger's log method may have $\kwa{append}$ as its effect, but a sloppy or malicious implementation may incur extra effects, such as $\kwa{write}$ or $\kwa{close}$. This suggests the logger may be doing more than just logging, and knowing this guides the developer to a more informed decision about whether to use this particular implementation.

One obstacle to the adoption of effect systems is their verbosity. An effect system such as the Talpin-Jouvelot system requires the annotation of all values in a program \textbf{[cite]}. This requires the developer to be aware, at all points, of what effects are happening and where. Minor alterations to the signatures and effects of a component require the labels on all interacting components to change in accordance. This overhead is something the developer must carry with them at all stages of programming, affecting the usability of effect systems. Successive works have focussed on reducing these issues through techniques such as effect-inference, but the benefit of capabilities for effect-based reasoning has received less attention. This paper suggests that capability-safety permits an effect system with minimal overhead.

This paper's contribution is to develop an extension to the simply-typed lambda calculus $\stlc$ called the epsilon calculus $\epscalc$. $\epscalc$ introduces a new construct which selects those capabilities used in a peice of unlabelled code. A sound inference can be made about the unlabelled code by inspecting the type signatures of those functions in scope at the point of introduction. This is made possible by the restrictions imposed on the use and exchange of capabilities.

Chapter 2 covers some background information on capabilities and programming language semantics. It also establishes the various conventions used throughout. We identify some of the benefits obtained by capabilities and effects, and some of the drawbacks we set out to solve.

Chapter 3 introduces static and dynamic rules for $\epscalc$, developing and proving a formulation of soundness appropriate for the type-and-effect discipline. 

Chapter 4 shows how $\epscalc$ might solve these drawbacks, and try to convince the reader that $\epscalc$ can be implemented in existing capability-safe languages in a routine manner.
 
