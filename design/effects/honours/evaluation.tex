
\chapter{Evaluation}

\section{Related Work}

Fengyun Liu has approached the study of capability-based effect systems by developing a lambda calculus based around two type-constructors for building free and stoic functions \cite{liu16}. Free functions may ambiently capture capabilities, but stoic functions may not; for a stoic function to have any effect, it must be explicitly given the capability for that effect. The resulting theory allows the type system to determine if a stoic function is pure or not by inspecting its parameters. If a function is known to be pure there are many optimisations that can be made (inlining, parallelisation). Liu's work is largely motivated by achieving such optimisations for Scala compilers.

By contrast, our work is motivated by the propagation and use of capabilities, and how language-design features might inform software design. Unlike Liu's System F-Impure, $\epscalc$ has no effect-polymorphism. However, our work has more fine-grained detail about those effects incurred by a particular function --- while System F-Impure can conclusively determine if a stoic function is pure, determining what particular effects an impure function has is outside of the scope of Liu's work.

\section{Future Work}

A major limitation to practical adoption of $\epscalc$ is that it is not Turing complete --- it has no general recursion, nor recursive types. Extending $\epscalc$ to include these features would bring it up to par with real programming languages.

Miller's formulation of the capability-model is in terms of objects, and all of the capability-safe languages to which this paper has referred are object-oriented. It is worth investigating how the bridge between $\epscalc$ and existing capability-safe languages might be bridged by investigating different object encodings, and determining which langauge extensions are needed to enable these. By extension, these languages have first-class modules, so a version of $\epscalc$ which can reason about objects would immediately yield module-level reasoning.

The biggest contribution that could be made to $\epscalc$ would be to enrich it with a theory of polymorphic effects. As an example, consider $\lambda x: \Unit \rightarrow_{\varepsilon} \Unit . ~x~\unit$, where $\varepsilon$ is free. Invoking this particular function would incur every effect in $\varepsilon$, but allowing general. Currently $\epscalc$ has no way to define such functions which are parametrised by effect-sets. Deveoping an extension which can handle polymorphic effects would be a valuable contribution, and improve the stock of $\epscalc$ as a practical type-and-effect system.

\section{Conclusion}

$\epscalc$ is an extension to $\stlc$ which allows for the import of capabilities into unlabelled code. This importing is done in a capability-safe manner, which prohibits the exercise of ambient authority. As a result, we can safely bound the set of possible effects in the unlabelled code by inspecting those capabilities passed into it via the $\kwa{import}$ expression.

\textbf{Talk about examples given, mention any extensions needed to allow for things such as multiple imports.}

There are some important limitations to $\epscalc$: it has no general recursion, and no recursive types; it is formulated in terms of the lambda calculus, whereas the capability model is stated in terms of objects; it has no way to express functions with polymorphic effects. These are all interesting avenues of future work that would enrich $\epscalc$ and our collective understanding of the relation between effects and capabilities.






