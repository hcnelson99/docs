
\chapter{Evaluation}

\section{Related Work}

Fengyun Liu has explored how a capability-safety can be used to determine which sections of code are pure \cite{liu16}. His approach develops a lambda calculus with two type-constructors for building free and stoic functions. Free functions may ambiently capture capabilities, but stoic functions may not. For a stoic function to have effects, it must be explicitly given the capability for that effect. These functions are small, capability-safe pockets that enable the type system to determine purity. If a function is known to be pure then optimisations such as inlining and parallelisation can be made. Liu's work is motivated by achieving such optimisations for Scala.

By contrast, our work is motivated by how capabilities are propagated and exercised, and how language-design features might inform sofwate design. Unlike Liu's System F-Impure, $\epscalc$ has no effect-polymorphism. However, our work has more fine-grained detail about those effects incurred by a particular function, and distinguishes higher-order effects from the non-higher-order kind.

\section{Future Work}

A limitation to practical adoption of $\epscalc$ is that it is not Turing complete --- it has no general recursion, nor recursive types. Extending $\epscalc$ to include these features would bring it up to par with real programming languages. Extending $\epscalc$ to accommodate these features is expected to be routine, but has not been done.

We have seen that approximating some unannotated code by every effect it exercises can lead to very conservative overapproximations. Section 4.2.4. illustrates with $\import{\kwa{File.*}}{x}{unit}{\lambda f: \kwa{ \{ File \}}.~f.write}$ which is a piece of effect-less, unannotated code that returns an effectful function. However, the effectless code is approximated as incurring $\kwa{File.*}$. By a careful analysis of which effects are sourced directly or in a higher-order fashion,t he rules of $\epscalc$ might be amended to give a better approximation.

The current theory contains no notion of polymorphic effects. As an example, consider $\lambda x: \Unit \rightarrow_{\varepsilon} \Unit . ~x~\unit$, where $\varepsilon$ is free. Invoking this particular function would incur every effect in $\varepsilon$. In $\epscalc$, $\varepsilon$ is only allowed to be a concrete set of effects. It has no way to define functions which are parametrised by effect-sets. Developing an extension which can handle polymorphic effects would be a valuable contribution, and improve the stock of $\epscalc$ as a practical and expressive effect system.

\section{Conclusion}

$\epscalc$ is a lambda calculus with a notion of primitive capabilities (resources) and the operations on them. It contains an annotated sublanguage and an $\kwa{import}$ construct which allows developers to nest unannotated code inside annotated code. The typing rule for $\kwa{import}$ is defined according to capability-safe principles, to prohibit the exercise of ambient authority. The result is a sound type-and-effect system which can safely approximate the effects of an unannotated body of code by inspecting what capabilities are passed into it. Section 4 has shown how $\epscalc$ can express practical examples.

There are some limitations to $\epscalc$, such as its limited expressiveness, overapproximation when unannotated code is returning a function, and lack of polymorphic effects. These are all interesting avenues of future work that would enrich $\epscalc$ and our collective understanding of the relation between effects and capabilities.






