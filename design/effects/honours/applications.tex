
\chapter{Applications}

\section{Encodings}

When writing practical examples it is useful to use higher-level constructs which have been derived from the base language. In this section we introduce some of the constructs that we use in examples. Because the core language is sound, any derived extension is also sound.

\subsection{Unit}

$\kwa{Unit}$ is a type inhabited by exactly one value. It conveys the absence of information. In our dynamic rules, $\kwa{unit}$ is what an operation call on a resource literal is reduced to. We define $\kwa{unit} \defn \lambda x: \varnothing. x$ and $\kwa{Unit} \defn \varnothing \rightarrow_{\varnothing} \varnothing$. Note that because there is no empty resource literal, $\kwa{unit}$ cannot be applied to anything. Furthermore, $\vdash \unit : \Unit~\kw{with} \varnothing$, by \textsc{$\varepsilon$-Abs}, so any context can make this type judgement.



\begin{figure}[h]


\fbox{$\Gamma \vdash e: \tau$} \\
\fbox{$\hat \Gamma \vdash \hat e: \hat \tau~\kw{with} \varepsilon$}


\[
\begin{array}{c}

\infer[\textsc{(T-Unit)}]
	{\Gamma \vdash \unit : \Unit}
	{} ~~~~

\infer[(\textsc{$\varepsilon$-Unit})]
	{\hat \Gamma \vdash \unit : \Unit~\kw{with} \varnothing}
	{}

\end{array}
\]

	
\caption{Derived $\kwa{Unit}$ rules.}
\label{This is the label.}
\end{figure}

\subsection{Let}

\noindent
The expression $\letxpr{x}{\hat e_1}{\hat e_2}$ first binds the value $\hat e_1$ to the name $x$ and then evaluates $\hat e_2$. We can generalise by allowing $\hat e_1$ to be a non-value, in which case it must first be reduced to a value. If $\Gamma \vdash \hat e_1: \hat \tau_1$, then $\letxpr{x}{\hat e_1}{\hat e_2} \defn (\lambda x: \hat \tau_1 . \hat e_2) \hat e_1$. Note that if $\hat e_1$ is a non-value, we can reduce the $\kwa{let}$ by \textsc{E-App2}. If $\hat e_1$ is a value, we may apply \textsc{E-App3}, which binds $\hat e_1$ to $x$ in $\hat e_2$. This is fundamentally a lambda application, so it can be typed using \textsc{$\varepsilon$-App} (or \textsc{T-App}, if the terms involved are unlabelled).

\begin{figure}[h]

\fbox{$\Gamma \vdash e: \tau$} \\
\fbox{$\hat \Gamma \vdash \hat e: \hat \tau~\kw{with} \varepsilon$} \\
\fbox{$\hat e \rightarrow \hat e ~|~ \varepsilon$}

\[
\begin{array}{c}

	~~~
	
	\infer[\textsc{($\varepsilon$-Let)}]
	{\Gamma \vdash \letxpr{x}{e_1}{e_2}: \tau_2}
	{\Gamma \vdash e_1: \tau_1 & \Gamma, x: \tau_1 \vdash e_2: \tau_2} \\[4ex]

\infer[\textsc{($\varepsilon$-Let)}]
	{\hat \Gamma \vdash \letxpr{x}{\hat e_1}{\hat e_2} : \hat \tau_2~\kw{with} \varepsilon_1 \cup \varepsilon_2}
	{\hat \Gamma \vdash \hat e_1 : \hat \tau_1~\kw{with} \varepsilon_1 & \hat \Gamma, x: \hat \tau_1 \vdash \hat e_2: \hat \tau_2~\kw{with} \varepsilon_2} \\[4ex]

\infer[\textsc{($\varepsilon$-Let1)}]
	{\letxpr{x}{\hat e_1}{\hat e_2} \longrightarrow \letxpr{x}{\hat e_1'}{\hat e_2}~|~\varepsilon_1}
	{\hat e_1 \longrightarrow \hat e_1'~|~\varepsilon_1} \\[3ex]
	
\infer[\textsc{($\varepsilon$-Let2)}]
	{\letxpr{x}{\hat v}{\hat e} \longrightarrow [\hat v/x]\hat e~|~\varnothing}
	{} 

\end{array}
\]


\caption{Derived $\kwa{let}$ rules.}
\label{This is the label.}
\end{figure}

\subsection{Conditionals}

\subsection{Tuples}

\textbf{We need tuples to import multiple names.}


\section{Examples}




\begin{figure}[h]

\begin{lstlisting}
resource module Logger
require File

def log(): Unit with File.append =
    File.append(``message logged'')
\end{lstlisting}

\begin{lstlisting}
require File
instantiate Logger(File)

def main(): Unit =
    Logger.log()
\end{lstlisting}

\caption{A $\kwa{logger}$ client doesn't need to add effect labels. These can be inferred.}
\label{This is the label.}
\end{figure}



\begin{figure}[h]

\begin{lstlisting}
resource module Logger
require File

def log(): Unit with File.append, File.write =
    File.append(``message logged'')
    File.write(``message written'')
\end{lstlisting}

\begin{lstlisting}
module Client

def action(l: Logger): Unit with File.append =
    l.log()
\end{lstlisting}

\begin{lstlisting}
require File
instantiate Logger(File)

def main(): Unit with File.append =
    Client.action(Logger)
\end{lstlisting}

\caption{This won't type because of a mismatch between the client's effects and the logger's effects.}
\label{This is the label.}
\end{figure}



\textbf{EXAMPLE OF A RESOURCE LEAKING AND BREAKING CONFINEMENT}

\textbf{EXAMPLE OF IMPORTING MULTIPLE CAPABILITIES, ONE GETS LEAKED AND PASSED SOMEWHERE IT HASN'T BEEN SELECTED}
