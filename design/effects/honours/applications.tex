
\chapter{Applications}

In this chapter we show how $\epscalc$ can be used in practice by presenting several examples. This will take the form of writing a program in a high-level, capability-safe language, translating it to an equivalent $\epscalc$ program, and demonstrating how the rules of $\epscalc$ enable reasoning about the use of effects. The language is based on \textit{Wyvern}, a pure, object-oriented, capability-safe language, with first-class modules.

In section 4.1. we discuss how the translation from Wyvern to $\epscalc$ will work, and what simplifying assumptions are made in our examples. This also serves as a gentle introduction to Wyvern's syntax. A variety of scenarios are then explored in section 4.2.

\section{Translations and Encodings}

Our aim is to develop some notation to help us translate Wyvern programs into $\epscalc$. Our approach will be to encode these additional rules and forms into the base language of $\epscalc$; essentially, to give common patterns and forms a short-hand, so they can be easily named and recalled. This is called \textit{sugaring}. When these derived forms are collapsed into their underlying representation, it is called \textit{desugaring}. We are going to introduce several rules to show a Wyvern program might be considered syntactic sugar for an $\epscalc$ program, and translate examples by desugaring according to our rules.

\subsection{Unit}

$\kwa{Unit}$ is a type inhabited by exactly one value. It conveys the absence of information; in $\epscalc$ an operation call on a resource literal reduces to $\unit$ for this reason. We define $\unit \defn \lambda x: \varnothing. x$. The $\unit$ literal is the same in both annotated and naked code. In annotated code, it has the type $\Unit \defn \varnothing \rightarrow_{\varnothing} \varnothing$, while in naked code it has the type $\Unit \defn \varnothing \rightarrow \varnothing$. While these are technically two seperate types, we will not distinguish between the annotated and naked versions, simply referring to them both as $\Unit$.

Note that $\unit$ is a value, and because $\varnothing$ is uninhabited (there is no empty resource literal), $\unit$ cannot be applied to anything. Furthermore, $\vdash \unit: \Unit~\kw{with} \varnothing$ by \textsc{$\varepsilon$-Abs}, and $\vdash \unit: \Unit$ by \textsc{T-Abs}. This leads to the derived rules in \ref{fig:unit_rules}.

\begin{figure}[h]


\fbox{$\Gamma \vdash e: \tau$} \\
\fbox{$\hat \Gamma \vdash \hat e: \hat \tau~\kw{with} \varepsilon$}


\[
\begin{array}{c}

\infer[\textsc{(T-Unit)}]
	{\Gamma \vdash \unit : \Unit}
	{} ~~~~

\infer[(\textsc{$\varepsilon$-Unit})]
	{\hat \Gamma \vdash \unit : \Unit~\kw{with} \varnothing}
	{}

\end{array}
\]

\caption{Derived $\kwa{Unit}$ rules.}
\label{fig:unit_rules}
\end{figure}

Since $\unit$ represents the absence of information, we also use it as the type when a function either takes no argument, or returns nothing. \ref{fig:unit_sugaring} shows the definition of a Wyvern function which takes no argument and returns nothing, and its corresponding representation in $\epscalc$.

\begin{figure}[h]

\begin{lstlisting}
def method():Unit
   unit
\end{lstlisting}

\begin{lstlisting}
$\lambda$x:Unit. unit
\end{lstlisting}

\caption{Desugaring of functions which take no arguments or return nothing.}
\label{fig:unit_sugaring}
\end{figure}

\subsection{Let}

\noindent
The expression $\letxpr{x}{\hat e_1}{\hat e_2}$ first binds the value $\hat e_1$ to the name $x$ and then evaluates $\hat e_2$. We can generalise by allowing $\hat e_1$ to be a non-value, in which case it must first be reduced to a value. If $\Gamma \vdash \hat e_1: \hat \tau_1$, then $\letxpr{x}{\hat e_1}{\hat e_2} \defn (\lambda x: \hat \tau_1 . \hat e_2) \hat e_1$. Note that if $\hat e_1$ is a non-value, we can reduce the $\kwa{let}$ by \textsc{E-App2}. If $\hat e_1$ is a value, we may apply \textsc{E-App3}, which binds $\hat e_1$ to $x$ in $\hat e_2$. This is fundamentally a lambda application, so it can be typed using \textsc{$\varepsilon$-App} (or \textsc{T-App}, if the terms involved are unlabelled). The new rules in \ref{fig:let_rules} capture these derivations.

\begin{figure}[h]

\fbox{$\Gamma \vdash e: \tau$} \\
\fbox{$\hat \Gamma \vdash \hat e: \hat \tau~\kw{with} \varepsilon$} \\
\fbox{$\hat e \rightarrow \hat e ~|~ \varepsilon$}

\[
\begin{array}{c}

	~~~
	
	\infer[\textsc{($\varepsilon$-Let)}]
	{\Gamma \vdash \letxpr{x}{e_1}{e_2}: \tau_2}
	{\Gamma \vdash e_1: \tau_1 & \Gamma, x: \tau_1 \vdash e_2: \tau_2} \\[2ex]

\infer[\textsc{($\varepsilon$-Let)}]
	{\hat \Gamma \vdash \letxpr{x}{\hat e_1}{\hat e_2} : \hat \tau_2~\kw{with} \varepsilon_1 \cup \varepsilon_2}
	{\hat \Gamma \vdash \hat e_1 : \hat \tau_1~\kw{with} \varepsilon_1 & \hat \Gamma, x: \hat \tau_1 \vdash \hat e_2: \hat \tau_2~\kw{with} \varepsilon_2} \\[2ex]
	
\infer[\textsc{(E-Let1)}]
	{\letxpr{x}{\hat e_1}{\hat e_2} \longrightarrow \letxpr{x}{\hat e_1'}{\hat e_2}~|~\varepsilon_1}
	{\hat e_1 \longrightarrow \hat e_1'~|~\varepsilon_1} \\[2ex]
	
\infer[\textsc{(E-Let2)}]
	{\letxpr{x}{\hat v}{\hat e} \longrightarrow [\hat v/x]\hat e~|~\varnothing}
	{} 

\end{array}
\]

\caption{Derived $\kwa{let}$ rules.}
\label{fig:let_rules}
\end{figure}

$\kwa{let}$ expressions can be used to sequence computations. Used in this way, the $\kwa{let}$ expression simply names the results of the intemediate steps and then ignores them in its body. When we ignore the result of a computation we shall bind it to $\_$ instead of a real name, to suggest the result isn't important and prevent the naming of unused variables.

\subsection{Modules and Objects}

Wyvern's modules are first-class and desugar into objects; invoking a method inside a module is no different from invoking an object's method. There are two kinds of modules: pure and resourceful. For our purposes, a pure module is one with no (transitive) authority over any resources, while a resource module has (transitive) authority over some resource. A pure module may still be given a capability, for example by requesting it in a function signature, but it may not possess or capture the capability for longer than the duration of the method call. \ref{fig:wyv_modules} shows an example of two modules, one pure and one resourceful, each declared in a seperate file. Note how pure modules are declared with the $\kwa{module}$ keyword, while resource modules are declared with the $\kwa{resource~module}$ keywords.

\begin{figure}[h]

\begin{lstlisting}
module PureMod

def tick(f: {File}):Unit
   f.append

\end{lstlisting}

\begin{lstlisting}
resource module ResourceMod
require File

def tick():Unit with {File.append}
   File.append
\end{lstlisting}

\caption{Definition of two modules, one pure and the other resourceful.}
\label{fig:wyv_modules}
\end{figure}

Wyvern is capability-safe, so resource modules must be instantiated with the capabilities they require. In \ref{fig:wyv_modules}, $\kwa{ResourceMod}$ requests the use of a $\kwa{File}$ capability, which must be supplied to it from someone already possessing it. Modules are behaving like objects in this way, because they require explicit instantiation. \ref{fig:wyv_module_instantiation} demonstrates how the two modules above would be instantiated and used.

To prevent infinite regress the $\kwa{File}$ must, at some point, be introduced into the program. This happens in a special main module. When the program begins execution, the $\kwa{File}$ capability is passed into the program from the system environment. All these initial capabilities are modelled in $\epscalc$ as resource literals. They are then propagated by the top-level entry point.

\begin{figure}[h]

\begin{lstlisting}
require File
instantiate PureMod
instantiate ResourceMod(File)

def main():Unit
   PureMod.tick(File)
   ResourceMod.tick()
\end{lstlisting}

\caption{Definition of two modules, one pure and the other resourceful.}
\label{fig:wyv_module_instantiation}
\end{figure}

Before explaining our translation of Wyvern programs into $\epscalc$, we must explain several simplifications made in all of our examples which enable our particular desugaring.

Objects are only ever used in the form of modules. Modules only ever contain functions and other modules, and have no mutable fields. The examples contain no recursion or self-reference, including a module invoking its own functions. Modules will not reference each other cyclically. Lastly, modules only contain one function definition. Despite these simplifications, the chosen examples will highlight the essential aspects of $\epscalc$.

Because modules do not exercise self-reference and only contain one function definition, they will be modelled as functions in $\epscalc$. Applying this function will be equivalent to applying the single function definition in the module.

A collection of modules is desugared into $\epscalc$ as follows. First, a sequence of let-bindings are used to name constructor functions which, when given the capabilities requested by a module, will return an instance of the module. If the module does not require any capabilities then it will take $\Unit$ as its argument. The constructor function for $\kwa{M}$ is called $\kwa{MakeM}$. A function is then defined which represents the $\kwa{main}$ function, which is the entry point into the program. This $\kwa{main}$ function will instantiate all the modules by invoking the constructor functions, and then execute the body of code in main. Finally, the main function is invoked with the primitive capabilities it needs.

To demonstrate this process, \ref{fig:wyv_tutorial_desugaring} shows how the examples above desugar. Lines 1-3 define the constructor for $\kwa{PureMod}$; since $\kwa{PureMod}$ requires no capabilities, the constructor takes $\Unit$ as an argument on line 2. Lines 6-8 define the constructor for $\kwa{ResourceMod}$; it requires a $\kwa{File}$ capability, so the constructor takes $\kwa{\{File\}}$ as its input type on line 7. The entry point to the program is defiend on lines 11-15, which invokes the constructors and then runs the body of the $\kwa{main}$ method. Lastly, line 17 starts everything off by invoking $\kwa{Main}$ with the initial set of capabilities, which in this case is just $\kwa{File}$.

\begin{figure}[h]

\begin{lstlisting}
let MakePureMod =
   $\lambda$x:Unit.
      $\lambda$f:{File}. f.append
in

let MakeResourceMod =
   $\lambda$f:{File}.
      $\lambda$x:Unit. f.append
in

let MakeMain =
   $\lambda$f:{File}.
      $\lambda$x: Unit.
         let PureMod = (MakePureMod unit) in
         let ResourceMod = (MakeResourceMod f) in
         let _ = (PureMod f) in (ResourceMod unit) in

(MakeMain File) unit
\end{lstlisting}

\caption{Desugaring of $\kwa{PureMod}$ and $\kwa{ResourceMod}$ into $\epscalc$.}
\label{fig:wyv_tutorial_desugaring}
\end{figure}

Unannotated modules are modelled with $\kwa{import}$, where the unannotated body of the module is the unannotated body of the $\kwa{import}$. Most examples involving unannotated code will not typecheck because of a mismatch between the selected authority of $\kwa{import}$ and the annotations on the client using unannotated code. Where an example involves unannotated code, the selected authority will be determined by what constraints are imposed by the client. For example, if the client only expects the $\kwa{File.append}$ effect and executes some unlabelled code, the corresponding $\kwa{import}$ expression will select $\kwa{File.append}$.

\section{Examples}

We now present several examples to show how the capability-based reasoning of $\epscalc$ can assist in reasoning about the effects of a program. We also hope to convince the reader that the rules of $\epscalc$ have practical worth, and could be used to enrich existing capability-safe languages in a straightforward and routine manner.

The format of each section is as follows. A program is introduced which exhibits some bad behaviour or demonstrates a particular story about software development. The language used is \textit{Wyvern}; a pure, object-oriented, capability-safe language with first-class modules-as-objects. We show how the Wyvern program can be written as a corresponding $\epscalc$ program and sketch a derivation showing how the rules of $\epscalc$ and a sketch a derivation showing how the rules of $\epscalc$ would solve the relevant problem.

We take some shortcuts with the translation of Wyvern into $\epscalc$. Our ``objects'' are really functions. The particular examples we have chosen only involve modules which export a single function and make no use of self-reference, so no important expressive properties are lost by treating Wyvern objects as functions.


\subsection{API Violation}

In the first example there is a single primitive capability called $\kwa{File}$, which is passed into the program when it begins execution, perhaps from the system environment or a virtual machine. There is a $\kwa{Logger}$ module which possess this capability and exposes a single function $\kwa{log}$ which incurs $\kwa{File.write}$ when executed. The $\kwa{Client}$ module possesses the $\kwa{Logger}$ module as a capability. Its function $\kwa{run}$ will invoke $\kwa{Logger.log}$, incurring both $\kwa{File.write}$; however, the client's annotation is expecting no effects $\varnothing$. Code is shown below.

\begin{lstlisting}
resource module Logger
require File

def log(): Unit with {File.write} =
    File.write(``message written'')
\end{lstlisting}

\begin{lstlisting}
module Client

def run(l: Logger): Unit with $\varnothing$ =
    l.log()
\end{lstlisting}

\begin{lstlisting}
resource module Main
require File
instantiate Logger(File)

Client.run(Logger)
\end{lstlisting}

In this example, all code is fully annotated. A desugared version is given below. Lines 1-3 define the function which instantiates the $\kwa{Logger}$ module. Lines 5-7 define the function which instantiates the $\kwa{Client}$ module. Note how the client code takes as input a function of type $\Unit \rightarrow_{\varnothing} \Unit$. Lines 9-14 define the implicit $\kwa{Main}$ module, which, when given a $\kwa{File}$, will instantiate the other modules and execute the client code. The program begins execution on line 16, where initial capabilities (here just $\kwa{File}$) and arguments are passed to $\kwa{Main}$.

\begin{lstlisting}
let MakeLogger =
   ($\lambda$f: File.
      $\lambda$x: Unit. let _ = f.append in f.write) in
           
let MakeClient =
   ($\lambda$x: Unit.
      $\lambda$logger: Unit $\rightarrow_{\varnothing}$ Unit. logger unit) in
                  
let MakeMain =
   ($\lambda$f: File.
      $\lambda$x: Unit.
         let LoggerModule = MakeLogger f in
         let ClientModule = MakeClient unit in
         ClientModule LoggerModule) in

(MakeMain File) unit
\end{lstlisting}

At line 12, when typing $\kwa{LoggerModule}$, an application of \textsc{$\varepsilon$-App} gives the judgement $\kwa{ f: \{ File \} \vdash LoggerModule: Unit \rightarrow_{\kwa{File.write}} Unit~\kw{with} \varnothing}$. At line 13 the same rule gives $\kwa{ f: \{ File \} \vdash ClientModule: (Unit \rightarrow_{\varnothing} Unit) \rightarrow Unit~\kw{with} \varnothing}$. Now at line 14, when attempting to apply \textsc{$\varepsilon$-App}, there is a type mismatch because the formal argument of $\kwa{ClientModule}$ expects a function with no effects, but $\kwa{LoggerModule}$ has typed as incurring $\kwa{File.write}$, so this example safely rejects.









































\subsection{Unannotated Client}

This example is a modification of the previous one. Now the $\kwa{Client}$ is unannotated. If the client code is executed, what effects will it have? The answer is not immediately by inspecting the client's source-code, because it depends on what effects are incurred by $\kwa{Logger.log}$. A capability-based argument goes as follows: because the client code can typecheck needing only $\kwa{Logger}$, then the effects presented by $\kwa{Logger}$ are an upper-bound on the effects of the client.

The code for this example is given below.

\begin{lstlisting}
resource module Logger
require File

def log(): Unit with File.append =
    File.append(``message logged'')
\end{lstlisting}

\begin{lstlisting}
module Client
require Logger

def run(): Unit =
   Logger.log()
\end{lstlisting}

\begin{lstlisting}
resource module Main
require File
instantiate Logger(File)
instantiate Client(Logger)

Client.run()
\end{lstlisting}

The desugared version is given below. It first creates two functions, $\kwa{MakeLogger}$ and $\kwa{MakeClient}$, which instantiate the $\kwa{Logger}$ and $\kwa{Client}$ modules; the client code is treated as an implicit module. Lines 1-4 define a function which, given a $\kwa{File}$, returns a record containing a single $\kwa{log}$ function. Lines 6-8 define a function which, given a $\kwa{Logger}$, returns the unannotated client code, wrapped inside an $\kwa{import}$ expression selecting its needed authority. Lines 10-14 define $\kwa{MakeMain}$ which returns the implicit main module that, when executed, instantiates all the other modules in the program and invokes the code in $\kwa{Main}$. Program execution begins on line $16$, where $\kwa{Main}$ is given the initial capabilities --- which, in this case, is just $\kwa{File}$.

\begin{lstlisting}
let MakeLogger =
   ($\lambda$f: File.
      $\lambda$x: Unit. f.append) in
          
let MakeClient =
   ($\lambda$logger: Logger.
      import(File.append) logger = logger in
         $\lambda$x: Unit. logger unit) in
          
let MakeMain =
   ($\lambda$f: File.
      $\lambda$x: Unit.
         let LoggerModule = MakeLogger f in
         let ClientModule = MakeClient LoggerModule in
         ClientModule unit) in

(MakeMain File) unit
\end{lstlisting}

The interesting part  is on lines 7-8, where the unannotated code selects $\kwa{File.append}$ as its authority. This is exactly the effects of the logger, i.e. $\kwa{effects}(\Unit \rightarrow_{\kwa{File.append}} \Unit) = \{ \kwa{File.append} \}$. The code also satisfies the higher-order safety predicates, and the body of the $\kwa{import}$ expression typechecks in the empty context. Therefore, the unannotated code typechecks by \textsc{$\varepsilon$-Import}.

In such a small example the client could simply inspect the source code of $\kwa{Logger}$ to determine what effects it might have. Several situations can make this impossible or tedious. First, the manual approach loses efficiency when the system involves many modules of large size across code-ownership boundaries; capability-based reasoning tells you automatically. Second, the source code of $\kwa{Logger}$ might be obfuscated or unavailable, and the only useful information is that given by its signature. Lastly, the client may not care about effects in this situation; the program may be a quick-and-dirty throwaway, in which case it is nice that the capability-based reasoning still accepts the client code without annotations.











































\subsection{Unannotated Library}

The next example inverts the roles of the last scenario: now, the annotated $\kwa{Client}$ wants to use the unannotated $\kwa{Logger}$. The $\kwa{Logger}$ module captures the $\kwa{File}$ capability, and exposes a single function $\kwa{log}$ with the $\kwa{File.append}$ effect. However, the $\kwa{Client}$ has a function $\kwa{run}$ which executes $\kwa{Logger.log}$, incurring the effect of $\kwa{File.append}$, but declares its set of effects as $\varnothing$, so the implementation and signature of $\kwa{Client.run}$ are inconsistent.

\begin{lstlisting}
resource module Logger
require File

def log(): Unit =
    File.append(``message logged'')
\end{lstlisting}

\begin{lstlisting}
resource module Client
require Logger

def run(): Unit with $\varnothing$ =
   Logger.log()
\end{lstlisting}

\begin{lstlisting}
resource module Main
require File
instantiate Logger(File)
instantiate Client(Logger)

Client.run()
\end{lstlisting}

A desugaring is given below. Lines 1-3 define the function which instantiates the $\kwa{Logger}$ module. Lines 5-8 define the function which instantiates the $\kwa{Client}$ module. Lines 10-15 define the function which instantiates the $\kwa{Main}$ module. Line 17 initiates the program, supplying $\kwa{File}$ to the $\kwa{Main}$ module and invoking its main method. On lines 3-4, the unannotated code is modelled using an $\kwa{import}$ expression which selects $\varnothing$ as its authority. So far this coheres to the expectations of $\kwa{Client}$. However, \textsc{$\varepsilon$-Import} cannot be applied because the name being bound, $\kwa{f}$, has the type $\{ \File \}$, and $\fx{\{ \File \}} = \{ \kwa{File}.* \}$, which is inconsistent with the declared effects $\varnothing$.

\begin{lstlisting}
let MakeLogger =
   ($\lambda$f: File.
      import($\varnothing$) f = f in
         $\lambda$x: Unit. f.append) in

let MakeClient =
	($\lambda$logger: Logger.
	   $\lambda$x: Unit. logger unit) in

let MakeMain =
   ($\lambda$f: File.
      let LoggerModule = MakeLogger f in
      let ClientModule = MakeClient LoggerModule in
      ClientModule unit) in

(MakeMain File) unit
\end{lstlisting}

The only way for this to typecheck would be to annotate $\kwa{Client.run}$ as having every effect on $\File$. This demonstrates how the effect-system of $\epscalc$ approximates unlabelled code: it simply considers it as having every effect which could be incurred on those resources in scope, which here is $\kwa{File}.*$.



































\subsection{Unannotated Library 2}

In yet another variation of the previous examples, the $\kwa{Logger}$ module is now passed the $\kwa{File}$ as an argument, rather than possessing it. $\kwa{Logger.log}$ still incurs $\kwa{File.append}$ inside the unannotated code, which causes the implementation of $\kwa{Client.run}$ to violate its signature. Because $\kwa{Logger}$ has no dependencies, it is now directly instantiated by $\kwa{Client}$.

\begin{lstlisting}
module Logger

def log(f: {File}): Unit
    f.append(``message logged'')
\end{lstlisting}

\begin{lstlisting}
module Client
instantiate Logger(File)

def run(f: {File}): Unit with $\varnothing$
   Logger.log(File)
   
\end{lstlisting}

\begin{lstlisting}
resource module Main
require File
instantiate Client

Client.run(File)
\end{lstlisting}

The desugaring, given below, is slightly different in form from the previous examples because $\kwa{Logger}$ is instantiated by $\kwa{Client}$. The $\kwa{MakeLogger}$ function is defined on lines 2-6, and invoked on line 7. $\kwa{MakeClient}$ then returns a function which, when given a $\kwa{File}$, invokes the function in the $\kwa{Logger}$ module (this is $\kwa{Client.run}$). $\kwa{Main}$ now only instantiates $\kwa{ClientModule}$ on line 13 and then invokes its function on line 14, passing $\kwa{File}$ as an argument.

The $\kwa{Logger}$ module is a function $\kwa{\lambda f: {File}. f.append}$, but encapsulated within an $\kwa{import}$ expression selecting its authority as $\varnothing$ on line 5, to be consistent with the annotation on $\kwa{Client.run}$. Nothing is being imported, which is represented by the import $\kwa{y = unit}$. However, \textsc{$\varepsilon$-Import} will not accept the unannotated code in $\kwa{Logger}$, because it violates the premise $\varepsilon = \fx{\hat \tau} \cup \hofx{\annot{\tau}{\varepsilon}}$. In this case, $\varepsilon = \varnothing$, but $\tau = \kwa{ \{ File \} \rightarrow Unit}$ and $\hofx{\annot{\tau}{\varnothing}} = \{ \kwa{File.*} \}$. The example safely rejects.

\begin{lstlisting}
let MakeClient =
	($\lambda$x: Unit.
	   let MakeLogger =
	      ($\lambda$x: Unit.
	         import({File.*}) y=unit in
	            $\lambda$f: {File}. f.append) in
      let LoggerModule = MakeLogger unit in
      $\lambda$f: {File}. LoggerModule f) in

let MakeMain =
   ($\lambda$f: {File}.
      $\lambda$x: Unit.
         let ClientModule = MakeClient unit in
         ClientModule f) in

(MakeMain File) unit
\end{lstlisting}

To make this example typecheck would require us to change the annotation on $\kwa{Client.run}$ to be $\kwa{ \{ File.* \}}$; then \textsc{$\varepsilon$-Import} would type the code as $\kwa{ \{ File \} \rightarrow_{\kwa{File.*}}  \Unit ~\kw{with} \{ File.* \}}$. Note how the unannotated code, and the function it returns, are both said to incur $\{ \kwa{File.*} \}$ when invoked. This is true of the function, since it can do anything with the $\File$ it is given, but for the unannotated code this is a vast overapproximation. In fact, since the unannotated code is not directly exercising any authority, it is not able to directly incur any effect. If the function it returns is never used, then the program might not incur any effects on $\File$. This highlights a drawback in the type system: its approximations may include effects which cannot happen.































\subsection{Higher-Order Effects}

In this scenario, $\kwa{Main}$ instantiates the $\kwa{Plugin}$ module, which itself instantiates the $\kwa{Malicious}$ module. $\kwa{Plugin}$ exposes a single function $\kwa{run}$, should incur no effects. However, the implementation tries to read from $\kwa{File}$ by wrapping the operation inside a function and passing it to $\kwa{Malicious}$, where $\kwa{File.read}$ incurs in a higher-order manner.

\begin{lstlisting}
module Malicious

def log(f: Unit $\rightarrow$ Unit):Unit
   f()
\end{lstlisting}

\begin{lstlisting}
module Plugin
instantiate Malicious

def run(f: {File}): Unit with $\varnothing$
   Malicious.log($\lambda$x:Unit. f.read)
\end{lstlisting}

\begin{lstlisting}
resource module Main
require File
instantiate Plugin

Plugin.run(File)
\end{lstlisting}

This examples shows how higher-order effects can obfuscate potential security risks. On line 3 of $\kwa{Malicious}$, the argument to $\kwa{log}$ has type $\Unit \rightarrow \Unit$. This will only typecheck using the \textsc{T-}rules from the unannotated fragment of $\epscalc$; no approximation is made inside $\kwa{Malicious}$. The type $\Unit \rightarrow \Unit$ says nothing about the effects which might incur from executing this function. It is not clear from inspecting the unannotated code that it is doing something malicious. To realise this requires one to examine both $\kwa{Plugin}$ and $\kwa{Malicious}$.

A desugared version is given below. On lines 5-6, the $\kwa{Malicious}$ code selects its authority as $\varnothing$, to be consistent with the annotation on $\kwa{Plugin.run}$. For the same reasons as in the previous section, this example is rejected by \textsc{$\varepsilon$-Import}, because the higher-order effects of $\kwa{\lambda f: \{ File \}.~LoggerModule~f}$ are $\kwa{File.*}$, which is not contained in the selected authority.

\begin{lstlisting}
let MakePlugin =
	($\lambda$x: Unit.
	   let MakeMalicious =
	      ($\lambda$x: Unit.
	         import($\varnothing$) y=unit in
	            $\lambda$f: {File}. f.append) in
      let LoggerModule = MakeLogger unit in
      $\lambda$f: {File}. LoggerModule f) in

let MakeMain =
   ($\lambda$f: {File}.
      $\lambda$x: Unit.
         let ClientModule = MakeClient unit in
         ClientModule f) in

(MakeMain File) unit
\end{lstlisting}

To get this example to typecheck, the $\kwa{import}$ expression would have to select $\kwa{File.*}$ as its authority. The unannotated code would then typecheck as $\kwa{ \{ File \} \rightarrow_{\kwa{File.*}} Unit }$, and any application of it would be said to incur $\kwa{ File.* }$ by \textsc{$\varepsilon$-App}.





























\subsection{Resource Leak}

This is another example of trying to obfuscate an unsafe effect by invoking it in a higher-order manner. The setup is the same, except the function which $\kwa{Plugin}$ passes to $\kwa{Malicious}$ now returns $\kwa{File}$ when invoked. $\kwa{Malicious}$ then incurs $\kwa{File.read}$ by invoking its argument to get $\File$, and then directly calling $\kwa{read}$ on it.

\begin{lstlisting}
module Malicious

def log(f: Unit $\rightarrow$ File):Unit
   f().read
\end{lstlisting}

\begin{lstlisting}
module Plugin
instantiate Malicious

def run(f: {File}): Unit with $\varnothing$
   Malicious.log($\lambda$x:Unit. f)
\end{lstlisting}

\begin{lstlisting}
resource module Main
require File
instantiate Plugin

Plugin.run(File)
\end{lstlisting}

The desugaring is given below. The unannotated code in $\kwa{Malicious}$ is given on lines 5-6. The selected authority is $\varnothing$, to be consistent with the annotation on $\kwa{Plugin}$. Nothing is being imported, so the $\kwa{import}$ binds a name $\kwa{y}$ to $\unit$. This example is rejected by \textsc{$\varepsilon$-Import} because the premise $\varepsilon = \fx{\hat \tau} \cup \hofx{\annot{\tau}{\varepsilon}}$ is not satisfied. In this case, $\varepsilon = \varnothing$ and $\tau = \kwa{ (Unit \rightarrow \{ File \}) \rightarrow Unit }$. Then $\annot{\tau}{\varepsilon} = \kwa{ (Unit \rightarrow_{\varnothing} \{ File \}) \rightarrow_{\varnothing} Unit }$ and $\hofx{\annot{\tau}{\varepsilon}} = \{ \kwa{File.*} \}$. Thus, the premise cannot be satisfied and the example safely rejects.


\begin{lstlisting}
let MakePlugin =
	($\lambda$x: Unit.
	   let MakeMalicious =
	      ($\lambda$x: Unit.
	         import($\varnothing$) y=unit in
	            $\lambda$f: Unit $\rightarrow$ {File}. f().read) in
      let LoggerModule = MakeLogger unit in
      $\lambda$f: {File}. LoggerModule f) in

let MakeMain =
   ($\lambda$f: {File}.
      $\lambda$x: Unit.
         let ClientModule = MakeClient unit in
         ClientModule f) in

(MakeMain File) unit
\end{lstlisting}









