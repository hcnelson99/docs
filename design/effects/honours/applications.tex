
\chapter{Applications}

\section{Encodings}

When writing practical examples it is useful to use higher-level constructs which have been derived from the base language. In this section we introduce some of the constructs that we use in examples. Because the core language is sound, any derived extension is also sound.

\subsection{Unit}

$\kwa{Unit}$ is a type inhabited by exactly one value. It conveys the absence of information. In our dynamic rules, $\kwa{unit}$ is what an operation call on a resource literal is reduced to. We define $\kwa{unit} \defn \lambda x: \varnothing. x$ and $\kwa{Unit} \defn \varnothing \rightarrow_{\varnothing} \varnothing$. Note that because there is no empty resource literal, $\kwa{unit}$ cannot be applied to anything. Furthermore, $\vdash \unit : \Unit~\kw{with} \varnothing$, by \textsc{$\varepsilon$-Abs}, so any context can make this type judgement.



\begin{figure}[h]


\fbox{$\Gamma \vdash e: \tau$} \\
\fbox{$\hat \Gamma \vdash \hat e: \hat \tau~\kw{with} \varepsilon$}


\[
\begin{array}{c}

\infer[\textsc{(T-Unit)}]
	{\Gamma \vdash \unit : \Unit}
	{} ~~~~

\infer[(\textsc{$\varepsilon$-Unit})]
	{\hat \Gamma \vdash \unit : \Unit~\kw{with} \varnothing}
	{}

\end{array}
\]

	
\caption{Derived $\kwa{Unit}$ rules.}
\label{This is the label.}
\end{figure}

\subsection{Let}

\noindent
The expression $\letxpr{x}{\hat e_1}{\hat e_2}$ first binds the value $\hat e_1$ to the name $x$ and then evaluates $\hat e_2$. We can generalise by allowing $\hat e_1$ to be a non-value, in which case it must first be reduced to a value. If $\Gamma \vdash \hat e_1: \hat \tau_1$, then $\letxpr{x}{\hat e_1}{\hat e_2} \defn (\lambda x: \hat \tau_1 . \hat e_2) \hat e_1$. Note that if $\hat e_1$ is a non-value, we can reduce the $\kwa{let}$ by \textsc{E-App2}. If $\hat e_1$ is a value, we may apply \textsc{E-App3}, which binds $\hat e_1$ to $x$ in $\hat e_2$. This is fundamentally a lambda application, so it can be typed using \textsc{$\varepsilon$-App} (or \textsc{T-App}, if the terms involved are unlabelled).

\begin{figure}[h]

\fbox{$\Gamma \vdash e: \tau$} \\
\fbox{$\hat \Gamma \vdash \hat e: \hat \tau~\kw{with} \varepsilon$} \\
\fbox{$\hat e \rightarrow \hat e ~|~ \varepsilon$}

\[
\begin{array}{c}

	~~~
	
	\infer[\textsc{($\varepsilon$-Let)}]
	{\Gamma \vdash \letxpr{x}{e_1}{e_2}: \tau_2}
	{\Gamma \vdash e_1: \tau_1 & \Gamma, x: \tau_1 \vdash e_2: \tau_2} \\[4ex]

\infer[\textsc{($\varepsilon$-Let)}]
	{\hat \Gamma \vdash \letxpr{x}{\hat e_1}{\hat e_2} : \hat \tau_2~\kw{with} \varepsilon_1 \cup \varepsilon_2}
	{\hat \Gamma \vdash \hat e_1 : \hat \tau_1~\kw{with} \varepsilon_1 & \hat \Gamma, x: \hat \tau_1 \vdash \hat e_2: \hat \tau_2~\kw{with} \varepsilon_2} \\[4ex]

\infer[\textsc{($\varepsilon$-Let1)}]
	{\letxpr{x}{\hat e_1}{\hat e_2} \longrightarrow \letxpr{x}{\hat e_1'}{\hat e_2}~|~\varepsilon_1}
	{\hat e_1 \longrightarrow \hat e_1'~|~\varepsilon_1} \\[3ex]
	
\infer[\textsc{($\varepsilon$-Let2)}]
	{\letxpr{x}{\hat v}{\hat e} \longrightarrow [\hat v/x]\hat e~|~\varnothing}
	{} 

\end{array}
\]


\caption{Derived $\kwa{let}$ rules.}
\label{This is the label.}
\end{figure}

\subsection{Conditionals}

\subsection{Tuples}

\textbf{We need tuples to import multiple names.}

