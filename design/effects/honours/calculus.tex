\chapter{Effect Calculi}

In this section we give examples to motivate the practical benefits of an effect system. We then describe a pair of languages: $\opercalc$ and $\epscalc$. In $\opercalc$, every function's input type is labelled by the effects that can be incurred by values of that type. This enables reasoning about the effects that might be incurred by a piece of code.

We then explore what happens when we drop the requirement that every part of a program be labelled with its effects. This leads to the description of $\epscalc$, where labelled and unlabelled code can interact via an $\kwa{import}$ construct. $\kwa{import}$ enables a programmer to nest unlabelled code inside labelled code. The primary result of this chapter is that capability-safety enables a simple, effect-safe inference about the unlabelled code in an $\kwa{import}$ expression.

\section{Examples}

\textbf{Be motivational here, explaining the need for effect-based reasoning using examples from Chapter 4}

\section{$\opercalc$: Operation Calculus}

The operation calculus $\opercalc$ is an extension of $\stlc$ with primitive capabilities (resources), on which operations may be invoked. An effect is an operation invoked on a resource. Every function-type is annotated by what effects may be incurred during execution of the function body. The static rules of $\opercalc$ can inspect this information and ascribe a set of effects to a piece of code, which conservatively approximates what will happen at runtime.

The results of this chapter are straightforward and unsurprising, but $\opercalc$ contains new notations and a new concept of effect-soundness, and forms the basis of the more interesting $\epscalc$, which we discuss in the next chapter.

\subsection{$\opercalc$ Grammar}

The grammar for $\opercalc$ and its meta-theory are summarised in Figure 3.1. Expressions are the same as they are in $\stlc$, except for two new forms: resource literals and operation-calls.

A resource literal $r$ is a variable drawn from a fixed set $R$. They cannot be created or destroyed at runtime. The resources in $R$ model those initial capabilities passed into the program, perhaps from the system environment. For example, a $\kwa{File}$ or a $\kwa{Socket}$ would be an example of a resource literal.

An operation is a special action that be invoked on a resource. For example, we might invoke the $\kwa{open}$ operation on a $\kwa{File}$ resource. Operations are drawn from a fixed set $\Pi$ of variables; like resources, they cannot be created or destroyed at runtime.

An effect is an operation performed on a resource. Formally, they are members of $R \times \Pi$, but for readability we write $\kwa{File.open}$ instead of $\kwa{(File, open)}$. A set of effects is denoted by $\varepsilon$. Effects and operations look notationally similar, but should be distinguished: an effect is some description of runtime behaviour in the meta-theory of $\opercalc$; an operation-call is an expression inside an $\opercalc$ which actually invokes that runtime behaviour.

Realistically, operations should take arguments. For example, when writing to a file, we want to specify \textit{what} is being written to the file, e.g. $\kwa{File.write(``mymsg'')}$. However, we shall see the rules of $\opercalc$ are about tracking potential resource-use in a system, and so the exaxct behaviour of a particular operation call is of little interset. For this reason we make the simplifying assumption that all operations are null-ary: $\kwa{File.write}$ instead of $\kwa{File.write(``mymsg'')}$.

The base types of $\opercalc$ are sets of resources, denoted by $\{ \bar r \}$. If an expression $e$ is given type $\{ \bar r \}$, then evaluating $e$ will reduce to one of the resource literals in $\bar r$ (if $e$ terminates).

The only type constructor is $\rightarrow_{\varepsilon}$, where $\varepsilon$ is a concrete set of effects. $\tau_1 \rightarrow_{\varepsilon} \tau_2$ is the type of a function which takes inputs of type $\tau_1$, produces outputs of type $\tau_2$, and incurs no more effects than those contained in $\varepsilon$. For example, the type of a function which sends a message over a socket and returns a success flag could be $\kwa{Str} \rightarrow_{\kwa{Socket.write}} \Bool$. From this signature we can tell this function will not open or close the socket, because the annotation on the arrow does not have those effects. A valid implementation of this function might not write to the $\kwa{Socket}$, because $\{ \kwa{Socket.write} \}$ is an upper-bound on the effects which can happen. Because functions can only be typed with this annotated arrow-type, and because the only way to incur an effect at the top-level is to be supplied a capability for it, we say every function in $\opercalc$ is ``annotated'' by what effects they can incur.

\begin{figure}[h]
\vspace{-5pt}

\[
\begin{array}{lll}

\begin{array}{lllr}

e & ::= & ~ & exprs: \\
	& | & x & variable \\
	& | & v & value \\
	& | & e ~ e & application \\
	& | & e.\pi & operation \\
	&&\\

v & ::= & ~ & values: \\
	& | & r & resource~literal \\
	& | & \lambda x: \tau.e & abstraction \\
	&&\\

\end{array}

& ~~~~~~~~&

\begin{array}{lllr}

\varepsilon & ::= & ~ & effects: \\
	& | & \{ \overline{r.\pi} \} \\
	&&\\

\tau & ::= & ~ & types: \\
		& | & \{ \bar r \} \\
		& | & \tau \rightarrow_{\varepsilon} \tau \\ 
		&&\\

\Gamma & ::= & ~ & type~ctx: \\
				& | & \varnothing \\
				& | & \Gamma, x: \tau \\
				&&\\
\end{array}

\end{array}
\]

\vspace{-7pt}
\caption{Grammar for $\opercalc$.}
\label{This is the label.}
\end{figure}


 
 
\subsection{$\opercalc$ Dynamic Rules}

Before giving dynamic rules, Figure 3.2. first shows the updated definition of $\kwa{substitution}$. It is straight-forward, but in $\opercalc$ we make the restriction that a variable may only be substituted for a value. This restriction is imposed because if a variable can be replaced with an arbitrary expression, then we might also be introducing arbitrary effects --- a situation which violates the preservation of effects under reduction. Because our dynamic rules will employ a call-by-value this tightening of $\kwa{substitution}$ is no problem.
 \\


\begin{figure}[h]

\bm{$\kwa{substitution :: e \times v \times v \rightarrow e}$}

\begin{itemize}
	\setlength\itemsep{-0.7em}
	\item[] $[v/y]x = v$, if $x = y$
	\item[] $[v/y]x = x$, if $x \neq y$
	\item[] $[v/y](\lambda x: \tau. e) = \lambda x: \tau.[v/y]e$, if $y \neq x$ and $y$ does not occur free in $e$
	\item[] $[v/y](e_1~e_2) = ([v/y]e_1)([v/y]e_2)$
	\item[] $[v/y](e_1.\pi) = ([v/y]e_1).\pi$
\end{itemize}

\vspace{-7pt}
\caption{Substitution function in $\opercalc$.}
\label{This is the label.}
\end{figure}

Rules for single-step reductions are given in Figure 3.3. Single-step reduction now takes the form $e \longrightarrow e~|~\varepsilon$, with the resulting pair being the expression after reduction, and the set of effects incurred during the single-step of computation (which in the case of single-step reduction is at most a singleton).

\textsc{E-App1} and \textsc{E-App2} incur whatever is the effect of reducing their subexpressions. \textsc{E-App3} incurs no effects when it performs substitution (and proving the safety of this reduction depends on our narrowed definition of $\kwa{substitution}$).

The new single-step rules are \textsc{E-OperCall1} and \textsc{E-OperCall2}. The former reduces the receiver of an operation-call, and the latter performs an operation on a resource literal. \textsc{E-OperCall1} incurs whatever is the effect of reducing the subexpression. \textsc{E-OperCall2}, which reduces the operation-call $r.\pi$, incurs the effect $r.\pi$.

Operation calls reduce to $\unit$ (which is a derived form; see Encodings). An important property is that $\unit$ is the only value of its type (which is called $\Unit$). Because of this, it is used to signify the absence of information. As we have chosen not to model the semantics of operation-calls, we choose $\unit$ as a sensible result of reducing an operation-call. \\

\begin{figure}[h]

\noindent
\fbox{$e \longrightarrow e~|~\varepsilon$}

\[
\begin{array}{c}

\infer[\textsc{(E-App1)}]
	{e_1 e_2 \longrightarrow e_1'~ e_2~|~\varepsilon}
	{e_1 \longrightarrow e_1'~|~\varepsilon}
	~~~~~~
\infer[\textsc{(E-App2)}]
	{v_1 ~ e_2 \longrightarrow v_1 ~ e_2'~|~\varepsilon} 
	{e_2 \longrightarrow e_2'~|~\varepsilon}
~~~~~~
\infer[\textsc{(E-App3)}]
	{ (\lambda x: \tau. e) v_2 \longrightarrow [ v_2/x] e~|~\varnothing }
	{}\\[4ex]
	
\infer[\textsc{(E-OperCall1)}]
	{ e.\pi \longrightarrow  e'.\pi~|~\varepsilon }
	{ e \rightarrow  e'~|~\varepsilon}
		
	~~~~~~
	
\infer[\textsc{(E-OperCall2)}]
	{r.\pi \longrightarrow \kwa{unit}~|~\{ r.\pi \} }
	{r \in R & \pi \in \Pi}
	 \\[4ex]
	 
\end{array}
\]


\vspace{-7pt}
\caption{Single-step reductions in $\opercalc$.}
\label{This is the label.}
\end{figure}



A multi-step reduction consists of zero or more single-step reductions. The resulting effect-set is the union of the effect-sets produced by all the intermediate single-steps. Rules are given in Figure 3.4.

\begin{figure}[h]

\noindent
\fbox{$ e \longrightarrow^{*}  e~|~\varepsilon$}

\[
\begin{array}{c}

\infer[\textsc{(E-MultiStep1)}]
	{ e \rightarrow^{*}  e~|~\varnothing}
	{}
~~~
\infer[\textsc{(E-MultiStep2)}]
	{ e \rightarrow^{*}  e'~|~\varepsilon}
	{ e \rightarrow  e'~|~\varepsilon} \\[3ex]
	
\infer[\textsc{(E-MultiStep3)}]
	{ e \rightarrow^{*}  e''~|~\varepsilon_1 \cup \varepsilon_2}
	{ e \rightarrow^{*}  e'~|~\varepsilon_1 &  e' \rightarrow^{*}  e''~|~\varepsilon_2}
\end{array}
\]

\vspace{-7pt}
\caption{Multi-step reductions in $\opercalc$.}
\label{This is the label.}
\end{figure}

 
 
 
 
 
 
\subsection{$\opercalc$ Static Rules}

The static rules for $\opercalc$ are summarised in Figure 3.5. There is the standard subtyping judgement form $\tau <: \tau$, and a new form judgement, $\Gamma \vdash e: \tau~\kw{with} \varepsilon$. The new form ascribes a type-and-effect to a piece of code $e$, meaning successive reductions of $e$ will yield terms of type $\tau$, and collectively incur no more than those effects in $\varepsilon$. These rules give a conservative approximation to the runtime effects of executing $e$, so the static $\varepsilon$ ascribed to $e$ may include effects which don't actually happen at runtime.

The rules for variables and values are: \textsc{$\varepsilon$-Var}, \textsc{$\varepsilon$-Resource}, and \textsc{$\varepsilon$-Abs}. These are identical to the rules in $\stlc$, except they approximate the runtime-effects as $\varnothing$; although a fucntion and a resource literal both encapsulate capabilities, something must be done to them (apply the function, operate on the resource) to incur a runtime effect.

The effects of a lambda application are: their effects of evaluating its subexpressions, and the effects incurred by executing the body of the lambda to which the left-hand side evaluates. Those last effects are obtained from the label on the lambda's arrow-type in the first premise.

The effects of an operation call are: the effects of evaluating the subexpression, and the single effect incurred when the subexpression is reduced to a resource literal $r$, and operation $\pi$ is invoked on it. It is not always possible to know statically which exact resource literal the subexpression reduces to (if it halts at all). For example, the program $\kwa{(if~System.randomBool~then~File~else~Socket).close}$ may either reduce to $\kwa{File.close}$ or $\kwa{Socket.close}$. In such cases, the safe approximation is to type the conditional as $\{ \kwa{File, Socket} \}$. \textsc{$\varepsilon$-OperCall} would then approximate the runtime effects of the operation call as  $\{ \kwa{File.close, Socket.close} \}$.

The rules of $\opercalc$ permit any operation to be performed on any resource. This can give bizarre programs --- $\kwa{Sensor.readTemp}$ seems like a sensible operation call, but what about $\kwa{File.readTemp}$? We acknowledge that this allows for strange programs, but because $\opercalc$ does not model the semantics of particular operatino-calls, we ignore it.

Being able to type an expression as a (non-singleton) set of resources requires the subtyping rule \textsc{S-Resource}. This says that a subset of resources is also a subtype. To justify this rule, consider $\{ \bar r \} <: \{ \bar r_2 \}$. Any value with type $\{ \bar r_1 \}$ can reduce to any resource literal in $\bar r_1$, so to be complatible with type $\{ \bar r_2 \}$, the resource literals in $\bar r_1$ must also be in $\bar r_2$, hence the definition.

The other subtyping rule is \textsc{S-Arrow}, a modification of the rule from $\stlc$. In addition to this rule being contravariant in the input and covariant in the output, it is also covariant in the effects. This is because any possible effect which might be incurred by the subtype should be expected by the supertype, otherwise substitution of a supertyped value for a subtyped value would allow the introduction of new effects not possible under the original.\\

\begin{figure}[h]


\noindent
\fbox{$\Gamma \vdash e: \tau~\kw{with} \varepsilon$}

\[
\begin{array}{c}

\infer[\textsc{($\varepsilon$-Var)}]
	{ \Gamma, x:\tau \vdash x: \tau~\kw{with} \varnothing }
	{}
	
	~~~
	
\infer[\textsc{($\varepsilon$-Resource)}]
 	{ \Gamma, r: \{ r \} \vdash r : \{ r \}~\kw{with} \varnothing }
 	{} \\[3ex]
 	
 	~~~
	\infer[\textsc{($\varepsilon$-Abs)}]
	{ \Gamma \vdash \lambda x:\tau_2 . e : \tau_2 \rightarrow_{\varepsilon_3} \tau_3~\kw{with} \varnothing }
	{ \Gamma, x: \tau_2 \vdash e: \tau_3~\kw{with} \varepsilon_3 }
	
	~~~
	
\infer[\textsc{($\varepsilon$-App)}]
	{ \Gamma \vdash e_1~e_2 : \tau_3~\kw{with} \varepsilon_1 \cup \varepsilon_2 \cup \varepsilon  }
	{ \Gamma \vdash e_1: \tau_2 \rightarrow_{\varepsilon} \tau_3~\kw{with} \varepsilon_1 & \Gamma \vdash e_2: \tau_2~\kw{with} \varepsilon_2 } \\[3ex]
	
\infer[\textsc{($\varepsilon$-OperCall)}]
	{ \Gamma \vdash e.\pi: \kw{Unit} \kw{with} \{ \bar r.\pi \} }
	{ \Gamma \vdash e: \{ \bar r \} & \forall r \in \bar r \mid r: \{ r \} \in \Gamma & \pi \in \Pi } \\[3ex]

\infer[\textsc{($\varepsilon$-Subsume)}]
	{ \Gamma \vdash e: \tau' ~\kw{with} \varepsilon'}
	{ \Gamma \vdash e: \tau ~\kw{with} \varepsilon & \tau <: \tau' & \varepsilon \subseteq \varepsilon'}
\end{array}
\]


\noindent
\fbox{$\Gamma \vdash e: \tau~\kw{with} \varepsilon$}

\[
\begin{array}{c}

\infer[\textsc{(S-Arrow)}]
	{ \tau_1 \rightarrow_{\varepsilon} \tau_2 <: \tau_1' \rightarrow_{\varepsilon'} \tau_2' }
	{ \tau_1' <: \tau_1 & \tau_2 <: \tau_2' & \varepsilon \subseteq \varepsilon' }
~~~~~~
\infer[\textsc{(S-Resource)}]
	{ \{ \bar r_1 \} <: \{ \bar r_2 \} }
	{ r \in r_1 \implies r \in r_2 }

\end{array}
\]


\vspace{-7pt}
\caption{Static rules of $\opercalc$.}
\label{This is the label.}
\end{figure}

\subsection{Soundness of $\opercalc$}

The goal of this section is to show $\opercalc$ is sound, but this requires an appropriate notion of \textit{effect soundness}. Intuitively, if a static judgement like $\Gamma \vdash e: \tau~\kw{with} \varepsilon$ were correct, it coudl be read as saying that successive reductions on $e$ will never produce effects not in the approximation $\varepsilon$. By adding this to our notion of soundness, we get the following first definition:

\begin{theorem}[Soundness 1]
If $ \Gamma \vdash  e_A:  \tau_A~\kw{with} \varepsilon_A$ and $ e_A$ is not a value, then $e_A \longrightarrow e_B~|~\varepsilon$, where $ \Gamma \vdash e_B:  \tau_B~\kw{with} \varepsilon_B$ and $ \tau_B <:  \tau_A$ and $\varepsilon \subseteq \varepsilon_A$.
\end{theorem}

In this formulation, $\varepsilon_A$ approximates the effects of the term $e_A$ in the context $\Gamma$. $e_A$ can be reduced to $e_B$, incurring the runtime effects in $\varepsilon$. The same context can also approximate the runtime effects of $e_B$ as $\varepsilon_B$, meaning the term after reduction can be typed, but no additional information about $\varepsilon_B$ is stipulated.

Our approach to proving that multi-step reduction is sound will be to inductively appeal to the soundness of single-step reductions. This is tricky under the given definition of Soundness because it only relates the runtime effects to the approximation of the runtime effects \textit{before} reduction. There is constraint on the runtime effects \textit{after} reduction. To accommodate a proof of multi-step soundness, we need a stronger version of soundness which relates the approximated effects before reduction ($\varepsilon_A$) to the approximated effects after reduction ($\varepsilon_B$).

First consider the analogous relation for the types of temrs before and after reduction. In $\lambda$-calculi, the type after reduction can be the same or more specific (i.e. $\tau_B <: \tau_A$) than the type before reduction. But it can never be less specific. Similarly, we shall require the approximated effects of a type can get more specific after reduction, but never less-specific.

To illustrate why the approximated effects might get more specific, consider the function $\kwa{get} = \lambda x: \{ \kwa{File, Socket} \} .x$ and the program $\kwa{(f~File).write}$. In the context $\Gamma = \kwa{File: \{ File \}}$, the rule \textsc{$\varepsilon$-App} can be used to approximate the effects of $\kwa{(f~File).write}$ as $\{ \kwa{File.write, Socket.write} \}$. By \textsc{E-App3} we have the reduction $\kwa{(get~File).write} \longrightarrow \kwa{File.write}~|~\varnothing$. The same context can use \textsc{$\varepsilon$-OperCall} to approximate the reduced expression $\kwa{File.write}$ as $\{ \kwa{File.write} \}$; note how the approximation of effects is more precise after reduction. This example shows why the approximation after reduction ($\varepsilon_B$) should be a subset of the approximation before reduction ($\varepsilon_A$).

We have our final definition of soundness:

\begin{theorem}[Soundness]
If $ \Gamma \vdash  e_A:  \tau_A~\kw{with} \varepsilon_A$ and $ e_A$ is not a value, then $e_A \longrightarrow e_B~|~\varepsilon$, where $ \Gamma \vdash e_B:  \tau_B~\kw{with} \varepsilon_B$ and $ \tau_B <:  \tau_A$ and $\varepsilon_B \cup \varepsilon \subseteq \varepsilon_A$.
\end{theorem}

We take the standard road to proving soundness by showing that progress and preservation hold of $\opercalc$, which in turn rely on modified versions of Canonical Forms and the Substitution Lemma.

Canonical Forms for $\opercalc$ states that resource-typed values are resource literals, and any typing judgement of a value will approximate the runtime effects as $\varnothing$. This result is not true if the rule used is \textsc{$\varepsilon$-Subsume}, so the lemma statement excludes judgements which use that rule. Progress follows from Canonical Forms.

\begin{lemma}[Canonical Forms]
Unless the rule used is \textsc{$\varepsilon$-Subsume}, the following are true:
\begin{itemize}
	\setlength\itemsep{-0.7em}
	\item If $ \Gamma \vdash  v:  \tau~\kw{with} \varepsilon$ then $\varepsilon = \varnothing$.
	\item If $ \Gamma \vdash  v: \{ \bar r \}$ then $ v = r$ for some $r \in R$ and $\{ \bar r \} = \{ r \}$.
\end{itemize}
\end{lemma}

\begin{theorem}[Progress]
If $ \Gamma \vdash  e:  \tau~\kw{with} \varepsilon$ and $ e$ is not a value, then $ e \longrightarrow  e'~|~\varepsilon$.
\end{theorem}

\begin{proof} By induction on $ \Gamma \vdash  e:  \tau~\kw{with} \varepsilon$, for $ e$ not a value. If the rule is \textsc{$\varepsilon$-Subsumption} it follows by inductive hypothesis. If $ e$ has a reducible subexpression then reduce it. Otherwise use one of \textsc{$\varepsilon$-App3} or \textsc{$\varepsilon$-OperCall2}.
\end{proof}

To show preservation holds we need to know that type-and-effect safety, as it has been formulated in the definition of soundness, is preserved by the substitution in \textsc{E-App3}. As noted earlier, variables can only be substituted for values in $\opercalc$. Canonical Forms tells us that any value will have its effects approximated as $\varnothing$ (except when \textsc{$\varepsilon$-Subsume} is used). This leads to $\opercalc$ having a slightly stronger formulation than the $\stlc$ equivalent. The proof is routine.

\begin{lemma}[Substitution]
If $\Gamma, x: \tau' \vdash e: \tau~\kw{with} \varepsilon$ and $\Gamma \vdash v: \tau'~\kw{with} \varnothing$ then $\Gamma \vdash [v/x]e: \tau~\kw{with} \varepsilon$.
\end{lemma}

\begin{proof} By induction on $\Gamma, x: \tau' \vdash e: \tau~\kw{with} \varepsilon$.
\end{proof}

With this lemma, we are ready to prove the preservation theorem.

\begin{theorem}[Preservation]
If $\Gamma \vdash e_A: \tau_A~\kw{with} \varepsilon_A$ and $e_A \longrightarrow e_B~|~\varepsilon$, then $\tau_B <: \tau_A$ and $\varepsilon_B \cup \varepsilon \subseteq \varepsilon_A$.
\end{theorem}

\begin{proof} By induction on $\Gamma \vdash e_A: \tau_A~\kw{with} \varepsilon_A$, and then on $e_A \longrightarrow e_B~|~\varepsilon$. Since $e_A$ can be reduced, we need only consider those rules which apply to non-values and non-variables. \\

\textit{Case:} \textsc{$\varepsilon$-App} Then $e_A = e_1 ~ e_2$ and $e_1: \tau_2 \rightarrow_{\varepsilon} \tau_3~\kw{with} \varepsilon_1$ and $\Gamma \vdash e_2: \tau_2~\kw{with} \varepsilon_2$. If the reduction rule used was \textsc{E-App1} or \textsc{E-App2}, then the result follows by applying the inductive hypothesis to $e_1$ and $e_2$ respectively.

Otherwise the rule used was \textsc{E-App3}. Then $(\lambda x: \tau_2. e) v_2 \longrightarrow [ v_2/x] e~|~\varnothing$. By inversion on the typing rule for $\lambda x:  \tau_2. e$ we know $\Gamma, x:  \tau_2 \vdash  e:  \tau_3~\kw{with} \varepsilon_3$. By canonical forms, $\varepsilon_2 = \varnothing$ because $ e_2 =  v_2$ is a value. Then by the substitution lemma, $ \Gamma \vdash [ v_2/x] e :  \tau_3~\kw{with} \varepsilon_3$. By canonical forms, $\varepsilon_1 = \varepsilon_2 = \varnothing = \varepsilon_C$. Therefore $\varepsilon_A = \varepsilon_3 = \varepsilon_B \cup \varepsilon_C$.\\

\textit{Case:} \textsc{$\varepsilon$-OperCall}. Then $e_A = e_1.\pi$ and $ \Gamma \vdash e_1 : \{ \bar r \}~\kw{with} \varepsilon_1$. If the reduction rule used was \textsc{E-OperCall1} then the result follows by applying the inductive hypothesis to $ e_1$.

Otherwise the reduction rule used was \textsc{E-OperCall2} and $v_1.\pi \longrightarrow \kwa{unit}~|~\{ r.\pi \}$. By canonical forms, $ \Gamma \vdash v_1: \kwa{unit}~\kw{with} \{ r.\pi \}$. Also, $ \Gamma \vdash \kwa{unit}: \kwa{Unit}~\kw{with} \varnothing$. Then $\tau_B = \tau_A$. Also, $\varepsilon_C \cup \varepsilon_B = \{ r.\pi \} = \varepsilon_A$.\\

\end{proof}

Our single-step soundness theorem now holds immediately by joining the progress and preservation theorems into one.

\begin{theorem}[Soundness]
If $ \Gamma \vdash  e_A:  \tau_A~\kw{with} \varepsilon_A$ and $ e_A$ is not a value, then $e_A \longrightarrow e_B~|~\varepsilon$, where $ \Gamma \vdash e_B:  \tau_B~\kw{with} \varepsilon_B$ and $ \tau_B <:  \tau_A$ and $\varepsilon_B \cup \varepsilon \subseteq \varepsilon_A$.
\end{theorem}
\begin{proof}
If $ e_A$ is not a value then the reduction exists by the progress theorem. The rest follows by the preservation theorem.
\end{proof}

Knowing that single-step reductions are sound, the soundness of multi-step reductions can be shown by inductively applying single-step soundness on the length of a multi-step reduction.

\begin{theorem}[Multi-step Soundness]
If $ \Gamma \vdash  e_A:  \tau_A~\kw{with} \varepsilon_A$ and $e_A \longrightarrow^{*} e_B~|~\varepsilon$, where $\Gamma \vdash e_B: \tau_B~\kw{with} \varepsilon_B$ and $ \tau_B <: \tau_A$ and $\varepsilon_B \cup \varepsilon \subseteq \varepsilon_A$.
\end{theorem}

\begin{proof} By induction on the length of the multi-step reduction. If the length is 0 then $e_A = e_B$ and the result holds vacuously. If the length is 1 the result holds by soundness of single-step reductions. if the length is $n+1$, then the first $n$-step reduction is sound by inductive hypothesis and the last step is sound by single-step soundness, so the entire $n+1$-step reduction is sound.
\end{proof}

This concludes the soundness proof for $\opercalc$. As we have seen, $\opercalc$ builds upon $\stlc$ with resources and operations. Every function must have its input type labelled with the effects any values of that type might incur. This allows us to easily effect-check a piece of code to ascertain what runtime effects it might have when executed. And we have just proven it sound.
























\section{$\epscalc$: Epsilon Calculus}

$\opercalc$ requires every function to have its input type annotated --- if we relax this requirement, can our type system say anything useful about pieces of unannotated code? In this section we introduce $\epscalc$, which leverages capability-safe design to enable our type-system to approximate what effects might be incurred by unannotated code.

There are practical reasons to permit unannotated code in an effect-conscious language. Previous effect systems have been criticised for their verbosity, \textbf{citation needed} which might disincline a programmer from bothering to use them. Allowing the structured mixture of annotated and unannotated also permits one to rapidly prototype software in the unannotated sublanguage and then incrementally add effect annotations as they are needed, giving a trade-off between convenience and safety.

In general, reasoning about unannotated code is difficult because there are no constraints on what effects they might incur. Figure \ref{fig:unannotated_reasoning} demonstrates the issue with a Wyvern-like snippet of code. $\kwa{someMethod}$ takes a function as input and executes it; but the effects of $\kwa{f}$ depend on what particular implementation is passed to $\kwa{someMethod}$. Without more information, whether by means of a more complex type-system or more static annotations, there is no general way to know what effects might be incurred by $\kwa{someMethod}$.

\begin{figure}[h]
\begin{lstlisting}
def someMethod(f: Unit $\rightarrow$ Unit):
   f()
\end{lstlisting}
\vspace{-7pt}
\caption{What effects might be incurred by $\kwa{someMethod}$?}
\label{fig:unannotated_reasoning}
\end{figure}

Therefore, $\epscalc$ permits the nesting of unannotated code when it is nested inside annotated code with the $\kwa{import}$ expression. The typing rule for $\kwa{import}$ expression, \textsc{$\varepsilon$-Import}, imposes a set of restrictions on what authority can be exercised by the unannotated code. This enables the type system to safely approximate the effects of unannotated code as those effects captured by the capabilities selected by enclosing $\kwa{import}$ expressions. This is the key result of $\epscalc$, which we formalise and prove in this section.


\subsection{$\epscalc$ Grammar}

The grammar of $\epscalc$ is essentially split into rules for annotated code and analogous rules for unannotated code. To distinguish the two, annotated types, expressions, and contexts always have a hat above them: $\hat e$, $\hat \tau$, and $\hat \Gamma$ instead of $e$, $\tau$, and $\Gamma$.

The unannotated portion consists of programs made from the same building blocks as $\opercalc$, but with the regular type-constructor $\rightarrow$ from $\stlc$. Unannotated programs have no labels on their functions at all. They are also \textit{deeply} unannotated: if a term is unannotated at the top-level, then every sub-term is also unannotated, so you cannot nest annotated code inside unannotated code. The corresponding grammar of types contains unannotated types $\tau$, which are built from resource-stes and $\rightarrow$, and unannotated contexts $\Gamma$. An unannotated context can only map variables to unannotated types.

Except for the new $\kwa{import}$ expression, the analogous rules for annotated programs and their surrounding meta-theory is the same as $\opercalc$. Annotated types $\hat \tau$ are those built using the type constructors $\rightarrow_{\varepsilon}$, where $\varepsilon$ is a concrete set of effects. The category of annotated contexts is $\hat \Gamma$, which binds variables to annotated types.

The interesting new form is $\kwa{import}$, which belongs to the annotated sublanguage. $\kwa{import}$ introduces a name $x$ with annotated definition $\hat e$ into a body of unannotated code $e$. $\varepsilon$ is the set of effects selected by the unannotated code, so any resources and operation calls used in $e$ must be declared in $\varepsilon$. $\kwa{import}$ is the only means of nesting unannotated subterms inside annotated terms.

\begin{figure}[h]
\vspace{-5pt}

\[
\begin{array}{lll}

\begin{array}{lllr}

e & ::= & ~ & exprs: \\
	& | & x & variable \\
	& | & v & value \\
	& | & e ~ e & application \\
	& | & e.\pi & operation \\
	&&\\

v & ::= & ~ & values: \\
	& | & r & resource~literal \\
	& | & \lambda x: \tau.e & abstraction \\
	&&\\
	
\hat e & ::= & ~ & labelled~exprs: \\
	& | & x \\
	& | & \hat v \\
	& | & \hat e ~ \hat e \\
	& | & \hat e.\pi \\
	& | & \kwa{import}(\varepsilon)~x = \hat e~\kwa{in}~e & import \\
	&&\\

\hat v & ::= & ~ & labelled~values: \\
	& | & r \\
	& | & \lambda x: \hat \tau.\hat e \\
	&&\\

\end{array}

& ~~~~~~~~&

\begin{array}{lllr}

\varepsilon & ::= & ~ & effects: \\
	& | & \{ \overline{r.\pi} \} \\
	&&\\

\tau & ::= & ~ & types: \\
		& | & \{ \bar r \} \\
		& | & \tau \rightarrow \tau \\ 
		&&\\

\hat \tau & ::= & ~ & labelled ~types: \\
		& | & \{ \bar r \} \\
		& | & \hat \tau \rightarrow_{\varepsilon} \hat \tau \\
		&&\\

\Gamma & ::= & ~ & type~ctx: \\
				& | & \varnothing \\
				& | & \Gamma, x: \tau \\
				&&\\
				
\hat \Gamma & ::= & ~ & labelled~type~ctx:\\
				& | & \varnothing \\
				& | & \hat \Gamma, x: \hat \tau \\
				&&\\

\end{array}

\end{array}
\]

\vspace{-7pt}
\caption{Effect calculus.}
\label{This is the label.}
\end{figure}

\subsection{$\epscalc$ Dynamic Rules}

Different approaches can be taken to defining the execution of an $\epscalc$. One way is to define reductions for both annotated and unannotated programs, but this results in a lot of uninteresting rules which clutter the formalism. Another way is to define reductions for either annotated or unannotated programs, and translate programs into the appropriate form before executing them. We choose this approach, but the transformation happens during execution of the program, rather than before the program is executed. The idea is that whenever a piece of unlabelled code is encountered, the $\kwa{import}$ expression surrounding it will have been evaluated to the point where we know what effects $\varepsilon$ are being selected by the unannotated body $e$. At this point, we can annotate $e$ with $\varepsilon$ and continue executing this result.

To this end we define $\kwa{annot}$ in Figure \ref{fig:annot_defn}. This function takes a piece of unlabelled code $e$ and a set of effects $\varepsilon$ and produces $\hat e$, obtained by labelling every arrow-type with $\varepsilon$. A version of this function is given for expressions, types, and contexts. Its dual is $\kwa{erase}$, which deletes all annotations from code. We will need $\kwa{erase}$ in the definition of \textsc{$\varepsilon$-Import}, so we give its definition here. Like $\kwa{annot}$, there are versions which delete the annotations from expressions, contexts, and types. However, $\kwa{erase}$ is partial because it is not defined on $\kwa{import}$ expressions.

\begin{figure}[h]
\vspace{-5pt}

$\bm{\kwa{annot :: e \times \varepsilon \rightarrow \hat e}}$

\begin{itemize}
	\setlength\itemsep{-0.7em}
	\item[] $\annot{r}{\_} = r$
	\item[] $\annot{\lambda x: \tau_1 . e}{\varepsilon} = \lambda x: \annot{\tau_1}{\varepsilon} . \annot{e}{\varepsilon}$
	\item[] $\annot{e_1~e_2}{\varepsilon} = \kwa{annot}(e_1, \varepsilon)~\kwa{annot}(e_2, \varepsilon)$
	\item[] $\annot{e_1.\pi}{\varepsilon} = \annot{e_1}{\varepsilon}.\pi$
\end{itemize}
	
$\bm{\kwa{annot :: \tau \times \varepsilon \rightarrow \hat \tau}}$

\begin{itemize}
	\setlength\itemsep{-0.7em}
	\item[] $\annot{\{ \bar r \}}{\_} = \{ \bar r \}$
	\item[] $\annot{\tau \rightarrow \tau}{\varepsilon} = \tau \rightarrow_{\varepsilon} \tau$.	
\end{itemize}

$\bm{\kwa{annot :: \Gamma \times \varepsilon \rightarrow \hat \Gamma}}$

\begin{itemize}
	\setlength\itemsep{-0.7em}
	\item[] $\annot{\varnothing}{\_} = \varnothing$
	\item[] $\annot{\Gamma, x: \tau}{\varepsilon} = \annot{\Gamma}{\varepsilon}, x: \annot{\tau}{\varepsilon}$
\end{itemize}

$\bm{\kwa{erase :: \hat \tau \rightarrow \tau}}$
\begin{itemize}
	\setlength\itemsep{-0.7em}
	\item[] $\erase{\{ \bar r \}}$
	\item[] $\erase{\hat \tau_1 \rightarrow_{\varepsilon} \hat \tau_2} = \erase{\hat \tau_1} \rightarrow \erase{\hat \tau_2}$
\end{itemize}

$\bm{\kwa{erase :: \hat e \rightarrow e}}$
\begin{itemize}
	\setlength\itemsep{-0.7em}
	\item[] $\erase{r} = r$
	\item[] $\erase{\lambda x: \hat \tau_1 . \hat e} = \lambda x: \erase{\hat \tau_1} . \erase{\hat e}$
	\item[] $\erase{e_1~e_2} = \erase{e_1}~\erase{e_2}$
	\item[] $\erase{e_1.\pi} = \erase{e_1}.\pi$
\end{itemize}

\vspace{-7pt}
\caption{Definitions of $\kwa{annot}$ and $\kwa{erase}$.}
\label{fig:annot_defn}
\end{figure}

It is worth mentioning that $\kwa{annot}$ and $\kwa{erase}$ operate on a purely syntactic level. Their definitions state no meaningful correspondence between the types and effects of a program before and after it has been annotated or erased. It remains for us to prove there is a meaningful correspondence in the particular way these functions are used in the rules for $\kwa{import}$ expressions.

Finally, before giving the dynamic rules we must define a version of $\kwa{substitution}$ for $\epscalc$. As our dynamic rules are defined on annotated expressions, so too will $\kwa{substitution}$ be defined. The definition, given in \ref{fig:epscalc_defn}, is otherwise straight-forward. It has been updated for the new annotated notation and the new $\kwa{import}$ expression. It retains the same restriction from $\opercalc$ where substitution is only well-defined when a variable is replaced with a value. 

\begin{figure}[h]

\bm{$\kwa{substitution :: \hat e \times \hat v \times \hat v \rightarrow \hat e}$}

\begin{itemize}
	\setlength\itemsep{-0.7em}
	\item[] $[\hat v/y]x = \hat v$, if $x = y$
	\item[] $[\hat v/y]x = x$, if $x \neq y$
	\item[] $[\hat v/y](\lambda x: \hat \tau. \hat e) = \lambda x: \hat \tau.[\hat v/y]\hat e$, if $y \neq x$ and $y$ does not occur free in $\hat e$
	\item[] $[\hat v/y](\hat e_1~\hat e_2) = ([\hat v/y]\hat e_1)([\hat v/y]\hat e_2)$
	\item[] $[\hat v/y](\hat e_1.\pi) = ([\hat v/y]e_1).\pi$
	\item[] $[\hat v/y](\import{\varepsilon}{x}{\hat e}{e}) = \import{\varepsilon}{x}{[\hat v/y]\hat e}{e}$
\end{itemize}

\vspace{-7pt}
\caption{Definition of $\kwa{substitution}$.}
\label{fig:epscalc_defn}
\end{figure}

The multi-step rules of $\epscalc$ are identical to $\opercalc$. Every single-step rule in $\opercalc$ is also a single-step rule in $\epscalc$. The only difference is that the new annotated notation in $\epscalc$ would have a hat above every expression and type. For brevity, we omit those rules which are (basically) identical to those of $\opercalc$.

The two new single-step reductions are given in \ref{fig:opercalc_reductions}. Both reduce $\kwa{import}$ expressions. \textsc{E-Import1} reduces the definition of the capability being imported into the unannotated code. The more interesting rule is \textsc{E-Import2}, which applies when the capability being impoted is a value. The unlabelled body $e$ is annotated with the authority $\varepsilon$ it selects; this is $\kwa{annot}(e, \varepsilon)$. The name $x$ of the capability is then replaced with its actual definition $\hat v$; this is $[\hat v/x]\kwa{annot}(e, \varepsilon)$. This reduction incurs no effects.

\begin{figure}[h]

\noindent
\fbox{$\hat e \longrightarrow \hat e~|~\varepsilon$}

\[
\begin{array}{c}
\infer[\textsc{(E-Import1)}]
	{\kwa{import}(\varepsilon)~x = \hat e~\kw{in} e \longrightarrow \kwa{import}(\varepsilon)~x = \hat e'~\kw{in} e~|~\varepsilon'}
	{\hat e \longrightarrow \hat e'~|~\varepsilon'}\\[4ex]

\infer[\textsc{(E-Import2)}]
	{\kwa{import}(\varepsilon)~x = \hat v~\kw{in} e \longrightarrow [\hat v/x]\kwa{annot}(e, \varepsilon)~|~\varnothing}
	{}

\end{array}
\]


\vspace{-7pt}
\caption{New single-step reductions in $\epscalc$.}
\label{fig:opercalc_reductions}
\end{figure}


\subsection{$\epscalc$ Static Rules}

Our goal in this section is to introduce \textsc{$\varepsilon$-Import}, which approximates the effects of unannotated code by inspecting its selected authority. The rule is complicated, so we build up to it.

First, since programs in $\epscalc$ can be annotated or unannotated, we need to be able to recognise when either kind is well-typed. Since the annotated subset of $\epscalc$ contains $\opercalc$, all the $\opercalc$ still apply, but the notation is different: we put hats on everything to signify that a typing judgement is being made about annotated code inside an annotated context. This looks like $\hat \Gamma \vdash \hat e: \hat \tau~\kw{with} \varepsilon$. Except for this change in notation the rules are the same, so we shall not repeat them. 

The rules for typing unannotated pieces of code take the form $\Gamma \vdash e: \tau$. The subtyping judgement for unannotated code takes the form $\tau <: \tau$. A summary of these typing and subtyping rules is given in \ref{fig:unannotated_static_rules}; each is analogous to some rule in $\opercalc$, but the parts relating to effects have been removed.

\begin{figure}[h]

\fbox{$\Gamma \vdash e: \tau$}

\[
\begin{array}{c}


\infer[\textsc{(T-Var)}]
	{\Gamma, x: \tau \vdash x: \tau}
	{}
~~~~~~
\infer[\textsc{(T-Resource)}]
	{\Gamma, r: \{ r \} \vdash r : \{ r \}}
	{}

~~~~~~
\infer[\textsc{(T-Abs)}]
	{\Gamma \vdash \lambda x: \tau_1.e : \tau_1 \rightarrow \tau_2}
	{\Gamma, x: \tau_1 \vdash e: \tau_2}\\[4ex]
	
\infer[\textsc{(T-App)}]
	{\Gamma \vdash e_1~e_2: \tau_3}
	{\Gamma \vdash e_1: \tau_2 \rightarrow \tau_3 & \Gamma \vdash e_2: \tau_2}
~~~~~~
\infer[\textsc{(T-OperCall)}]
	{\Gamma \vdash e.\pi: \kwa{Unit}}
	{\Gamma \vdash e: \{ \bar r \} & \forall r \in \bar r \mid r \in R & \pi \in \Pi}

\end{array}
\]



\fbox{$\tau <: \tau$}

\[
\begin{array}{c}

\infer[\textsc{(S-Arrow)}]
	{ \tau_1 \rightarrow \tau_2 <: \tau_1' \rightarrow \tau_2' }
	{ \tau_1' <: \tau_1 & \tau_2 <: \tau_2' }
	~~~
\infer[\textsc{(S-Resources)}]
	{ \{ \bar r_1 \} <: \{ \bar r_2 \} }
	{ \{ \bar r_1 \} \subseteq \{ \bar r_2 \} }

\end{array}
\]

\vspace{-7pt}
\caption{(Sub)typing judgements for the unannotated sublanguage of $\epscalc$}
\label{fig:unannotated_static_rules}
\end{figure}

Again, there are no rules which directly approximate the effects of unannotated code. The only mechanism for doing this is to encapsulate that code in an $\kwa{import}$ expression, which restricts what authority it can exercise. This means the rules can only tell us something interesting about annotated code and unannotated code which is nested inside an $\kwa{import}$ expression. For the rest of this section, we are going to build up to the definition of \textsc{$\varepsilon$-Import}.

To begin, typing $\import{\varepsilon}{x}{\hat e}{e}$ requires us to know that the capability $\hat e$ being imported is well-typed, so we add the premise $\hat \Gamma \vdash \hat e: \hat \tau~\kw{with} \varepsilon_1$. Whatever authority is exercised by $e$ must have been selected by the $\kwa{import}$ expression, so you should be able to type $e$ with a binding for $x: \hat \tau$. However, $\hat \tau$ is annotated and $e$ is unannotated, so we erase the labels on it. This gives our second premise, $x: \erase{\hat \tau} \vdash e: \tau$. These observations give our first definition of \textsc{$\varepsilon$-Import} in Figure \ref{fig:import_rule_1}. Since \textsc{E-Import2} labels the unannotated code code with the selected authority $\varepsilon$, an $\kwa{import}$ expression should type to $\kwa{annot}(\tau, \varepsilon)$. The safe approximation of the unannotated code's effects is $\varepsilon_1 \cup \varepsilon$; the former comes from reducing the imported capability (which happens prior to the execution of the unannotated code) and the latter contains all the authority which the unannotated code may use.

\begin{figure}[h]

\fbox{$\tau <: \tau$}

\[
\begin{array}{c}

\infer[\textsc{($\varepsilon$-Import1)}]
	{ \hat \Gamma \vdash \import{\varepsilon}{x}{\hat e}{e}: \kwa{annot}(\tau, \varepsilon)~\kw{with} \varepsilon \cup \varepsilon_1 }
	{ \hat \Gamma \vdash \hat e: \hat \tau~\kw{with} \varepsilon_1 & x: \kwa{erase}(\hat \tau) \vdash e: \tau }

\end{array}
\]
\vspace{-7pt}
\caption{A first rule for type-and-effect checking $\kwa{import}$ expressions.}
\label{fig:import_rule_1}
\end{figure}

On the surface, this rule may seem overly restrictive because $\kwa{import}$ only allows one to import a single capability. What about unannotated code which uses multiple capabilities? One solution is to reformulate the rules (and grammar) to permit any number of imports. Another is to import multiple capabilities by importing a tuple of capabilities; for example $\import{\varepsilon}{x}{(\kwa{File, Socket})}{e}$. We have not presented tuples as a part of the base language, but they could be encoded as a derived form, or added as a language extension. Both approaches are straightforward and extending $\epscalc$ in these ways would be routine --- but only allowing the import of a single capabilitiy reduces clutter in the rules and simplifies the presentation, so we stick to this convention.

The first version of the rule has some issues. First of all, there is no formal relation between $\varepsilon$ and whatever effects are captured by $\hat \tau$. Consider $\hat e = \import{\varnothing}{x}{\File}{\kwa{x.write}}$, which imports a $\File$ and writes to it, but declares its authority as $\varnothing$. According to \textsc{$\varepsilon$-Import1}, $\vdash \hat e: \Unit~\kw{with} \varnothing$, but this is clearly wrong. We need to add a constraint to say that whatever effects are captured by $\hat \tau$ should be selected in $\varepsilon$. To this end we define a function, $\kwa{effects}$, which collects the set of effects that an annotated type captures. A first definition is given in Figure \ref{fig:fx_defn}. With it, we can add an extra premise $\kwa{effects}(\hat \tau) \subseteq \varepsilon$ which formalises the idea that any capability exercised by $e$ must be selected in $\varepsilon$. The updated rule is given in Figure \ref{fig:import_rule_2}.


\begin{figure}[h]

$\bm{\kwa{effects :: \hat \tau \rightarrow \varepsilon}}$ \begin{itemize}
	\setlength\itemsep{-0.7em}
	\item[] $\fx{\{ \bar r \}} = \{ r.\pi \mid r \in \bar r, \pi \in \Pi \}$
	\item[] $\fx{\hat \tau_1 \rightarrow_{\varepsilon} \hat \tau_2} = \fx{\hat \tau_1} \cup \varepsilon \cup \fx{\hat \tau_2}$
\end{itemize}
\vspace{-7pt}
\caption{A first definition of $\kwa{effects}$.}
\label{fig:fx_defn}
\end{figure}

\begin{figure}[h]

\[
\begin{array}{c}

\infer[\textsc{($\varepsilon$-Import2)}]
	{ \hat \Gamma \vdash \import{\varepsilon}{x}{\hat e}{e}: \kwa{annot}(\tau, \varepsilon)~\kw{with} \varepsilon \cup \varepsilon_1 }
	{ \hat \Gamma \vdash \hat e: \hat \tau~\kw{with} \varepsilon_1 & x: \kwa{erase}(\hat \tau) \vdash e: \tau & \kwa{effects}(\hat \tau) \subseteq \varepsilon}

\end{array}
\]
\vspace{-7pt}
\caption{A second rule for type-and-effect checking $\kwa{import}$ expressions.}
\label{fig:import_rule_2}
\end{figure}

The counterexample which defeated \textsc{$\varepsilon$-Import1} is now rejected by \textsc{$\varepsilon$-Import2}, but the rule is not yet perfect: the annotations on one import can be broken by another import. To illustrate, consider an example where two capabilities are imported\footnote{As stated before, we only formalise the case where code imports one capability, but this particular issue only arises with multiple imports.} in Figure \ref{fig:rule_import2_counterexample}. This program imports a function $\kwa{go}$ which, when given a $\Unit \rightarrow_{\varnothing} \Unit$ function with no effects, will execute it. The other capability given is a $\kwa{File}$. The unannotated code creates a $\Unit \rightarrow \Unit$ function which writes to a file when executed, and passes it to $\kwa{go}$, which subsequently incurs the $\kwa{File.write}$ effect.

\begin{figure}[h]

\begin{lstlisting}
import({File.*})
   go = $\lambda$x: Unit $\rightarrow_{\varnothing}$ Unit. x unit
   f = File
in
   go ($\lambda$y: Unit. f.write)

\end{lstlisting}

\vspace{-7pt}
\caption{Permitting multiple imports will break \textsc{$\varepsilon$-Import2}.}
\label{fig:rule_import2_counterexample}
\end{figure}

In the world of annotated code, you cannot pass a file-writing function to $\kwa{go}$. However, typechecking of the unannotated body disregards the annotations of its imports, and since the file-writing function takes $\unit$ and returns $\unit$, the type system will accept this program. This example shows that unannotated code might not use its capabilities in a way which respects their annotations. Because the unannotated code selects $\{ \kwa{File.*} \}$, the approximation on this $\kwa{import}$ is actually safe at the top-level, but it contains locally unsafe code. We want to prevent this.

If $\kwa{go}$ had the type $\Unit \rightarrow_{\{ \kwa{File.write} \}} \Unit$ then the above example would be safely rejected. However, a modified version where a file-reading function is passed to $\kwa{go}$ would still have the same issue. $\kwa{go}$ is only safe when it expects every possible effect that the unannotated code could pass into it. For example, if $\kwa{go}$ had the type $\Unit \rightarrow_{\{ \kwa{File.*} \}} \Unit$, then the unannotated code cannot pass it a capability it isn't already expecting, and so it cannot violate the annotation on $\kwa{go}$. To solve the issue, we are going to require imported capabilities to have authority over $\varepsilon$, which contains every possible effect the unannotated code might use to violate their annotations.

To achieve greater control over this, we split the definition of $\kwa{effects}$ into two separate functions, called $\kwa{effects}$ and $\kwa{ho \hyphen effects}$. Definitions are given in Figure \ref{fig:fx_defns}. The difference between the two is the difference between direct and transitive authority. If values of type $\hat \tau$ can directly incur an effect $r.\pi$, then $r.\pi \in \fx{\hat \tau}$. If values of type $\hat \tau$ can indirectly incur an effect $r.\pi$ --- perhaps because they are given a capability for this effect as a function argument --- then $r.\pi \in \hofx{\hat \tau}$. Put another way, if values of $\hat \tau$ possess a capability for that effect, then the capability's effects are contained in $\fx{\hat \tau}$. If values of $\hat \tau$ can incur an effect, but need to be given the capability by someone else in order to do that, then the effect belongs in $\hofx{\hat \tau}$.


\begin{figure}[h]

$\bm{\kwa{effects :: \hat \tau \rightarrow \varepsilon}}$ \begin{itemize}
	\setlength\itemsep{-0.7em}
	\item[] $\fx{\{ \bar r \}} = \{ r.\pi \mid r \in \bar r, \pi \in \Pi \}$
	\item[] $\fx{\hat \tau_1 \rightarrow_{\varepsilon} \hat \tau_2} = \hofx{\hat \tau_1} \cup \varepsilon \cup \fx{\hat \tau_2}$
\end{itemize}

$\bm{\kwa{ho \hyphen effects} :: \hat \tau \rightarrow \varepsilon}$ \begin{itemize}
	\setlength\itemsep{-0.7em}
	\item[] $\hofx{\{ \bar r \}} = \varnothing$
	\item[] $\hofx{\hat \tau_1 \rightarrow_{\varepsilon} \hat \tau_2} = \fx{\hat \tau_1} \cup \hofx{\hat \tau_2}$
\end{itemize}

\vspace{-7pt}
\caption{Effect functions.}
\label{fig:fx_defns}
\end{figure}

Note how the functions are mutually recursive, and have base cases for resource types. Any effect can be directly incurred by a resource on itself, hence $\fx{\{ \bar r \}} = \{ r.\pi \mid r \in \bar r, \pi \in \Pi \}$. A resource cannot be used to indirectly invoke some other effect, so $\hofx{\{ \bar r \}} = \varnothing$. There is also a correspondence between these definitions and the subtyping rule for functions. Recall that functions are contravariant in their input-type and covariant in their output-type. Similarly, both functions recurse on the input-type using the other function, and recurse on the output-type using the same function.

In light of these new definitions, we would still require $\fx{\hat \tau} \subseteq \varepsilon$ --- unannotated code must select any capability which could be given to it --- but a new premise $\varepsilon \subseteq \hofx{\hat \tau}$ would be added to formalise the idea that imported capabilities must know about every effect they could be given by unannotated code.  The counterexample from Figure \ref{fig:rule_import2_counterexample} will now be rejected, because $\hofx{\Unit \rightarrow_{\varnothing} \Unit) \rightarrow_{\varnothing} \Unit} = \varnothing$, but $\{ \kwa{File.*} \} \not\subseteq \varnothing$. But this is \textit{still} not sufficient! Consider $\varepsilon \subseteq \hofx{ \hat \tau_1 \rightarrow_{\varepsilon'} \hat \tau_2 }$. We want \textit{every} higher-order capability involved to be expecting $\varepsilon$, but $\subseteq$ does not distribute over $\rightarrow_{\varepsilon'}$. Expanding the definition, $\varepsilon \subseteq \fx{\hat \tau_1} \cup \hofx{\hat \tau_2}$. Let $r.\pi \in \varepsilon$ and suppose $r.\pi \in \fx{\hat \tau_1}$, but $r.\pi \notin \hofx{\hat \tau_2}$. Then $\varepsilon \subseteq \fx{\hat \tau_1} \cup \hofx{\hat \tau_2}$ is still true, but $\hat \tau_2$ is not expecting $r.\pi$. Unannotated code could then violate the annotations on $\hat \tau_2$ by causing it to invoke $r.\pi$, using the same trickery from before.

The solution is to define a relation like $\varepsilon \subseteq \fx{\hat \tau_1} \cup \hofx{\hat \tau_2}$, but where the $\subseteq$ distributes over the input and output type. The two relations are called $\kwa{safe}$ and $\kwa{ho \hyphen safe}$. The former is a distributive version of $\varepsilon \subseteq \fx{\hat \tau}$ and the latter of $\varepsilon \subseteq \hofx{\hat \tau}$. Definitions are given in \ref{fig:safe_defns}.


\begin{figure}[h]

\noindent
$\fbox{$\kwa{safe(\hat \tau, \varepsilon)}$}$

\[
\begin{array}{c}

\infer[\textsc{(Safe-Resource)}]
	{\kwa{safe}(\{ \bar r \}, \varepsilon)}
	{}
~~~~~
\infer[\textsc{(Safe-Unit)}]
	{\kwa{safe}(\kwa{Unit}, \varepsilon)}
	{} \\[3ex]

\infer[\textsc{(Safe-Arrow)}]
	{\kwa{safe}(\hat \tau_1 \rightarrow_{\varepsilon'} \hat \tau_2, \varepsilon)}
	{\varepsilon \subseteq \varepsilon' & \kwa{ho \hyphen safe}(\hat \tau_1, \varepsilon) & \kwa{safe}(\hat \tau_2, \varepsilon)} \\[3ex]

\end{array}
\]

\noindent
$\fbox{$\kwa{ho \hyphen safe(\hat \tau, \varepsilon)}$}$

\[
\begin{array}{c}

\infer[\textsc{(HOSafe-Resource)}]
	{ \kwa{ho \hyphen safe}( \{ \bar r \}, \varepsilon)} 
	{}
	~~~~~~
\infer[\textsc{(HOSafe-Unit)}]
	{ \kwa{ho \hyphen safe}( \kwa{Unit}, \varepsilon)} 
	{}\\[3ex]

\infer[\textsc{(HOSafe-Arrow)}]
	{ \kwa{ho \hyphen safe}( \hat \tau_1 \rightarrow_{\varepsilon'} \hat \tau_2, \varepsilon ) }
	{ \kwa{safe}(\hat \tau_1, \varepsilon)  & \kwa{ho \hyphen safe}(\hat \tau_2, \varepsilon) }\\[3ex]

\end{array}
\]

\vspace{-7pt}
\caption{Safety judgements in the epsilon calculus.}
\label{fig:safe_defns}
\end{figure}

Note again how the mutual recursion of $\kwa{safe}$ and $\kwa{ho \hyphen safe}$ mimics the co(ntra)variance rules for function subtyping. Some properties of these relations are also immediate: $\safe{\hat \tau}{\varepsilon}$ implies $\varepsilon \subseteq \fx{\hat \tau}$ and $\hosafe{\hat \tau}{\varepsilon}$ implies $\varepsilon \subseteq \hofx{\hat \tau}$, but the converses are not true, so the safety judgements are stronger notions.

We are now ready to give an amended version of \textsc{$\varepsilon$-Import}. The rule is stated in Figure \ref{fig:import_rule3}, and contains a new premise $\hosafe{\hat \tau}{\varepsilon}$, which formalises the notion that every capability which could given to a value of $\hat \tau$ --- or any constitutent piece of $\hat \tau$ --- must be expecting the effects which might be passed to it inside the unannotated code, which are contained in $\varepsilon$.

\begin{figure}[h]

\noindent
\fbox{$\hat \Gamma \vdash \hat e: \hat \tau~\kw{with} \varepsilon$}

\[
\begin{array}{c}

\infer[\textsc{($\varepsilon$-Import3)}]
	{ \hat \Gamma \vdash \kwa{import}(\varepsilon)~x = \hat e~\kw{in} e: \kwa{annot}(\tau, \varepsilon)~\kw{with} \varepsilon \cup \varepsilon_1 }
{{\def\arraystretch{1.4}
  \begin{array}{c}
\hat \Gamma \vdash \hat e: \hat \tau~\kw{with} \varepsilon_1
~~~~~~
\kwa{effects}(\hat \tau) \subseteq \varepsilon \\
\hosafe{\hat \tau}{\varepsilon} ~~~~~~ x: \kwa{erase}(\hat \tau) \vdash e: \tau
  \end{array}}} 
 
\end{array}
\]

\vspace{-7pt}
\caption{A third rule for type-and-effect checking $\kwa{import}$ expressions.}
\label{fig:import_rule3}
\end{figure}

The premises so far are comprehensively strict about what capabilities might be directly exercised by the unannotated code --- but what about those which are indirectly exercised? Consider $\hat e = \import{\varnothing}{x}{\unit}{\kwa{\lambda f: { File }.~f.write}}$. The unannotated selects no capabilities and returns a function which, when given a $\kwa{File}$, will incur $\kwa{File.write}$. This satisfies the premises in \textsc{$\varepsilon$-Import3}, but the ascribed type is $\{ \File \} \rightarrow_{\varnothing} \Unit$ --- not good!

So far we have only focused on the capabilities $\varepsilon$ which unannotated code might select and be endowed with, but a capability might also be introduced to unannotated code during runtime by being passed in as a function argument. Suppose the unannotated code returns a function $f$. Then $f$ may take as input either a resource or a function. If a function, then the permitted effects of this function are bound by $\varepsilon$, because the $\kwa{import}$ annotates $f$ with $\varepsilon$. Trying to invoke $\annot{f}{\varepsilon}$ back in annotated code with a capability whose authority exceeds $\varepsilon$ would therefore be rejected by the soundness of $\opercalc$, so we are automatically higher-order safe in this case. However, if a resource is given to $f$ then it could directly invoke any effect on $f$ without selecting it in $\varepsilon$. To prevent this, we add $\hofx{\annot{\tau}{\varepsilon}} \subseteq \varepsilon$ as a premise. This will collect every effect captured by a resource literal passed into the unannotated code and ensure it has been selected. $\kwa{hofx}$ is only defined on annotated types, so we must first annotate $\tau$ in order to apply the function --- the annotated type is otherwise not relevant to this situation.

The final version of \textsc{$\varepsilon$-Import} is given in Figure \ref{fig:import_rule}.

\begin{figure}[h]

\noindent
\fbox{$\hat \Gamma \vdash \hat e: \hat \tau~\kw{with} \varepsilon$}

\[
\begin{array}{c}

\infer[\textsc{($\varepsilon$-Import)}]
	{ \hat \Gamma \vdash \kwa{import}(\varepsilon)~x = \hat e~\kw{in} e: \kwa{annot}(\tau, \varepsilon)~\kw{with} \varepsilon \cup \varepsilon_1 }
{{\def\arraystretch{1.4}
  \begin{array}{c}
\varepsilon = \kwa{effects}(\hat \tau) \cup \hofx{\annot{\tau}{\varepsilon}} \\
\hat \Gamma \vdash \hat e: \hat \tau~\kw{with} \varepsilon_1 ~~~~~~ \kwa{ho \hyphen safe}(\hat \tau, \varepsilon) ~~~~~~ x: \kwa{erase}(\hat \tau) \vdash e: \tau
  \end{array}}} 
 
\end{array}
\]


\vspace{-7pt}
\caption{The final rule for typing imports.}
\label{fig:import_rule}
\end{figure}




\subsection{Soundness of $\epscalc$}

Soundness in $\epscalc$ is much the same as it is in $\opercalc$, but only for annotated programs. A definition is given below.

\begin{theorem}[Soundness]
If $\hat \Gamma \vdash \hat e_A: \hat \tau_A~\kw{with} \varepsilon_A$ and $\hat e_A$ is not a value, then $e_A \longrightarrow e_B~|~\varepsilon$, where $\hat \Gamma \vdash e_B: \hat \tau_B~\kw{with} \varepsilon_B$ and $\hat \tau_B <: \hat \tau_A$ and $\varepsilon_B \cup \varepsilon \subseteq \varepsilon_A$.
\end{theorem}

Because the rules of $\epscalc$ are the same as $\opercalc$, we simply extend the existing proofs to cover the case where the typing rule used is \textsc{$\varepsilon$-Import}. Canonical Forms remains unchanged. The Substitution Lemma gains an extra case, but the proof is routine.

\begin{lemma}[Canonical Forms]
The following are true:
\begin{itemize}
	\setlength\itemsep{-0.7em}
	\item If $\hat \Gamma \vdash \hat v: \hat \tau~\kw{with} \varepsilon$ then $\varepsilon = \varnothing$.
	\item If $\hat \Gamma \vdash \hat v: \{ \bar r \}$ then $\hat v = r$ for some $r \in R$ and $\{ \bar r \} = \{ r \}$.
\end{itemize}
\end{lemma}


\begin{lemma}[Substitution]
If $\hat \Gamma, x: \hat \tau' \vdash e: \hat \tau~\kw{with} \varepsilon$ and $\hat \Gamma \vdash \hat v: \hat \tau'~\kw{with} \varnothing$ then $\hat \Gamma \vdash [\hat v/x]e: \hat \tau~\kw{with} \varepsilon$.
\end{lemma}

The Progress Theorem now has an extra case: when the typing rule used is \textsc{$\varepsilon$-Import}. The result follows by considering whether the imported $\hat e$ in $\import{\varepsilon}{x}{\hat e}{e}$ is an expression or not.

\begin{theorem}[Progress]
If $\hat \Gamma \vdash \hat e: \hat \tau~\kw{with} \varepsilon$ and $\hat e$ is not a value, then $\hat e \longrightarrow \hat e'~|~\varepsilon$.
\end{theorem}

\begin{proof} If the rule is \textsc{$\varepsilon$-Import} then $e = \import{\varepsilon}{x}{\hat e}{e}$. If $\hat e$ is a non-value then it reduces by inductive assumption and the $\kwa{import}$ reduces via \textsc{$\varepsilon$-Import1}. Otherwise $\hat e$ is a value and the $\kwa{import}$ reduces via \textsc{$\varepsilon$-Import2}.
\end{proof}

Likewise, the preservation theorem gains an extra case when \textsc{$\varepsilon$-Import} is the typing rule used and \textsc{E-Import2} is the reduction rule used. To show the reduction $\import{\varepsilon}{x}{\hat v}{e} \longrightarrow [\hat v/x]\annot{e}{\varepsilon}~|~\varnothing$ preserves soundness requires a few things. First, if $\hat \Gamma \vdash \import{\varepsilon}{x}{\hat v}{e}: \hat \tau_A~\kw{with} \varepsilon_A$, then we need to be able to type the reduced expression in the same context: $\hat \Gamma \vdash [\hat v/x]\annot{e}{\varepsilon}: \hat \tau_B~\kw{with} \varepsilon_B$, where the type and effects are preserved. Our proof strategy for this case is to do this in two parts. First we show taht the typing judgement $\hat \Gamma \vdash \annot{e}{\varepsilon}: \hat \tau_B~\kw{with} \varepsilon_B$ can be made; then we the same judgement will hold of $[\hat v/x]\annot{e}{\varepsilon}$ in the same context by the substitution lemma. To prove the first part can be done, we introduce a new lemma.

\begin{lemma}[Annotation]
If the following are true:

\begin{itemize}
	\setlength\itemsep{-0.7em}
	\item $\hat \Gamma \vdash \hat v : \hat \tau~\kw{with} \varnothing$
	\item $\Gamma, y: \kwa{erase}(\hat \tau) \vdash e: \tau$
	\item $\varepsilon = \kwa{effects}(\hat \tau)$
	\item $\kwa{ho \hyphen safe}(\hat \tau, \varepsilon)$
\end{itemize}

\noindent
Then $\hat \Gamma, \kwa{annot}(\Gamma, \varepsilon), y: \hat \tau \vdash \kwa{annot}(e, \varepsilon) : \kwa{annot}(\tau, \varepsilon)~\kw{with} \varepsilon \cup \kwa{effects}(\kwa{annot}(\Gamma, \varepsilon))$.
\end{lemma}

\begin{proof}
By induction on $\Gamma, y: \kwa{erase}(\hat \tau) \vdash e: \tau$.
\end{proof}

\noindent
The exact formulation of the Annotation lemma is very specific to the premises of \textsc{$\varepsilon$-Import2}, but generalised slightly to accommodate a proof by induction. The generalisation is to allow $e$ to be typed in any context $\Gamma$ with a binding for $y$. $\Gamma$ encapsulates the ambeint authority exercised by $e$. At the top-level of any program, we will always have $\Gamma = \varnothing$; compare this with how the premise of \textsc{$\varepsilon$-Import} types the body of an $\kwa{import}$ expression with only a single binding for the import. However, inductively-speaking, there may be ambient capabilities. Consider $(\lambda x: \{ \kwa{File} \}.~\kwa{x.write})~\kwa{File}$. From the perspcetive of $\kwa{x.write}$, $\kwa{File}$ is an ambient capability, and so if we were to inductively apply the Annotation lemma, at this point, $\kwa{File} \in \Gamma$. However, because the code encapsulating $\kwa{x.write}$ selects $\kwa{File}$ by binding it to $x$ in the function, this is not ambient authority at the top-level.

Proof of the Annotation lemma is long but routine, save for the use of an additional pair of lemmas. These lemmas relate $\hat \tau$ and $\kwa{annot}(\kwa{erase}(\hat \tau), \varepsilon)$.

\begin{lemma}
If $\kwa{effects}(\hat \tau) \subseteq \varepsilon$ and $\kwa{ho \hyphen safe}(\hat \tau, \varepsilon)$ then $\hat \tau <: \kwa{annot}(\kwa{erase}(\hat \tau), \varepsilon)$.
\end{lemma}

\begin{lemma}
If $\kwa{ho \hyphen effects}(\hat \tau) \subseteq \varepsilon$ and $\safe{\hat \tau}{\varepsilon}$ then $\kwa{annot(erase}(\hat \tau), \varepsilon) <: \hat \tau$.
\end{lemma}

\begin{proof}
By simultaneous induction on $\kwa{ho \hyphen safe}$ and $\kwa{safe}$.
\end{proof}

\noindent
There is a close relation between these lemmas and the subtyping rule for functions. In a subtyping relation between functions, the input type is contravariant. Therefore, if $\hat \tau = \hat \tau_1 \rightarrow_{\varepsilon'} \tau_2$ and we have $\hat \tau <: \kwa{annot}(\tau, \varepsilon)$, then we need to know $\kwa{annot}(\tau_1) <: \hat \tau_1$. This is why there are two lemmas, one for each direction.

Armed with the annotation lemma, we are now ready to prove the preservation theorem.

\begin{theorem}[Preservation]
If $\hat \Gamma \vdash \hat e_A: \hat \tau_A~\kw{with} \varepsilon_A$ and $\hat e_A \longrightarrow \hat e_B~|~\varepsilon$, then $\hat \tau_B <: \hat \tau_A$ and $\varepsilon_B \cup \varepsilon \subseteq \varepsilon_A$.
\end{theorem}

\begin{proof} By induction on $\hat \Gamma \vdash \hat e_A: \hat \tau_A~\kw{with} \varepsilon_A$, and then on $\hat e_A \longrightarrow \hat e_B~|~\varepsilon$. \\

\textit{Case:} \textsc{$\varepsilon$-Import}. Then $e_A = \import{\varepsilon}{x}{\hat e}{e}$. If the reduction rule used was \textsc{E-Import1} then the result follows by applying the inductive hypothesis to $\hat e$.

Otherwise $\hat e$ is a value and the reduction used was \textsc{E-Import2}. The following are true:
\begin{enumerate}
	\setlength\itemsep{-0.7em}
	\item $e_A = \kwa{import}(\varepsilon)~x = \hat v~\kw{in} e$
	\item $\hat \Gamma \vdash e_A: \kwa{annot}(\tau, \varepsilon)~\kw{with} \varepsilon \cup \varepsilon_1$
	\item $\kwa{import}(\varepsilon)~x = \hat v~\kw{in} e \longrightarrow [\hat v/x]\kwa{annot}(e, \varepsilon)~|~\varnothing$
	\item $\hat \Gamma \vdash \hat v: \hat \tau~\kw{with} \varnothing$
	\item $\varepsilon = \kwa{effects}(\hat \tau)$
	\item $\kwa{ho \hyphen safe}(\hat \tau, \varepsilon)$
	\item $x: \kwa{erase}(\hat \tau) \vdash e: \tau$
\end{enumerate}

\noindent
Apply the annotation lemma with $\Gamma = \varnothing$ to get $\hat \Gamma, x: \hat \tau \vdash \kwa{annot}(e, \varepsilon): \kwa{annot}(\tau, \varepsilon)~\kw{with} \varepsilon$. From assumption (4) we know $\hat \Gamma \vdash \hat v: \hat \tau~\kw{with} \varnothing$, and so the substitution lemma may be applied, giving $\hat \Gamma \vdash [\hat v/x]\kwa{annot}(e, \varepsilon): \kwa{annot}(\tau, \varepsilon)~\kw{with} \varepsilon$. By canonical forms, $\varepsilon_1 = \varepsilon_C = \varnothing$. Then $\varepsilon_B = \varepsilon = \varepsilon_A \cup \varepsilon_C$. By examination, $\tau_A = \tau_B = \kwa{annot}(\tau, \varepsilon)$.
\end{proof}

We can now combine Progress and Preservation into the Soundness theorem for $\epscalc$. The proof of multi-step soundness in $\epscalc$ is identical to the proof in $\opercalc$.

\begin{theorem}[Soundness]
If $\hat \Gamma \vdash \hat e_A: \hat \tau_A~\kw{with} \varepsilon_A$ and $\hat e_A$ is not a value, then $e_A \longrightarrow e_B~|~\varepsilon$, where $\hat \Gamma \vdash e_B: \hat \tau_B~\kw{with} \varepsilon_B$ and $\hat \tau_B <: \hat \tau_A$ and $\varepsilon_B \cup \varepsilon \subseteq \varepsilon_A$.
\end{theorem}

\begin{theorem}[Multi-step Soundness]
If $\hat \Gamma \vdash \hat e_A: \hat \tau_A~\kw{with} \varepsilon_A$ and $e_A \longrightarrow^{*} e_B~|~\varepsilon$, where $\hat \Gamma \vdash e_B: \hat \tau_B~\kw{with} \varepsilon_B$ and $\hat \tau_B <: \hat \tau_A$ and $\varepsilon_B \cup \varepsilon \subseteq \varepsilon_A$.
\end{theorem}






