\chapter{Effect Calculi}

In this section we introduce a pair of langauges: the operation calculus $\opercalc$ and the capability calculus $\epscalc$. $\opercalc$ is an extension of $\stlc$ with primitive capabilities and their operations. Every function is annotated with what effects it might incur. The static rules of $\opercalc$ ascribe a type-and-effect to programs. They are type-sound, but also \textit{effect-sound}, which is a new notion we introduce.

We then extend $\opercalc$ to obtain $\epscalc$, which allows the nesting of unannotated code inside annotated code using a new $\kwa{import}$ construct. An effect-sound inference can be made about what effects the unannotated code might incur by inspecting those capabilities passed into the unannotated code.

The high-level motivating examples in this section written in a \textit{Wyvern}-like language. Wyvern is a capability-safe, pure, object-oriented language with first-class modules. A more thorough discussion of how Wyvern programs might be translated into the calculi is given in Chapter 4.

\section{$\opercalc$: Operation Calculus}

The operation calculus $\opercalc$ is an extension of $\stlc$ with primitive capabilities and operations which can be invoked on them. A primitive capability encapsulates some system resource. For simplicity, we conflate the two and use the term resource to refer to primitive capabilities. An effect is a particular operation invoked on some resource. Every function-type is annotated with what effects may be incurred during execution of the function body. The static rules of $\opercalc$ can inspect this information and ascribe a set of effects to a piece of code, giving a static approximation to the runtime effects. 

\subsection{$\opercalc$ Grammar}

In addition to the forms from $\stlc$, $\opercalc$ contains two new forms: resource literals and operation calls. The grammar for $\opercalc$ is summarised in Figure \ref{fig:opercalc_grammar}.

\begin{figure}[h]
\vspace{-5pt}

\[
\begin{array}{lll}

\begin{array}{lllr}

e & ::= & ~ & exprs: \\
	& | & x & variable \\
	& | & v & value \\
	& | & e ~ e & application \\
	& | & e.\pi & operation \\
	&&\\

v & ::= & ~ & values: \\
	& | & r & resource~literal \\
	& | & \lambda x: \tau.e & abstraction \\
	&&\\

\end{array}

\end{array}
\]

\vspace{-7pt}
\caption{Grammar for $\opercalc$.}
\label{fig:opercalc_grammar}
\end{figure}

A resource literal $r$ is a variable drawn from a fixed set $R$. Resources cannot be created or destroyed at runtime; they simply exist throughout the duration of the program. They resource those initial capabilities passed into the program which endow operations upon some system resources. For example, a $\kwa{File}$ or $\kwa{Socket}$ might provide read-and-write operations on a particular file or socket in the system environment.

An operation call $e.\pi$ represents some primitive operation invoked on the resource described by $e$. For example, we might invoke the $\kwa{open}$ operation on a $\kwa{File}$ resource, which would be the operation call $\kwa{File.open}$. Operations are drawn from a fixed set $\Pi$. Like resources, they cannot be created or destroyed at runtime.

An effect is a pair $(r, \pi) \in R \times \Pi$. Sets of effects are denoted $\varepsilon$; a rule for them is given in Figure \ref{fig:opercalc_fx}. As a shorthand, we write $r.\pi$ instead of $(r, \pi)$. Effects should be distinguished from operation calls: an operation call is the invocation of a particular operation on a particular resource in a program, while an effect is a mathematical object describing this behaviour.

\begin{figure}[h]
\vspace{-5pt}

\[
\begin{array}{lll}

\begin{array}{lllr}

\varepsilon & ::= & ~ & effects: \\
	& | & \{ \overline{r.\pi} \} & effect~set \\
	&&\\

\end{array}

\end{array}
\]

\vspace{-7pt}
\caption{Grammar for effects in $\opercalc$.}
\label{fig:opercalc_fx}
\end{figure}

Because the static rules of $\opercalc$ are only interested in where effects are incurred, we have chosen not to model the semantics of particular operations. In practice, operations might take arguments of particular types and return a value of a particular type; for example, $\kwa{File.write(``msgToWrite'')}$. We make the assumption that all operations are null-ary and return a value. Furthermore, all operations are assumed to be valid on all resources.

An updated definition of $\kwa{substitution}$ is given in Figure \ref{fig:opercalc_sub_defn}. The new cases are straightforward, but we make an extra restriction in $\opercalc$ that a variable may only be substituted for a value. This restriction is imposed because if a variable can be repalced with an arbitrary expression, then we might also be introducing arbitrary effects, which violates the preservation of effects. Because we only consider the call-by-value strategy, in which expressions are reduced to values before being bound to names, this restriction is no issue.

\begin{figure}[h]

\bm{$\kwa{substitution :: e \times v \times v \rightarrow e}$}

\begin{itemize}
	\setlength\itemsep{-0.7em}
	\item[] $[v/y]x = v$, if $x = y$
	\item[] $[v/y]x = x$, if $x \neq y$
	\item[] $[v/y](\lambda x: \tau. e) = \lambda x: \tau.[v/y]e$, if $y \neq x$ and $y$ does not occur free in $e$
	\item[] $[v/y](e_1~e_2) = ([v/y]e_1)([v/y]e_2)$
	\item[] $[v/y](e_1.\pi) = ([v/y]e_1).\pi$
\end{itemize}

\vspace{-7pt}
\caption{Substitution function in $\opercalc$.}
\label{fig:opercalc_sub_defn}
\end{figure}

\subsection{$\opercalc$ Dynamic Rules}

During reduction an operation call may be evaluated. When this happens, a runtime effect is said to have taken place. The form of the single-step reduction judgement is now $e \longrightarrow e~|~\varepsilon$ to reflect this fact. The resulting pair is the reduced expression, and the set of effects incurred as a result. In the case of single-step reduction, this is at most a single effect. The judgements for single-step reductions are summarised in Figure \ref{fig:opercalc_singlestep}.

\begin{figure}[h]

\noindent
\fbox{$e \longrightarrow e~|~\varepsilon$}

\[
\begin{array}{c}

\infer[\textsc{(E-App1)}]
	{e_1 e_2 \longrightarrow e_1'~ e_2~|~\varepsilon}
	{e_1 \longrightarrow e_1'~|~\varepsilon}
	~~~~~~
\infer[\textsc{(E-App2)}]
	{v_1 ~ e_2 \longrightarrow v_1 ~ e_2'~|~\varepsilon} 
	{e_2 \longrightarrow e_2'~|~\varepsilon}
~~~~~~
\infer[\textsc{(E-App3)}]
	{ (\lambda x: \tau. e) v_2 \longrightarrow [ v_2/x] e~|~\varnothing }
	{}\\[4ex]
	
\infer[\textsc{(E-OperCall1)}]
	{ e.\pi \longrightarrow  e'.\pi~|~\varepsilon }
	{ e \rightarrow  e'~|~\varepsilon}
		
	~~~~~~
	
\infer[\textsc{(E-OperCall2)}]
	{r.\pi \longrightarrow \kwa{unit}~|~\{ r.\pi \} }
	{}
	 \\[4ex]
	 
\end{array}
\]


\vspace{-7pt}
\caption{Single-step reductions in $\opercalc$.}
\label{fig:opercalc_singlestep}
\end{figure}

\textsc{E-App1} and \textsc{E-App2} incur whatever is the effect of reducing their subexpressions. \textsc{E-App3} incurs effects when it substitutes the actual value of the argument for its formal name in the function body. The first new single-step rule is \textsc{E-OperCall1}, which reduces the receiver of an operation call. The effects incurred are the effects incurred by reducing the receiver. The other new rule is \textsc{E-OperCall2}, which is reducing an operation call on a resource literal; then $r.\pi$ incurs the effect-set $\{ r.\pi \}$.

From the judgements for single-step reduction we define judgements for multi-step reductions in Figure \ref{fig:opercalc_multistep_defn}. A multi-step reduction consists of zero or more single-steps. The resulting effect-set is the union of all the effect-sets produced by the intermediate single-steps.

\begin{figure}[h]

\noindent
\fbox{$ e \longrightarrow^{*}  e~|~\varepsilon$}

\[
\begin{array}{c}

\infer[\textsc{(E-MultiStep1)}]
	{ e \rightarrow^{*}  e~|~\varnothing}
	{}
~~~
\infer[\textsc{(E-MultiStep2)}]
	{ e \rightarrow^{*}  e'~|~\varepsilon}
	{ e \rightarrow  e'~|~\varepsilon} \\[3ex]
	
\infer[\textsc{(E-MultiStep3)}]
	{ e \rightarrow^{*}  e''~|~\varepsilon_1 \cup \varepsilon_2}
	{ e \rightarrow^{*}  e'~|~\varepsilon_1 &  e' \rightarrow^{*}  e''~|~\varepsilon_2}
\end{array}
\]

\vspace{-7pt}
\caption{Multi-step reductions in $\opercalc$.}
\label{fig:opercalc_multistep_defn}
\end{figure}

 
 
 
 
 
 
\subsection{$\opercalc$ Static Rules}

A grammar for the types of $\opercalc$ is given in Figure \ref{fig:opercalc_types}. Typing contexts are the same as in $\stlc$. The base types are sets of resources, denoted $\{ \bar r \}$. If an expression is associated with type $\{ \bar r \}$, then evaluating $e$ will reduce to one of the resource literals $r \in \bar r$ (assuming it terminates). There is a single type-constructor, $\rightarrow_{\varepsilon}$. If an expression is associated with type $\tau_1 \rightarrow_{\varepsilon} \tau_2$, then it is a function which takes a $\tau_1$ as input, returns a $\tau_2$ as output, and during execution incurs no more than those effects in $\varepsilon$. If an effect $r.\pi \in \varepsilon$, then it is not guaranteed that $r.\pi$ will occur during function execution; but if $r.\pi \notin \varepsilon$, then it cannot occur during function execution.

\begin{figure}[h]
\vspace{-5pt}

\[
\begin{array}{lll}

\begin{array}{lllr}

\tau & ::= & ~ & types: \\
		& | & \{ \bar r \} \\
		& | & \tau \rightarrow_{\varepsilon} \tau \\ 
		&&\\
\end{array}

\begin{array}{lllr}

\Gamma & ::= & ~ & type~ctx: \\
				& | & \varnothing \\
				& | & \Gamma, x: \tau \\
				&&\\
\end{array}

\end{array}
\]

\vspace{-7pt}
\caption{Grammar for types in $\opercalc$.}
\label{fig:opercalc_types}
\end{figure}

The only way for code to gain authority over a capability is to be given that capability as a function argument. Because functions in $\opercalc$ must have their input types annotated with the effect-set they might incur on the arrow, we say that $\opercalc$ programs are annotated.

Given a program, we want to know what set of effects might be incurred when it is executed. For example, $(\lambda c: \{ \kwa{File, Socket} \}. c.write) \File$ incurs $\kwa{File.write}$ when executed. Judgements in the type system of $\opercalc$ therefore ascribe a type and a set of effects to a piece of code. The judgement form is $\Gamma \vdash e: \tau~\kw{with} \varepsilon$, which can be read as meaning that $e$ will successively reduce to terms of type $\tau$ and incur no more effects than those in $\varepsilon$. Static rules for $\opercalc$ are given in Figure \ref{fig:opercalc_static_rules}.

\begin{figure}[h]

\noindent
\fbox{$\Gamma \vdash e: \tau~\kw{with} \varepsilon$}

\[
\begin{array}{c}

\infer[\textsc{($\varepsilon$-Var)}]
	{ \Gamma, x:\tau \vdash x: \tau~\kw{with} \varnothing }
	{}
	
	~~~
	
\infer[\textsc{($\varepsilon$-Resource)}]
 	{ \Gamma, r: \{ r \} \vdash r : \{ r \}~\kw{with} \varnothing }
 	{} \\[3ex]
 	
 	~~~
	\infer[\textsc{($\varepsilon$-Abs)}]
	{ \Gamma \vdash \lambda x:\tau_2 . e : \tau_2 \rightarrow_{\varepsilon_3} \tau_3~\kw{with} \varnothing }
	{ \Gamma, x: \tau_2 \vdash e: \tau_3~\kw{with} \varepsilon_3 }
	
	~~~
	
\infer[\textsc{($\varepsilon$-App)}]
	{ \Gamma \vdash e_1~e_2 : \tau_3~\kw{with} \varepsilon_1 \cup \varepsilon_2 \cup \varepsilon  }
	{ \Gamma \vdash e_1: \tau_2 \rightarrow_{\varepsilon} \tau_3~\kw{with} \varepsilon_1 & \Gamma \vdash e_2: \tau_2~\kw{with} \varepsilon_2 } \\[3ex]
	
\infer[\textsc{($\varepsilon$-OperCall)}]
	{ \Gamma \vdash e.\pi: \kw{Unit} \kw{with} \{ \bar r.\pi \} }
	{ \Gamma \vdash e: \{ \bar r \} & \forall r \in \bar r \mid r: \{ r \} \in \Gamma & \pi \in \Pi } \\[3ex]

\infer[\textsc{($\varepsilon$-Subsume)}]
	{ \Gamma \vdash e: \tau' ~\kw{with} \varepsilon'}
	{ \Gamma \vdash e: \tau ~\kw{with} \varepsilon & \tau <: \tau' & \varepsilon \subseteq \varepsilon'}
\end{array}
\]


\vspace{-7pt}
\caption{Type-with-effect judgements in $\opercalc$.}
\label{fig:opercalc_static_rules}
\end{figure}

\textsc{$\varepsilon$-Var} approximates the runtime effects of a variable as $\varnothing$. \textsc{$\varepsilon$-Resource} does the same. Although a resource captures several effects (namely, every possible operation on itself), attempting to ``reduce'' a resource will incur no effects. For a similar reason, \textsc{$\varepsilon$-Abs} approximates the runtime effects of a function literal as $\varnothing$; although the ascribed type has an arrow with a set of effects, equivalent to the approximate effects of the function body. \textsc{$\varepsilon$-App} approximates a lambda application as incurring those effects from evaluating the subexpressions and the effects incurred by executing the body of the function to which the left-hand side evaluates. The effects of a function body are obtained from its arrow-type.

\textsc{$\varepsilon$-OperCall} approximates an operation call as: the effects of reducing the subexpression, and then the operation $\pi$ on every possible resource which that subexpression to which that subexpression might reduce. For example, consider $e.\pi$, where $\Gamma \vdash e: \{ \kwa{File, Socket} \}~\kw{with} \varnothing$. Then $e$ could evaluate to $\kwa{File}$, in which case the actual runtime effect is $\kwa{File.\pi}$, or it could evaluate to $\kwa{Socket}$, in which case the actual runtime effect is $\kwa{Socket.\pi}$. Determining which will actually happen is, in general, undecidable. The safe approximation then is to treat them both as happening. The type of an operation call is $\Unit$, which is the type of $\unit$. $\Unit$ is also a derived type, and $\vdash \unit: \Unit~\kw{with} \varnothing$ by a derived rule \textsc{$\varepsilon$-Unit}. Definitions for this are given in Chapter 4.

The last rule, \textsc{$\varepsilon$-Subsume}, only makes sense in the presence of subtyping rules. It says that the type can be narrowed or the effect-set widened in a judgement to produce a new judgement. The subtyping rules are given in Figure \ref{fig:opercalc_static_rules}.


\begin{figure}[h]
\vspace{-5pt}

\fbox{$\Gamma \vdash e: \tau~\kw{with} \varepsilon$}

\[
\begin{array}{c}

\infer[\textsc{(S-Arrow)}]
	{ \tau_1 \rightarrow_{\varepsilon} \tau_2 <: \tau_1' \rightarrow_{\varepsilon'} \tau_2' }
	{ \tau_1' <: \tau_1 & \tau_2 <: \tau_2' & \varepsilon \subseteq \varepsilon' }
~~~~~~
\infer[\textsc{(S-Resource)}]
	{ \{ \bar r_1 \} <: \{ \bar r_2 \} }
	{ r \in r_1 \implies r \in r_2 }

\end{array}
\]

\vspace{-7pt}
\caption{Subtyping judgements of $\opercalc$.}
\label{fig:opercalc_static_rules}
\end{figure}

The first subtyping rule is \textsc{S-Arrow}, which is similar to the rule for subtyping functions in $\stlc$. The only addition is that the effects of the subtype must be contained in the effects of the supertype, so that instances of the subtype can only incur effects the supertype's interface is expecting.

The other subtyping rule is \textsc{S-Resource}, which says a subset of resource sis also a subtype. To justify this rule, consider $\{ \bar r \} <: \{ \bar r_2 \}$. Any value with type $\{ \bar r_1 \}$ can reduce to any resource literal in $\bar r_1$, so to be compatible with type $\{ \bar r_2 \}$, the resource literals in $\bar r_1$ must also be in $\bar r_2$.

These rules let us determine what sort of effects might be incurred when a piece of code is executed. For example, consider $e = \kwa{(\lambda f: \{ File, Socket \}. f.write)~File}$. The judgement $\vdash e: \Unit~\kw{with} \{ \kwa{File.write, Socket.write} \}$ holds, which says that executing this piece of code might incur either of $\kwa{File.write}$ or $\kwa{Socket.write}$. A derivation for it is given in Figure \ref{fig:opercalc_tree}. To fit in one diagram, all resources and operations have been abbreviated to their first letter. Recall that $\unit$ is a derived form and $\Unit$ a derived type.

\begin{figure}[h]


    \begin{prooftree*}

    		\Infer0[\textsc{($\varepsilon$-Var)}]{f: \{ \kwa{F}, \kwa{S} \} \vdash f: \{ \kwa{F}, \kwa{S} \}}
    		
    		\Infer1[\textsc{($\varepsilon$-OperCall)}]{\kwa{f}: \{ \kwa{F}, \kwa{S} \} \vdash \kwa{f.w} : \Unit~\kw{with} \{ \kwa{F.w, S.w} \} }
    		
    		\Infer1[\textsc{($\varepsilon$-Abs)}]{ \lambda \kwa{f}: \{ \kwa{F}, \kwa{S} \}. \kwa{f.w} : \{ \kwa{F, S} \} \rightarrow_{\kwa{F.w, S.w}} \Unit~\kw{with} \varnothing }
    		
    
       \Infer0[\textsc{($\varepsilon$-Resource)}]{\vdash \kwa{F}: \{ \kwa{F} \}~\kw{with} \varnothing}
    
    		\Infer2[\textsc{($\varepsilon$-App)}]{ \vdash (\lambda \kwa{f}: \{ \kwa{F, S} \}. \kwa{f.write})~\kwa{F} : \Unit~\kw{with} \{ \kwa{F.w, S.w} \}  }
    		
 	\end{prooftree*}
 	
\vspace{-12pt}
\caption{Derivation tree for $(\lambda \kwa{f}: \{ \File, \kwa{Socket} \}.~\kwa{f.write})~\File$.}
\label{fig:opercalc_tree}
\end{figure}

These rules can be used to determine if a piece of code is safe. For example, a function which uses a logger might be $\kwa{e = \lambda l: File \rightarrow_{\kwa{File.append}} Unit.~l~unit}$. Applying the rules to the logger implementation $\kwa{l}$ gives an approximation to the effects it might incur. With that information, we can decide if it is safe to use that particular logger. For example, if $\kwa{l = \lambda f: \{ File \}.~f.read}$ then by \textsc{$\varepsilon$-Abs}, $~\vdash~\kwa{l}: \kw{ \{ File \} \rightarrow_{\kwa{File.read}} Unit} \kw{with} \varnothing$. We can see that applying this function will incur the $\kwa{File.read}$ function, alerting us that this code might be maliciuos. Furthermore, $\kwa{e~l}$ will not typecheck, because $\kwa{e}$ expects a function with $\kwa{File.append}$ on the arrow.


\subsection{$\opercalc$ Soundness}

To show the rules of $\opercalc$ are sound requires an appropriate notion of the static approximations being correct with respect to the reductions. Intuitively, if a static judgement like $\Gamma \vdash e: \tau~\kw{with} \varepsilon$ were correct, then successive reductions on $e$ should never produce effects not in $\varepsilon$. Adding this to our definition of soundness yields the following first definition.

\begin{theorem}[$\opercalc$ Soundness 1]
If $ \Gamma \vdash  e_A:  \tau_A~\kw{with} \varepsilon_A$ and $ e_A$ is not a value, then $e_A \longrightarrow e_B~|~\varepsilon$, where $ \Gamma \vdash e_B:  \tau_B~\kw{with} \varepsilon_B$ and $ \tau_B <:  \tau_A$ and $\varepsilon \subseteq \varepsilon_A$, for some $e_B, \varepsilon, \tau_B, \varepsilon_B$.
\end{theorem}

In this formulation, $\varepsilon_A$ is an approximation to what $e_A$ will do when executed. $e_A$ reduces to $e_B$, incurring the effects in $\varepsilon$, and $e_B$ can be typed in the same context $\Gamma$ with the type $\tau_B$ and effect-approximation $\varepsilon_B$. $\tau_B$ must be a subtype of $\tau_A$, and the runtime effects $\varepsilon$ must be contained in the original approximation $\varepsilon_A$, but no further information about $\varepsilon_B$ is stipulated.

Our approach to proving that multi-step reduction is sound will be to inductively appeal to the soundness of single-step reductions. This is tricky under the given definition of Soundness because it only relates the runtime effects to the approximation of the runtime effects \textit{before} reduction. There are no constraints on the runtime effects \textit{after} reduction. To accommodate a proof of multi-step soundness, we need a stronger version of soundness which relates the approximated effects before reduction ($\varepsilon_A$) to the approximated effects after reduction ($\varepsilon_B$).

First consider how the type after reduction relates to the type before reduction. In $\lambda$-calculi, the type after reduction can be the same or more specific (i.e. $\tau_B <: \tau_A$) than the type before reduction, but never less specific. The idea is that as we reduce the expression we gain more information about its precise type. Similarly, we want to allow for the approximation to get more specific after a reduction. To illustrate why, consider the function $\kwa{get} = \lambda x: \{ \kwa{File, Socket} \} .x$ and the program $\kwa{(get~File).write}$. In the context $\Gamma = \kwa{File: \{ File \}}$, the rule \textsc{$\varepsilon$-App} can be used to approximate the effects of $\kwa{(f~File).write}$ as $\{ \kwa{File.write, Socket.write} \}$. By \textsc{E-App3} we have the reduction $\kwa{(get~File).write} \longrightarrow \kwa{File.write}~|~\varnothing$. The same context can use \textsc{$\varepsilon$-OperCall} to approximate the reduced expression $\kwa{File.write}$ as $\{ \kwa{File.write} \}$; note how the approximation of effects is more precise after reduction. This example shows why the approximation after reduction ($\varepsilon_B$) should be a subset of the approximation before reduction ($\varepsilon_A$). By adding this premise we have our final definition of soundness.

\begin{theorem}[$\opercalc$ Single-step Soundness]
If $ \Gamma \vdash  e_A:  \tau_A~\kw{with} \varepsilon_A$ and $ e_A$ is not a value, then $e_A \longrightarrow e_B~|~\varepsilon$, where $ \Gamma \vdash e_B:  \tau_B~\kw{with} \varepsilon_B$ and $ \tau_B <:  \tau_A$ and $\varepsilon_B \cup \varepsilon \subseteq \varepsilon_A$, for some $e, \varepsilon, \tau_B, \varepsilon_B$.
\end{theorem}

Our approach to proving soundness wil be to show progress and preservation. These in turn rely on canonical forms and the substitution lemma, modified for $\opercalc$. The new version of canonical forms states that resource-typed values are resource literals, and any typing judgement of a value will approximate the runtime effects as $\varnothing$. This result is not true if the rule used is \textsc{$\varepsilon$-Subsume}, so the lemma statement excludes judgements which use that rule. Progress follows from Canonical Forms.

\begin{lemma}[$\opercalc$ Canonical Forms]
Unless the rule used is \textsc{$\varepsilon$-Subsume}, the following are true:
\begin{itemize}
	\setlength\itemsep{-0.7em}
	\item If $ \Gamma \vdash  v:  \tau~\kw{with} \varepsilon$ then $\varepsilon = \varnothing$.
	\item If $ \Gamma \vdash  v: \{ \bar r \}$ then $ v = r$ for some $r \in R$ and $\{ \bar r \} = \{ r \}$.
\end{itemize}
\end{lemma}

\begin{theorem}[$\opercalc$ Progress]
If $ \Gamma \vdash  e:  \tau~\kw{with} \varepsilon$ and $ e$ is not a value, then $ e \longrightarrow  e'~|~\varepsilon$, for some $e', \varepsilon$.
\end{theorem}

\begin{proof} By induction on $ \Gamma \vdash  e:  \tau~\kw{with} \varepsilon$, for $ e$ not a value. If the rule is \textsc{$\varepsilon$-Subsumption} it follows by inductive hypothesis. If $e$ has a reducible subexpression then reduce it. Otherwise use one of \textsc{$\varepsilon$-App3} or \textsc{$\varepsilon$-OperCall2}.
\end{proof}

To show preservation holds we need to know that type-and-effect safety, as it has been formulated in the definition of soundness, is preserved by the substitution in \textsc{E-App3}. As noted in the definition of $\kwa{substitution}$, variables can only be substituted for values in $\opercalc$. Canonical Forms tells us that any value will have its effects approximated as $\varnothing$ (unless $\varepsilon$-Subsume is used). Beyond this observation, the proof is routine.

\begin{lemma}[$\opercalc$ Substitution]
If $\Gamma, x: \tau' \vdash e: \tau~\kw{with} \varepsilon$ and $\Gamma \vdash v: \tau'~\kw{with} \varnothing$ then $\Gamma \vdash [v/x]e: \tau~\kw{with} \varepsilon$.
\end{lemma}

\begin{proof} By induction on the derivation of $\Gamma, x: \tau' \vdash e: \tau~\kw{with} \varepsilon$.
\end{proof}

With this lemma, we can prove the preservation theorem.

\begin{theorem}[$\opercalc$ Preservation]
If $\Gamma \vdash e_A: \tau_A~\kw{with} \varepsilon_A$ and $e_A \longrightarrow e_B~|~\varepsilon$, then $\tau_B <: \tau_A$ and $\varepsilon_B \cup \varepsilon \subseteq \varepsilon_A$, for some $e_B, \varepsilon, \tau_B, \varepsilon_B$.
\end{theorem}

\begin{proof} By induction on the derivation of $\Gamma \vdash e_A: \tau_A~\kw{with} \varepsilon_A$, and then the derivation of $e_A \longrightarrow e_B~|~\varepsilon$. Since $e_A$ can be reduced, we need only consider those rules which apply to non-values and non-variables. \\

\textit{Case:} \textsc{$\varepsilon$-App} Then $e_A = e_1 ~ e_2$ and $e_1: \tau_2 \rightarrow_{\varepsilon} \tau_3~\kw{with} \varepsilon_1$ and $\Gamma \vdash e_2: \tau_2~\kw{with} \varepsilon_2$. If the reduction rule used was \textsc{E-App1} or \textsc{E-App2}, then the result follows by applying the inductive hypothesis to $e_1$ and $e_2$ respectively. Otherwise the rule used was \textsc{E-App3}. Then $(\lambda x: \tau_2. e) v_2 \longrightarrow [ v_2/x] e~|~\varnothing$. By inversion on the typing rule for $\lambda x:  \tau_2. e$ we know $\Gamma, x:  \tau_2 \vdash  e:  \tau_3~\kw{with} \varepsilon_3$. By canonical forms, $\varepsilon_2 = \varnothing$ because $ e_2 =  v_2$ is a value. Then by the substitution lemma, $ \Gamma \vdash [ v_2/x] e :  \tau_3~\kw{with} \varepsilon_3$. By canonical forms, $\varepsilon_1 = \varepsilon_2 = \varnothing = \varepsilon_C$. Therefore $\varepsilon_A = \varepsilon_3 = \varepsilon_B \cup \varepsilon_C$.\\

\textit{Case:} \textsc{$\varepsilon$-OperCall}. Then $e_A = e_1.\pi$ and $ \Gamma \vdash e_1 : \{ \bar r \}~\kw{with} \varepsilon_1$. If the reduction rule used was \textsc{E-OperCall1} then the result follows by applying the inductive hypothesis to $ e_1$. Otherwise the reduction rule used was \textsc{E-OperCall2} and $v_1.\pi \longrightarrow \kwa{unit}~|~\{ r.\pi \}$. By assumption, $\Gamma \vdash v_1.\pi : \kwa{unit}~\kw{with} \{ r.\pi \}$, and by \textsc{$\varepsilon$-Unit}, $\Gamma \vdash \unit: \Unit~\kw{with} \varnothing$. Therefore, $\tau_B = \tau_A = \Unit$ and $\varepsilon \cup \varepsilon_B = \{ r.\pi \} = \varepsilon_A$.\\

\end{proof}

Our single-step soundness theorem now holds immediately by joining the progress and preservation theorems into one.

\begin{theorem}[$\opercalc$ Single-step Soundness]
If $ \Gamma \vdash  e_A:  \tau_A~\kw{with} \varepsilon_A$ and $ e_A$ is not a value, then $e_A \longrightarrow e_B~|~\varepsilon$, where $ \Gamma \vdash e_B:  \tau_B~\kw{with} \varepsilon_B$ and $ \tau_B <:  \tau_A$ and $\varepsilon_B \cup \varepsilon \subseteq \varepsilon_A$, for some $e_B, \varepsilon, \tau_B, \varepsilon_B$.
\end{theorem}
\begin{proof}
If $ e_A$ is not a value then the reduction exists by the progress theorem. The rest follows by the preservation theorem.
\end{proof}

Knowing that single-step reductions are sound, the soundness of multi-step reductions can be shown by inductively applying single-step soundness on their length.

\begin{theorem}[$\opercalc$ Multi-step Soundness]
If $ \Gamma \vdash  e_A:  \tau_A~\kw{with} \varepsilon_A$ and $e_A \longrightarrow^{*} e_B~|~\varepsilon$, where $\Gamma \vdash e_B: \tau_B~\kw{with} \varepsilon_B$ and $ \tau_B <: \tau_A$ and $\varepsilon_B \cup \varepsilon \subseteq \varepsilon_A$.
\end{theorem}

\begin{proof} By induction on the length of the multi-step reduction. If the length is 0 then $e_A = e_B$ and the result holds vacuously. If the length is $n+1$, then the first $n$-step reduction is sound by inductive hypothesis and the last step is sound by single-step soundness, so the entire $n+1$-step reduction is sound.
\end{proof}






\section{$\epscalc$: Capability Calculus}

$\opercalc$ requires every function to have its input type annotated --- if we relax this requirement, can a type system say anything useful about pieces of unannotated code? There are practical reasons to permit unannotated code in an effect-conscious language. Previous effect systems have been criticised for their verbosity \cite{rytz2012}, which might disincline a programmer from bothering to use them. Allowing structured, safe mixing of annotated and unannotated code can alleviate this problem by allowing develoeprs to rapidly prototype software in the unannotated sublanguage and then incrementally add effect annotations as they are needed, giving a trade-off between convenience and safety.

In general, reasoning about unannotated code is difficult because there are no constraints on what effects might be incurred. Figure \ref{fig:unannotated_reasoning} demonstrates the issue: $\kwa{someMethod}$ takes a function as input and executes it, but the effects of $\kwa{f}$ depend on the particular implementation passed to $\kwa{someMethod}$. Without more information, such as extra constraints on the problem, more annotations, or a more complex type system, there is no way to know what effects might be incurred by $\kwa{someMethod}$.

\begin{figure}[h]
\begin{lstlisting}
def someMethod(f: Unit $\rightarrow$ Unit):
   f()
\end{lstlisting}
\vspace{-7pt}
\caption{What effects can $\kwa{someMethod}$ incur?}
\label{fig:unannotated_reasoning}
\end{figure}

A capability-safe design can help us: if the capabilities exercised by the unannotated code are passed in from an annotated environment, then whatever effects they capture are a conservative upper-bound on what can happen in the unannotated code. To demonstrate, consider a developer who wants to decide whether the modele in Figure \ref{fig:cc_motivation}. The module is a $\kwa{Logger}$ which possesses two capabilities $\kwa{File}$ and $\kwa{Socket}$, and provides a single unannotated function $\kwa{log}$.

\begin{figure}[h]
\begin{lstlisting}
resource module Logger
require File
require Socket

def log(x: Unit): Unit
   ...
\end{lstlisting}
\vspace{-7pt}
\caption{What effects can $\kwa{someMethod}$ incur?}
\label{fig:cc_motivation}
\end{figure}

What effects will be incurred if $\kwa{Logger.log}$ is invoked? One approach is to examine its source code, but this is tedious and in many real-world situations the source code may not be available. A capability-based argument can do better: the only authority which $\kwa{Logger}$ can exercise is that which has been explicitly given. Here, the $\kwa{Logger}$ can be explicitly given a $\kwa{File}$ and a $\kwa{Socket}$, so $\kwa{ \{ \kwa{File.*, Socket.*} \} }$ is a safe upper bound on the effects of $\kwa{Logger}$. Knowing $\kwa{Logger}$ could be manipulating sockets, a developer may decide this implementation cannot be trusted and choose not to use it.

The reasoning we employed only required us to examine the interface of the unannotated code for the capabilities that might be passed into it. To model this situation in $\epscalc$, we add a new $\kwa{import}$ expression which selects the authority the unannotated code is allowed to use. The static rules can then approximate the effects of the unannotated code as being those captured by its imports. That capability-safe design enables this inference is the key result of this report. We spend the rest of this chapter formalising the idea and proving it sound.

\subsection{$\epscalc$ Grammar}

The grammar of $\epscalc$ is split into rules for annotated code and analogous rules for unannotated code. To distinguish the two we put a hat above annotated types, expressions, and contexts: $\hat e$, $\hat \tau$, and $\hat \Gamma$ are annotated, while $e$, $\tau$, and $\Gamma$ are unannotated. The rules for unannotated programs and their types are given in Figure \ref{fig:epscalc_unannotated_grammar}.

\begin{figure}[h]
\vspace{-5pt}

\[
\begin{array}{lll}

\begin{array}{lllr}
e & ::= & ~ & exprs: \\
	& | & x & variable \\
	& | & v & value \\
	& | & e ~ e & application \\
	& | & e.\pi & operation \\
	&&\\

v & ::= & ~ & values: \\
	& | & r & resource~literal \\
	& | & \lambda x: \tau.e & abstraction \\
	&&\\
\end{array}

\begin{array}{lllr}

\tau & ::= & ~ & types: \\
		& | & \{ \bar r \} \\
		& | & \tau \rightarrow \tau \\ 
		&&\\

\Gamma & ::= & ~ & type~ctx: \\
				& | & \varnothing \\
				& | & \Gamma, x: \tau \\
				&&\\
				
\end{array}

\end{array}
\]

\vspace{-7pt}
\caption{Effect calculus.}
\label{fig:epscalc_unannotated_grammar}
\end{figure}

The rules are much the same as in $\opercalc$, but the sole type-constructor $\rightarrow$ is not annotated with a set of effects. If an expression is associated with the type $\tau_1 \rightarrow \tau_2$, it should be taken to mean that the expression is a function which, given a $\tau_1$, will return a $\tau_2$. The type says nothing about what effects may or may not be incurred during execution. Unannotated types $\tau$ are built using $\rightarrow$ and sets of resources $\{ \bar r \}$. An unannotated context $\Gamma$ maps variables to unannotated types.

Rules for annotated programs and their types are given in Figure \ref{fig:epscalc_annotated_grammar}. Except for the new $\kwa{import}$ expression, the rules for annotated programs are the same as in $\opercalc$. Annotated types $\hat \tau$ are built using the type constructor $\rightarrow_{\varepsilon}$ and sets of resources $\{ \bar r \}$. An annotated context $\hat \Gamma$ maps variables to annotated types.

\begin{figure}[h]
\vspace{-5pt}

\[
\begin{array}{lll}

\begin{array}{lllr}

\hat e & ::= & ~ & labelled~exprs: \\
	& | & x \\
	& | & \hat v \\
	& | & \hat e ~ \hat e \\
	& | & \hat e.\pi \\
	& | & \kwa{import}(\varepsilon)~x = \hat e~\kwa{in}~e & import \\
	&&\\

\hat v & ::= & ~ & labelled~values: \\
	& | & r \\
	& | & \lambda x: \hat \tau.\hat e \\
	&&\\

\end{array}

& ~~~~~~~~&

\begin{array}{lllr}

\hat \tau & ::= & ~ & labelled ~types: \\
		& | & \{ \bar r \} \\
		& | & \hat \tau \rightarrow_{\varepsilon} \hat \tau \\
		&&\\

\hat \Gamma & ::= & ~ & labelled~type~ctx:\\
				& | & \varnothing \\
				& | & \hat \Gamma, x: \hat \tau \\
				&&\\

\end{array}

\end{array}
\]

\vspace{-7pt}
\caption{Effect calculus.}
\label{fig:epscalc_annotated_grammar}
\end{figure}

$\kwa{import}$ introduces a name $x$ with annotated definition $\hat e$ into a body of unannotated code $e$. $\varepsilon$ is the authority which $e$ is allowed to exercise, so any resources and operation calls used in $e$ must be declared in $\varepsilon$. The only way to nest unannotated code inside annotated code is to use $\kwa{import}$. It is not possible to nest annotated code inside unannotated code, because of the general difficulty of reasoning about what the unannotated code may do. We will not be interested in unannotated programs, unless they appear inside an $\kwa{import}$ expression.

\subsection{$\epscalc$ Dynamic Rules}

Different approaches might be taken to define the small-step semantics of $\epscalc$. One way is to define reductions for both annotated and unannotated programs, but this clutters the formalism with irrelevant, uninteresting rules. Another is to define reductions for either of the two, and translate programs into the appropriate form before executing them. Because our static rules focus on what can be said about unannotated code nested inside annotated code, we take this second approach: reductions are defined on annotated forms, and unannotated forms nested inside annotated code are transformed at runtime.

Excluding $\kwa{import}$, the annotated sublanguage of $\epscalc$ is the same as $\opercalc$, so we can take the reduction rules of $\opercalc$ to be reduction rules in $\epscalc$. For brevity, they are not restated.

Rules new to $\epscalc$ will be for reducing $\kwa{import}$ expressions. The idea is that whenever a piece of unannotated code $e$ is encountered inside annotated code, the surrounding $\kwa{import}$ will select its authority $\varepsilon$, so we can annotate $e$ with $\varepsilon$ to wrangle it into a form that can be further reduced by the reduction rules. To this end, we define$\annot{e}{\varepsilon}$ in Figure \ref{fig:annot_defn}, which recursively annotates the parts of $e$ with $\varepsilon$. There are versions of $\kwa{annot}$ defined for expressions and types. We will need to annotate contexts later, so the definition is given here.

\begin{figure}[h]
\vspace{-5pt}

$\bm{\kwa{annot :: e \times \varepsilon \rightarrow \hat e}}$

\begin{itemize}
	\setlength\itemsep{-0.7em}
	\item[] $\annot{r}{\_} = r$
	\item[] $\annot{\lambda x: \tau_1 . e}{\varepsilon} = \lambda x: \annot{\tau_1}{\varepsilon} . \annot{e}{\varepsilon}$
	\item[] $\annot{e_1~e_2}{\varepsilon} = \kwa{annot}(e_1, \varepsilon)~\kwa{annot}(e_2, \varepsilon)$
	\item[] $\annot{e_1.\pi}{\varepsilon} = \annot{e_1}{\varepsilon}.\pi$
\end{itemize}
	
$\bm{\kwa{annot :: \tau \times \varepsilon \rightarrow \hat \tau}}$

\begin{itemize}
	\setlength\itemsep{-0.7em}
	\item[] $\annot{\{ \bar r \}}{\_} = \{ \bar r \}$
	\item[] $\annot{\tau \rightarrow \tau}{\varepsilon} = \tau \rightarrow_{\varepsilon} \tau$.	
\end{itemize}

$\bm{\kwa{annot :: \Gamma \times \varepsilon \rightarrow \hat \Gamma}}$

\begin{itemize}
	\setlength\itemsep{-0.7em}
	\item[] $\annot{\varnothing}{\_} = \varnothing$
	\item[] $\annot{\Gamma, x: \tau}{\varepsilon} = \annot{\Gamma}{\varepsilon}, x: \annot{\tau}{\varepsilon}$
\end{itemize}

\vspace{-7pt}
\caption{Definitions of $\kwa{annot}$ and $\kwa{erase}$.}
\label{fig:annot_defn}
\end{figure}

It is worth mentioning that $\kwa{annot}$ operates on a purely syntatic level. Nothing in the definition will stop you annotating a program with something silly, so every use of $\kwa{annot}$ must be justified.

Finally, before giving the dynamic rules we must update $\kwa{substitution}$. Because our dynamic rules are defined on annotated programs, so too will $\kwa{substitution}$ be defined. The definition is the same from $\opercalc$, with the same restriction that variables can only be replaced with values; however, a new case for $\kwa{import}$ is needed. The new case is given in Figure \ref{fig:epscalc_sub_defn}.

\begin{figure}[h]

\bm{$\kwa{substitution :: \hat e \times \hat v \times \hat v \rightarrow \hat e}$}

\begin{itemize}
	\setlength\itemsep{-0.7em}
	\item[] $[\hat v/y](\import{\varepsilon}{x}{\hat e}{e}) = \import{\varepsilon}{x}{[\hat v/y]\hat e}{e}$
\end{itemize}

\vspace{-7pt}
\caption{New case for $\kwa{substitution}$ in $\epscalc$.}
\label{fig:epscalc_sub_defn}
\end{figure}

The new single-step reductions on $\kwa{import}$ expressions are given in \ref{fig:opercalc_reductions}. \textsc{E-Import1} reduces the definition of the capability being imported. If the capability being imported is a value, then \textsc{E-Import2} annotates $e$ with the authority $\varepsilon$; this is $\annot{e}{\varepsilon}$. The name of the capability $x$ is then replaced with its definition $\hat v$; this is $[\hat v/x]\annot{e}{\varepsilon}$. The single-step incurs no effects.


\begin{figure}[h]

\noindent
\fbox{$\hat e \longrightarrow \hat e~|~\varepsilon$}

\[
\begin{array}{c}
\infer[\textsc{(E-Import1)}]
	{\kwa{import}(\varepsilon)~x = \hat e~\kw{in} e \longrightarrow \kwa{import}(\varepsilon)~x = \hat e'~\kw{in} e~|~\varepsilon'}
	{\hat e \longrightarrow \hat e'~|~\varepsilon'}\\[4ex]

\infer[\textsc{(E-Import2)}]
	{\kwa{import}(\varepsilon)~x = \hat v~\kw{in} e \longrightarrow [\hat v/x]\kwa{annot}(e, \varepsilon)~|~\varnothing}
	{}

\end{array}
\]


\vspace{-7pt}
\caption{New single-step reductions in $\epscalc$.}
\label{fig:opercalc_reductions}
\end{figure}

Multi-step reductions in $\epscalc$ are defined the same as in $\opercalc$. For brevity, they are not restated.

















\subsection{$\epscalc$ Static Rules}

Our main goal in this section is to introduce the rule for typing $\kwa{import}$ expressions. This is complicated, so we build up to it.

Firstly, since a term might be annotated or unannotated, we need to be able to recognise when either is well-typed. Since the annotated subset of $\epscalc$ contains $\opercalc$, all the $\opercalc$ rules apply, with different notation: we put hats on everything to signify that a typing judgement is being made about annotated code inside an annotated context. This looks like $\hat \Gamma \vdash \hat e: \hat \tau~\kw{with} \varepsilon$. Except for this change in notation the rules are the same, so we shall not repeat them.

We do not reason about the effects of unannotated code directly, so judgements about them take the form $\Gamma \vdash e: \tau$. The subtyping judgement for unannotated code takes the form $\tau <: \tau$. A summary of these typing and subtyping rules is given in \ref{fig:unannotated_static_rules}; each is analogous to some rule in $\opercalc$, but the parts relating to effects have been removed.

\begin{figure}[h]

\fbox{$\Gamma \vdash e: \tau$}

\[
\begin{array}{c}


\infer[\textsc{(T-Var)}]
	{\Gamma, x: \tau \vdash x: \tau}
	{}
~~~~~~
\infer[\textsc{(T-Resource)}]
	{\Gamma, r: \{ r \} \vdash r : \{ r \}}
	{}

~~~~~~
\infer[\textsc{(T-Abs)}]
	{\Gamma \vdash \lambda x: \tau_1.e : \tau_1 \rightarrow \tau_2}
	{\Gamma, x: \tau_1 \vdash e: \tau_2}\\[4ex]
	
\infer[\textsc{(T-App)}]
	{\Gamma \vdash e_1~e_2: \tau_3}
	{\Gamma \vdash e_1: \tau_2 \rightarrow \tau_3 & \Gamma \vdash e_2: \tau_2}
~~~~~~
\infer[\textsc{(T-OperCall)}]
	{\Gamma \vdash e.\pi: \kwa{Unit}}
	{\Gamma \vdash e: \{ \bar r \}}

\end{array}
\]



\fbox{$\tau <: \tau$}

\[
\begin{array}{c}

\infer[\textsc{(S-Arrow)}]
	{ \tau_1 \rightarrow \tau_2 <: \tau_1' \rightarrow \tau_2' }
	{ \tau_1' <: \tau_1 & \tau_2 <: \tau_2' }
	~~~
\infer[\textsc{(S-Resources)}]
	{ \{ \bar r_1 \} <: \{ \bar r_2 \} }
	{ \{ \bar r_1 \} \subseteq \{ \bar r_2 \} }

\end{array}
\]

\vspace{-7pt}
\caption{(Sub)typing judgements for the unannotated sublanguage of $\epscalc$}
\label{fig:unannotated_static_rules}
\end{figure}

The only way to approximate what effects might be incurred by some unannotated code is to encapsulate it with an $\kwa{import}$ expression and type-and-effect-check the $\kwa{import}$. For the rest of this section we are going to build up to the final definition of this rule.

To begin, typing $\import{\varepsilon}{x}{\hat v}{e}$ in a context $\hat \Gamma$ requires us to know that the imported capability $\hat e$ is well-typed, so we should add the premise $\hat \Gamma \vdash \hat e: \hat \tau~\kw{with} \varepsilon_1$. Since $x = \hat e$ is an import, it can be used throughout $e$, but we do not want $e$ to exercise ambient authority, so whatever capabilities are used must be selected by the $\kwa{import}$ expression; therefore, we require that $e$ can be typechecked using only the binding $x: \hat \tau$. However, $e$ is unannotated and $\hat \tau$ is annotated, so there is no rule for typechecking unannotated code in an annotated context. To get around this, we define a function $\kwa{erase}$ which removes the annotations from a type; a definition is given in Figure \ref{fig:erase_defn}. We can then add $x: \erase{\hat \tau} \vdash e: \tau$ as a premise.

\begin{figure}[h]
\vspace{-5pt}

$\bm{\kwa{erase :: \hat \tau \rightarrow \tau}}$
\begin{itemize}
	\setlength\itemsep{-0.7em}
	\item[] $\erase{\{ \bar r \}}$
	\item[] $\erase{\hat \tau_1 \rightarrow_{\varepsilon} \hat \tau_2} = \erase{\hat \tau_1} \rightarrow \erase{\hat \tau_2}$
\end{itemize}


\vspace{-7pt}
\caption{Definitions of $\kwa{annot}$ and $\kwa{erase}$.}
\label{fig:erase_defn}
\end{figure}

Since $\import{\varepsilon}{x}{\hat v}{e} \longrightarrow [\hat v/x]\annot{e}{\varepsilon}$, then it is sensible that the ascribed type would be $\annot{\tau}{\varepsilon}$: the type of the unannotated code, annotated with the selected authority $\varepsilon$. The approximation of the effects of the $\kwa{import}$ is $\varepsilon \cup \varepsilon_1$; the former comes from reducing the imported capability (which happens prior to executing of the $\kwa{import}$) and the latter contains all the effects which the unannotated code is allowed to incur.

The first version of \textsc{$\varepsilon$-Impotr} is given in Figure \ref{fig:import_rule_1}.


\begin{figure}[h]

\fbox{$\tau <: \tau$}

\[
\begin{array}{c}

\infer[\textsc{($\varepsilon$-Import1)}]
	{ \hat \Gamma \vdash \import{\varepsilon}{x}{\hat e}{e}: \kwa{annot}(\tau, \varepsilon)~\kw{with} \varepsilon \cup \varepsilon_1 }
	{ \hat \Gamma \vdash \hat e: \hat \tau~\kw{with} \varepsilon_1 & x: \kwa{erase}(\hat \tau) \vdash e: \tau }

\end{array}
\]
\vspace{-7pt}
\caption{A first rule for type-and-effect checking $\kwa{import}$ expressions.}
\label{fig:import_rule_1}
\end{figure}

At the moment there is no relation between $\varepsilon$ --- the effects which $e$ is allowed to incur --- and those effects captured by the imported capability. Consider $\hat e = \import{\varnothing}{x}{\File}{\kwa{x.write}}$, which imports a $\File$ and writes to it, but declares its authority as $\varnothing$. According to \textsc{$\varepsilon$-Import1}, $\vdash \hat e: \Unit~\kw{with} \varnothing$, but this is clearly wrong. We need to constrain the imported capability to only capture effects in $\varepsilon$. To this end we define a function $\kwa{effects}$, which collects the set of effects that an annotated type captures. A first definition is given in Figure \ref{fig:fx_defn}. With it, we can add an extra premise $\kwa{effects}(\hat \tau) \subseteq \varepsilon$ which formalises the idea that any capability exercised by $e$ must be selected in $\varepsilon$. The updated rule is given in Figure \ref{fig:import_rule_2}.

\begin{figure}[h]

$\bm{\kwa{effects :: \hat \tau \rightarrow \varepsilon}}$ \begin{itemize}
	\setlength\itemsep{-0.7em}
	\item[] $\fx{\{ \bar r \}} = \{ r.\pi \mid r \in \bar r, \pi \in \Pi \}$
	\item[] $\fx{\hat \tau_1 \rightarrow_{\varepsilon} \hat \tau_2} = \fx{\hat \tau_1} \cup \varepsilon \cup \fx{\hat \tau_2}$
\end{itemize}
\vspace{-7pt}
\caption{A first definition of $\kwa{effects}$.}
\label{fig:fx_defn}
\end{figure}

\begin{figure}[h]

\[
\begin{array}{c}

\infer[\textsc{($\varepsilon$-Import2)}]
	{ \hat \Gamma \vdash \import{\varepsilon}{x}{\hat e}{e}: \kwa{annot}(\tau, \varepsilon)~\kw{with} \varepsilon \cup \varepsilon_1 }
	{ \hat \Gamma \vdash \hat e: \hat \tau~\kw{with} \varepsilon_1 & x: \kwa{erase}(\hat \tau) \vdash e: \tau & \kwa{effects}(\hat \tau) \subseteq \varepsilon}

\end{array}
\]
\vspace{-7pt}
\caption{A second rule for type-and-effect checking $\kwa{import}$ expressions.}
\label{fig:import_rule_2}
\end{figure}

The counterexample which defeated \textsc{$\varepsilon$-Import1} is now rejected by \textsc{$\varepsilon$-Import2}, but the rule is not yet perfect: the annotations on one import can be broken by another import. To illustrate, consider Figure \ref{fig:rule_import2_counterexample} where two\footnote{Our formalisation only allows unannotated cdoe to import a single capability, but this discussion leads to a generalisation needed for the rules be safe when multiple imports are allowed.} capabilities are imported. This program imports a function $\kwa{go}$ which, when given a $\Unit \rightarrow_{\varnothing} \Unit$ function with no effects, will execute it. The other import is a $\kwa{File}$. The unannotated code creates a $\Unit \rightarrow \Unit$ function which writes to a file when executed, and passes it to $\kwa{go}$, which subsequently incurs the $\kwa{File.write}$ effect.

\begin{figure}[h]

\begin{lstlisting}
import({File.*})
   go = $\lambda$x: Unit $\rightarrow_{\varnothing}$ Unit. x unit
   f = File
in
   go ($\lambda$y: Unit. f.write)

\end{lstlisting}

\vspace{-7pt}
\caption{Permitting multiple imports will break \textsc{$\varepsilon$-Import2}.}
\label{fig:rule_import2_counterexample}
\end{figure}

In the world of annotated code it is not possible to pass a file-writing function to $\kwa{go}$. However, the judgement $x: \erase{\hat \tau} \vdash e: \tau$ discards the annotations on $\kwa{go}$, and since the file-writing function has type $\unit \rightarrow \unit$, the unannotated world accepts it as well-typed. Because the $\kwa{import}$ selects $\{ \kwa{File.*} \}$, the approximation is actually safe at the top-level, but it contains locally unsafe code. We want to prevent this.

If $\kwa{go}$ had the type $\Unit \rightarrow_{\{ \kwa{File.write} \}} \Unit$ then the above example would be safe. However, a modified version where a file-reading function is passed to $\kwa{go}$ would have the same issue. $\kwa{go}$ is only safe when it expects every possible effect that the unannotated code might incur; if $\kwa{go}$ had the type $\Unit \rightarrow_{\{ \kwa{File.*} \}} \Unit$, then the unannotated code cannot pass it a capability with an effect it isn't already expecting, and so the annotation on $\kwa{go}$ cannot be violated. To solve the issue, we require imported capabilities to have authority to incur the effects in $\varepsilon$.

To achieve greater control in how we say this, the definition of $\kwa{effects}$ into two separate functions, called $\kwa{effects}$ and $\kwa{ho \hyphen effects}$. If values of $\hat \tau$ can be used to directly incur an effect $r.\pi$, then $r.\pi \in \fx{\hat \tau}$. If values of $\hat \tau$ can incur an effect $r.\pi$, but need to be given the capability by someone else in order to do that, then $r.\pi \in \hofx{\hat \tau}$.


\begin{figure}[h]

$\bm{\kwa{effects :: \hat \tau \rightarrow \varepsilon}}$ \begin{itemize}
	\setlength\itemsep{-0.7em}
	\item[] $\fx{\{ \bar r \}} = \{ r.\pi \mid r \in \bar r, \pi \in \Pi \}$
	\item[] $\fx{\hat \tau_1 \rightarrow_{\varepsilon} \hat \tau_2} = \hofx{\hat \tau_1} \cup \varepsilon \cup \fx{\hat \tau_2}$
\end{itemize}

$\bm{\kwa{ho \hyphen effects} :: \hat \tau \rightarrow \varepsilon}$ \begin{itemize}
	\setlength\itemsep{-0.7em}
	\item[] $\hofx{\{ \bar r \}} = \varnothing$
	\item[] $\hofx{\hat \tau_1 \rightarrow_{\varepsilon} \hat \tau_2} = \fx{\hat \tau_1} \cup \hofx{\hat \tau_2}$
\end{itemize}

\vspace{-7pt}
\caption{Effect functions.}
\label{fig:fx_defns}
\end{figure}

Note how the functions are mutually recursive, and have base cases for resource types. Any effect can be directly incurred by a resource on itself, hence $\fx{\{ \bar r \}} = \{ r.\pi \mid r \in \bar r, \pi \in \Pi \}$. A resource cannot be used to indirectly invoke some other effect, so $\hofx{\{ \bar r \}} = \varnothing$. The definitions on functions mirror the subtyping rule for functions. Recall that functions are contravariant in their input type and covariant in their output type. Similarly, both functions recurse on the input-type using the other function, and recurse on the output-type using the same function.

In light of these new definitions, we still require $\fx{\hat \tau} \subseteq \varepsilon$ --- unannotated code must select any capability which could be given to it --- but a new premise $\varepsilon \subseteq \hofx{\hat \tau}$ should be added to formalise the idea that imported capabilities must know about every effect they could be given by unannotated code. The counterexample from Figure \ref{fig:rule_import2_counterexample} would now be rejected, because $\hofx{\Unit \rightarrow_{\varnothing} \Unit) \rightarrow_{\varnothing} \Unit} = \varnothing$, but $\{ \kwa{File.*} \} \not\subseteq \varnothing$. But this is \textit{still} not sufficient! Consider $\varepsilon \subseteq \hofx{ \hat \tau_1 \rightarrow_{\varepsilon'} \hat \tau_2 }$. We want \textit{every} higher-order capability involved to be expecting $\varepsilon$. Expanding the definition, $\varepsilon \subseteq \fx{\hat \tau_1} \cup \hofx{\hat \tau_2}$. Let $r.\pi \in \varepsilon$ and suppose $r.\pi \in \fx{\hat \tau_1}$, but $r.\pi \notin \hofx{\hat \tau_2}$. Then $\varepsilon \subseteq \fx{\hat \tau_1} \cup \hofx{\hat \tau_2}$ is still true, but $\hat \tau_2$ is not expecting $r.\pi$. Unannotated code could then violate the annotations on $\hat \tau_2$ by causing it to invoke $r.\pi$, using the same trickery from before.

The issue is that $\subseteq$ does not distribute over $\rightarrow_{\varepsilon'}$. We want a relation like $\varepsilon \subseteq \fx{\hat \tau_1} \cup \hofx{\hat \tau_2}$, but where $\subseteq$ distributes over the input and output type. The two relations are called $\kwa{safe}$ and $\kwa{ho \hyphen safe}$. The former is a distributive version of $\varepsilon \subseteq \fx{\hat \tau}$ and the latter of $\varepsilon \subseteq \hofx{\hat \tau}$. Definitions are given in \ref{fig:safe_defns}.


\begin{figure}[h]

\noindent
$\fbox{$\kwa{safe(\hat \tau, \varepsilon)}$}$

\[
\begin{array}{c}

\infer[\textsc{(Safe-Resource)}]
	{\kwa{safe}(\{ \bar r \}, \varepsilon)}
	{}
~~~~~
\infer[\textsc{(Safe-Unit)}]
	{\kwa{safe}(\kwa{Unit}, \varepsilon)}
	{} \\[3ex]

\infer[\textsc{(Safe-Arrow)}]
	{\kwa{safe}(\hat \tau_1 \rightarrow_{\varepsilon'} \hat \tau_2, \varepsilon)}
	{\varepsilon \subseteq \varepsilon' & \kwa{ho \hyphen safe}(\hat \tau_1, \varepsilon) & \kwa{safe}(\hat \tau_2, \varepsilon)} \\[3ex]

\end{array}
\]

\noindent
$\fbox{$\kwa{ho \hyphen safe(\hat \tau, \varepsilon)}$}$

\[
\begin{array}{c}

\infer[\textsc{(HOSafe-Resource)}]
	{ \kwa{ho \hyphen safe}( \{ \bar r \}, \varepsilon)} 
	{}
	~~~~~~
\infer[\textsc{(HOSafe-Unit)}]
	{ \kwa{ho \hyphen safe}( \kwa{Unit}, \varepsilon)} 
	{}\\[3ex]

\infer[\textsc{(HOSafe-Arrow)}]
	{ \kwa{ho \hyphen safe}( \hat \tau_1 \rightarrow_{\varepsilon'} \hat \tau_2, \varepsilon ) }
	{ \kwa{safe}(\hat \tau_1, \varepsilon)  & \kwa{ho \hyphen safe}(\hat \tau_2, \varepsilon) }\\[3ex]

\end{array}
\]

\vspace{-7pt}
\caption{Safety judgements in the epsilon calculus.}
\label{fig:safe_defns}
\end{figure}

Note again how the mutual recursion of $\kwa{safe}$ and $\kwa{ho \hyphen safe}$ mimics the co(ntra)variance rules for function subtyping. Some properties of these relations are also immediate: $\safe{\hat \tau}{\varepsilon}$ implies $\varepsilon \subseteq \fx{\hat \tau}$ and $\hosafe{\hat \tau}{\varepsilon}$ implies $\varepsilon \subseteq \hofx{\hat \tau}$, but the converses are not true, because the safety predicates are distributive and are therefore stronger notions.

An amended version of \textsc{$\varepsilon$-Import} is given in Figure \ref{fig:import_rule3}. It contains a new premise $\hosafe{\hat \tau}{\varepsilon}$ which formalises the notion that every capability which could given to a value of $\hat \tau$ --- or any constitutent piece of $\hat \tau$ --- must be expecting the effects $\varepsilon$ which might be passed to it inside the unannotated code.

\begin{figure}[h]

\noindent
\fbox{$\hat \Gamma \vdash \hat e: \hat \tau~\kw{with} \varepsilon$}

\[
\begin{array}{c}

\infer[\textsc{($\varepsilon$-Import3)}]
	{ \hat \Gamma \vdash \kwa{import}(\varepsilon)~x = \hat e~\kw{in} e: \kwa{annot}(\tau, \varepsilon)~\kw{with} \varepsilon \cup \varepsilon_1 }
{{\def\arraystretch{1.4}
  \begin{array}{c}
\hat \Gamma \vdash \hat e: \hat \tau~\kw{with} \varepsilon_1
~~~~~~
\kwa{effects}(\hat \tau) \subseteq \varepsilon \\
\hosafe{\hat \tau}{\varepsilon} ~~~~~~ x: \kwa{erase}(\hat \tau) \vdash e: \tau
  \end{array}}} 
 
\end{array}
\]

\vspace{-7pt}
\caption{A third rule for type-and-effect checking $\kwa{import}$ expressions.}
\label{fig:import_rule3}
\end{figure}

The premises so far restrict what authority can be selected by unannotated code, but what about authority passed as a function argument? Consider $\hat e = \import{\varnothing}{x}{\unit}{\kwa{\lambda f: { File }.~f.write}}$. The unannotated code selects no capabilities and returns a function which, when given a $\kwa{File}$, will incur $\kwa{File.write}$. This satisfies the premises in \textsc{$\varepsilon$-Import3}, but the type ascribed by \textsc{$\varepsilon$-Import3} is $\{ \File \} \rightarrow_{\varnothing} \Unit$ --- not good!

Suppose the unannotated code defines a function $f$, which gets annotated with $\varepsilon$ to produce $\annot{f}{\varepsilon}$. Suppose $\annot{f}{\varepsilon}$ is invoked at a later point and incurs the effect $r.\pi$. What is the source of $r.\pi$? If $r.\pi$ was selected by the $\kwa{import}$ expression surrounding $f$, it is safe for $\annot{f}{\varepsilon}$ to incur this effect. Otherwise, $\annot{f}{\varepsilon}$ may have been passed an argument which can be used to incur $r.\pi$, in which case $r.\pi$ is a higher-order effect of $\annot{f}{\varepsilon}$. If the argument is a function, then by the soundness of $\opercalc$, it must be that $r.\pi \in \varepsilon$. If the argument is a resource $r$ then $\annot{f}{\varepsilon}$ may exercise $r.\pi$, which our rule does not yet account for. However, we can tell before annotation whether $\annot{f}{\varepsilon}$ might be given $r$ by inspecting its (unannotated type) for a resource set containing $r$.

To solve the problem, we ensure $\varepsilon$ contains every effect captured by resources passed into $f$ as arguments. To do this, we add a new premise $\hofx{\annot{\tau}{\varnothing}} \subseteq \varepsilon$. Because $\kwa{hofx}$ is only defined on annotated types, applying it requires us to first annotate $\tau$. What we annotate with is unimportant --- we know functions passed into $\annot{f}{\varepsilon}$ must satisfy the constraints imposed by $\varepsilon$. We are simply inspecting the resources passed into $f$ as an argument, so we choose to annotate with $\varnothing$.

We can now handle the counterexample $\import{\varnothing}{x}{\unit}{\kwa{\lambda f: { File }.~f.write}}$: because $\kwa{x: Unit \vdash \lambda f: { File }.~f.write: \{ File \} \rightarrow Unit}$, and $\hofx{\annot{ \{ \File \} \rightarrow \Unit}{\varnothing}} = \{ \File \}$, but $\{ \File \} \not\subseteq \varnothing$, so the example safely rejects.

The final version of \textsc{$\varepsilon$-Import} is given in Figure \ref{fig:import_rule}.

\begin{figure}[h]

\noindent
\fbox{$\hat \Gamma \vdash \hat e: \hat \tau~\kw{with} \varepsilon$}

\[
\begin{array}{c}

\infer[\textsc{($\varepsilon$-Import)}]
	{ \hat \Gamma \vdash \kwa{import}(\varepsilon)~x = \hat e~\kw{in} e: \kwa{annot}(\tau, \varepsilon)~\kw{with} \varepsilon \cup \varepsilon_1 }
{{\def\arraystretch{1.4}
  \begin{array}{c}
\varepsilon = \kwa{effects}(\hat \tau) \cup \hofx{\annot{\tau}{\varepsilon}} \\
\hat \Gamma \vdash \hat e: \hat \tau~\kw{with} \varepsilon_1 ~~~~~~ \kwa{ho \hyphen safe}(\hat \tau, \varepsilon) ~~~~~~ x: \kwa{erase}(\hat \tau) \vdash e: \tau
  \end{array}}} 
 
\end{array}
\]


\vspace{-7pt}
\caption{The final rule for typing imports.}
\label{fig:import_rule}
\end{figure}



\subsection{$\epscalc$ Soundness}

Annotated programs are the only ones which can be reduced and have their effects approximated, so the statement of soundness in $\epscalc$ only applies to those situations. A definition is given below.

\begin{theorem}[Soundness]
If $\hat \Gamma \vdash \hat e_A: \hat \tau_A~\kw{with} \varepsilon_A$ and $\hat e_A$ is not a value, then $e_A \longrightarrow e_B~|~\varepsilon$, where $\hat \Gamma \vdash e_B: \hat \tau_B~\kw{with} \varepsilon_B$ and $\hat \tau_B <: \hat \tau_A$ and $\varepsilon_B \cup \varepsilon \subseteq \varepsilon_A$.
\end{theorem}

Since the rules of $\opercalc$ are also contained in $\epscalc$ and have been proven sound, we shall present the same theorems in this section, but only comment on the cases which pertain to new forms and rules. Some lemmas are new, and in those cases we prove them for every case.

We begin with canonical forms, which remains unchanged. The substitution lemma gains an extra case, but the proof is routine.


\begin{lemma}[Canonical Forms]
Unless the rule used is \textsc{$\varepsilon$-Subsume}, the following are true:
\begin{itemize}
	\setlength\itemsep{-0.7em}
	\item If $ \Gamma \vdash  v:  \tau~\kw{with} \varepsilon$ then $\varepsilon = \varnothing$.
	\item If $ \Gamma \vdash  v: \{ \bar r \}$ then $ v = r$ for some $r \in R$ and $\{ \bar r \} = \{ r \}$.
\end{itemize}
\end{lemma}

\begin{lemma}[Substitution]
If $\hat \Gamma, x: \hat \tau' \vdash e: \hat \tau~\kw{with} \varepsilon$ and $\hat \Gamma \vdash \hat v: \hat \tau'~\kw{with} \varnothing$ then $\hat \Gamma \vdash [\hat v/x]e: \hat \tau~\kw{with} \varepsilon$.
\end{lemma}

\begin{proof} By induction on $\hat \Gamma, x: \hat \tau' \vdash e: \hat \tau~\kw{with} \varepsilon$,

\textit{Case:} \textsc{$\varepsilon$-Import}. By definition, $[\hat v/y](\import{\varepsilon}{x}{\hat e}{e}) = \import{\varepsilon}{x}{[\hat v/y] \hat e}{e}$. The result follows by applying the inductive assumption to $[\hat v/y] \hat e$.
\end{proof}

Similarly, the progress theorem now has an extra case for when the typing rule used was \textsc{$\varepsilon$-Import}. The proof is also straightforward.

\begin{theorem}[Progress]
If $\hat \Gamma \vdash \hat e: \hat \tau~\kw{with} \varepsilon$ and $\hat e$ is not a value, then $\hat e \longrightarrow \hat e'~|~\varepsilon$.
\end{theorem}

\begin{proof} By induction on $\hat \Gamma \vdash \hat e: \hat \tau~\kw{with} \varepsilon$.

\textit{Case:} Then $\hat e = \import{\varepsilon}{x}{\hat e'}{e}$. If $\hat e'$ is a non-value then $\hat e$ reduces by \textsc{E-Import1}. Otherwise $\hat e$ reduces by \textsc{E-Import2}.
\end{proof}

The preservation theorem also gains an extra case for when \textsc{$\varepsilon$-Import} is the typing rule used. The subcase where \textsc{E-Import1} is the reduction rule used is straightforward, but the other subcase where \textsc{E-Import2} is used is tricky. We devote most of the rest of this section to building up the appropriate lemmas needed to show that this particular subcase is type-and-effect safe.

In this particular situation the capability being imported is a value and the reduction annotates the naked code with its selecetd authority $\varepsilon$ and then performs substitution. The reduction has the form $\import{\varepsilon}{x}{\hat v}{e} \longrightarrow [\hat v/x]\annot{e}{\varepsilon}~|~\varnothing$. To show it preserves type-and-effect safety requires a few things. First, if $\hat \Gamma \vdash \import{\varepsilon}{x}{\hat v}{e}: \hat \tau_A~\kw{with} \varepsilon$, then we need to be able to type the reduced expression in the same context: $\hat \Gamma \vdash [\hat v/x]\annot{e}{\varepsilon}: \hat \tau_B~\kw{with} \varepsilon_B$. Since $\hat v$ is a value then by the conclusion of \textsc{$\varepsilon$-Import}, $\varepsilon_B = \varepsilon$, the selected authority of $e$. Showing $\varepsilon \subseteq \varepsilon_A$ would be efficient to show effect-soundness.

To show type-soundness we need $\tau_B <: \tau_A$. But what is $\tau_B$? Intuitively, if $x: \erase{\hat \tau} \vdash e: \tau$, and the expression after reduction is $[\hat v/x]\annot{e}{\varepsilon}$, then the type after reduction is probably related to $\tau$ in some way. By substitution lemma, the type of $\annot{e}{\varepsilon}$ ought to be preserved after substitution. So we might guess the type will be either $\annot{\tau}{\varepsilon}$ or $\annot{\hat \tau}{\varepsilon}$. The first of those two is what we prove with the following lemma.

\begin{lemma}[Annotation]
If the following are true:

\begin{enumerate}
	\setlength\itemsep{-0.7em}
	\item $\hat \Gamma \vdash \hat v : \hat \tau~\kw{with} \varnothing$
	\item $\Gamma, y: \kwa{erase}(\hat \tau) \vdash e: \tau$
	\item $\varepsilon = \kwa{effects}(\hat \tau) \cup \hofx{\annot{\tau}{\varepsilon}}$
	\item $\kwa{ho \hyphen safe}(\hat \tau, \varepsilon)$
\end{enumerate}

\noindent
Let $\varepsilon' = \varepsilon~\cup~ \fx{\annot{\Gamma}{\varepsilon}}$. Then $\hat \Gamma, \kwa{annot}(\Gamma, \varepsilon'), y: \hat \tau \vdash \kwa{annot}(e, \varepsilon') : \kwa{annot}(\tau, \varepsilon')~\kw{with} \varepsilon'$.
\end{lemma}

The premises of the annotation lemma are very specific to the premises of \textsc{$\varepsilon$-Import}, but generalised slightly to accommodate a proof by induction: note how there are ambient bindings in the typechecking of unannotated code: $\Gamma, y: \kwa{erase}(\hat \tau) \vdash e: \tau$. Furthermore, the approximated effects in the judgement in the conclusion of the theorem statement contain everything captured by these ambient bindings: $\fx{\annot{\Gamma}{\varepsilon}}$, which is essentially the ambient authority exercised in $e$. By contrast, $\varepsilon$ is the selected authority of $e$.

Because of the constraints imposed on $e$ by \textsc{$\varepsilon$-Import}, no effect at the top-level is ambient.; therefore when we apply the annotation lemma we choose $\Gamma = \varnothing$. However, inductively-speaking, some effects are ambient in certain sub-scopes of $e$. For example, the expression $\kwa{f.write}$ exercises ambient authority over whatever resource is bound to $f$, but when enclosed by an appropriate abstraction like $\kwa{\lambda f: {File}.~f.write}$, $f$ is no longer considered ambient in the enclosing scope. In the process of proving the lemma we may need to, for example, step into the body of a function, at which point certain capabilities become ambient and need to be considered as such, and so we need to consider at all points what is the ambient authority.

Note that when $\Gamma = \varnothing$ then $\varepsilon' = \varepsilon$ and applying the lemma gives a typing judgement of the form $\hat \Gamma, \kwa{annot}(\Gamma, \varepsilon'), y: \hat \tau \vdash \kwa{annot}(e, \varepsilon') : \kwa{annot}(\tau, \varepsilon')~\kw{with} \varepsilon$, which matches the judgement in the conclusion of \textsc{$\varepsilon$-Import}, before the substitution $[\hat v/x]$ is made.

\begin{proof}
By induction on $\Gamma, y: \kwa{erase}(\hat \tau) \vdash e: \tau$.
\end{proof}

\begin{lemma}
If $\kwa{effects}(\hat \tau) \subseteq \varepsilon$ and $\kwa{ho \hyphen safe}(\hat \tau, \varepsilon)$ then $\hat \tau <: \kwa{annot}(\kwa{erase}(\hat \tau), \varepsilon)$.
\end{lemma}

\begin{lemma}
If $\kwa{ho \hyphen effects}(\hat \tau) \subseteq \varepsilon$ and $\safe{\hat \tau}{\varepsilon}$ then $\kwa{annot(erase}(\hat \tau), \varepsilon) <: \hat \tau$.
\end{lemma}

\begin{proof}
By simultaneous induction on $\kwa{ho \hyphen safe}$ and $\kwa{safe}$.
\end{proof}

\noindent
Again, there is a close relation between these lemmas and the subtyping rule for functions. In a subtyping relation between functions, the input type is contravariant. Therefore, if $\hat \tau = \hat \tau_1 \rightarrow_{\varepsilon'} \tau_2$ and we have $\hat \tau <: \kwa{annot}(\tau, \varepsilon)$, then we need to know $\kwa{annot}(\tau_1) <: \hat \tau_1$. This is why there are two lemmas: one for each direction.

Armed with the annotation lemma, we can now prove the preservation theorem.

\begin{theorem}[Preservation]
If $\hat \Gamma \vdash \hat e_A: \hat \tau_A~\kw{with} \varepsilon_A$ and $\hat e_A \longrightarrow \hat e_B~|~\varepsilon$, then $\hat \tau_B <: \hat \tau_A$ and $\varepsilon_B \cup \varepsilon \subseteq \varepsilon_A$.
\end{theorem}

\begin{proof} By induction on $\hat \Gamma \vdash \hat e_A: \hat \tau_A~\kw{with} \varepsilon_A$, and then on $\hat e_A \longrightarrow \hat e_B~|~\varepsilon$. \\

\textit{Case:} \textsc{$\varepsilon$-Import}. Then $e_A = \import{\varepsilon}{x}{\hat e}{e}$. If the reduction rule used was \textsc{E-Import1} then the result follows by applying the inductive hypothesis to $\hat e$.

Otherwise $\hat e$ is a value and the reduction used was \textsc{E-Import2}. The following are true:
\begin{enumerate}
	\setlength\itemsep{-0.7em}
	\item $e_A = \kwa{import}(\varepsilon)~x = \hat v~\kw{in} e$
	\item $\hat \Gamma \vdash e_A: \kwa{annot}(\tau, \varepsilon)~\kw{with} \varepsilon \cup \varepsilon_1$
	\item $\kwa{import}(\varepsilon)~x = \hat v~\kw{in} e \longrightarrow [\hat v/x]\kwa{annot}(e, \varepsilon)~|~\varnothing$
	\item $\hat \Gamma \vdash \hat v: \hat \tau~\kw{with} \varnothing$
	\item $\varepsilon = \kwa{effects}(\hat \tau)$
	\item $\kwa{ho \hyphen safe}(\hat \tau, \varepsilon)$
	\item $x: \kwa{erase}(\hat \tau) \vdash e: \tau$
\end{enumerate}

\noindent
Apply the annotation lemma with $\Gamma = \varnothing$ to get $\hat \Gamma, x: \hat \tau \vdash \kwa{annot}(e, \varepsilon): \kwa{annot}(\tau, \varepsilon)~\kw{with} \varepsilon$. From assumption (4) we know $\hat \Gamma \vdash \hat v: \hat \tau~\kw{with} \varnothing$,n so the substitution lemma may be applied, giving $\hat \Gamma \vdash [\hat v/x]\kwa{annot}(e, \varepsilon): \kwa{annot}(\tau, \varepsilon)~\kw{with} \varepsilon$. By canonical forms, $\varepsilon_1 = \varepsilon_C = \varnothing$. Then $\varepsilon_B = \varepsilon = \varepsilon_A \cup \varepsilon_C$. By examination, $\tau_A = \tau_B = \kwa{annot}(\tau, \varepsilon)$.
\end{proof}

We can now combine Progress and Preservation into the Soundness theorem for $\epscalc$. The proof of multi-step soundness in $\epscalc$ is identical to the proof in $\opercalc$.

\begin{theorem}[Soundness]
If $\hat \Gamma \vdash \hat e_A: \hat \tau_A~\kw{with} \varepsilon_A$ and $\hat e_A$ is not a value, then $e_A \longrightarrow e_B~|~\varepsilon$, where $\hat \Gamma \vdash e_B: \hat \tau_B~\kw{with} \varepsilon_B$ and $\hat \tau_B <: \hat \tau_A$ and $\varepsilon_B \cup \varepsilon \subseteq \varepsilon_A$.
\end{theorem}

\begin{theorem}[Multi-step Soundness]
If $\hat \Gamma \vdash \hat e_A: \hat \tau_A~\kw{with} \varepsilon_A$ and $e_A \longrightarrow^{*} e_B~|~\varepsilon$, where $\hat \Gamma \vdash e_B: \hat \tau_B~\kw{with} \varepsilon_B$ and $\hat \tau_B <: \hat \tau_A$ and $\varepsilon_B \cup \varepsilon \subseteq \varepsilon_A$.
\end{theorem}






