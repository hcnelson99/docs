\chapter{Effect Calculi}

This chapter introduces a pair of languages: the operation calculus $\opercalc$ and the capability calculus $\epscalc$. $\opercalc$ is an extension of $\stlc$ with primitive capabilities and their operations. Every function is annotated with what effects it might incur. The static rules of $\opercalc$ ascribe a type-and-effect to programs, and the resulting theory is sound with respect to both types and effects. We then generalise $\opercalc$ to obtain $\epscalc$, which allows unannotated code to be nested inside annotated code using a new $\kwa{import}$ construct in a capability-safe manner. A safe inference can be made about what effects the unannotated code might incur by inspecting the capabilities it is given.

The motivating examples in this chapter are written in a \textit{Wyvern}-like language. Wyvern is a capability-safe, pure, object-oriented language with first-class modules \cite{nistor13}. A more thorough discussion of how Wyvern programs might be translated into the calculi is given in Chapter 4.

\section{$\opercalc$: Operation Calculus}

The operation calculus $\opercalc$ extends $\stlc$ with primitive capabilities and their operations. A primitive capability encapsulates some system resource; a primitive capability $\kwa{File}$ might provide some operations on a particular file in the file system. For convenience we often conflate the capability granting operations with the resource itself. An effect is a particular operation invoked on some resource. Every function-type in $\opercalc$ is annotated with what effects may be incurred during execution of the function body. The static rules of $\opercalc$ can inspect this information and ascribe a set of effects to a piece of code, giving a static approximation to the runtime effects.

When a component is annotated with the effects it might incur, an effect-system can determine when the allowed 	authority of a component is being violated. Consider the pair of modules in Figure \ref{fig:opercalc_motivating}: the $\kwa{Logger}$ possesses a $\kwa{File}$ capability and exposes a single function $\kwa{log}$ which incurs the $\kwa{File.write}$ effect. The $\kwa{Client}$, when passed a $\kwa{Logger}$, will invoke its $\kwa{log}$ function.


\begin{figure}[h]
\vspace{-5pt}

\begin{lstlisting}
resource module Logger
require File

def log(): Unit with {File.write} =
    File.write(``message written'')
\end{lstlisting}

\begin{lstlisting}
module Client

def run(l: Logger): Unit with $\varnothing$ =
    l.log()
\end{lstlisting}

\vspace{-7pt}
\caption{The implementation of $\kwa{Client.run}$ exceeds its specified authority.}
\label{fig:opercalc_motivating}
\end{figure}

Following the principle of least authority, $\kwa{Client.run}$ is annotated as incurring $\varnothing$ as its effects and $\kwa{Logger.log}$ is annotated as incurring $\{ \kwa{File.write} \}$. But as $\kwa{Client.run}$ invokes $\kwa{Logger.log}$, its implementation violates its specified authority. By the end of this section, we will have developed rules for $\opercalc$ that reject implementations inconsistent with their specification.


\subsection{$\opercalc$ Grammar}

In addition to the forms from $\stlc$, $\opercalc$ contains two new forms: resource literals and operation calls. The grammar for $\opercalc$ is summarised in Figure \ref{fig:opercalc_grammar}.

\begin{figure}[h]
\vspace{-5pt}

\[
\begin{array}{lll}

\begin{array}{lllr}

e & ::= & ~ & exprs: \\
	& | & x & variable \\
	& | & v & value \\
	& | & e ~ e & application \\
	& | & e.\pi & operation \\
	&&\\

\end{array}

\begin{array}{lllr}

v & ::= & ~ & values: \\ 
	& | & r & resource~literal \\
	& | & \lambda x: \tau.e & abstraction \\
	&&\\

\end{array}

\end{array}
\]

\vspace{-7pt}
\caption{Grammar for $\opercalc$.}
\label{fig:opercalc_grammar}
\end{figure}

A resource literal $r$ is a variable drawn from a fixed set $R$. Resources cannot be created or destroyed at runtime. They model those initial capabilities passed into the program which endow operations upon system resources. A $\kwa{File}$ and a $\kwa{Socket}$ are examples of resource literals.

An operation call $e.\pi$ is the invocation of a primitive operation $\pi$ invoked on the resource described by $e$. For example, we might invoke the $\kwa{open}$ operation on a $\kwa{File}$ resource, which would be the operation call $\kwa{File.open}$. Operations are drawn from a fixed set $\Pi$. Like resources, they cannot be created or destroyed at runtime.

An effect is a pair $(r, \pi) \in R \times \Pi$. Sets of effects are denoted $\varepsilon$; a rule for them is given in Figure \ref{fig:opercalc_fx}. 
 As a shorthand, we write $r.\pi$ instead of $(r, \pi)$. Effects should be distinguished from operation calls: an operation call is the invocation of a particular operation on a particular resource in a program, while an effect is a mathematical object describing this behaviour. We have defined $\varepsilon$ syntactically as a sequence of pairs from $R \times \Pi$, but instances of $\varepsilon$ should be interpreted as a set. The notation $r.*$ is short-hand for the set $\{ r.\pi \mid \pi \in \Pi \}$, which contains every effect on $r$. Sometimes we abuse notation by conflating the effect $r.\pi$ with a singleton set of effects $\{ r.\pi \}$. We might also write things like $\{ r_1.*, r_2.* \}$, which should be understood as the set of all operations on $r_1$ and $r_2$.

\begin{figure}[h]
\vspace{-5pt}

\[
\begin{array}{lll}

\begin{array}{lllr}

\varepsilon & ::= & ~ & effects: \\
	& | & \{ \overline{r.\pi} \} & effect~set \\
	&&\\

\end{array}

\end{array}
\]

\vspace{-7pt}
\caption{Grammar for effects in $\opercalc$.}
\label{fig:opercalc_fx}
\end{figure}

Because the static rules of $\opercalc$ are only interested in where effects are incurred, we have chosen not to model the semantics of particular operations. In practice, operations might take arguments of particular types and return a value of a particular type $\kwa{File.write(``msgToWrite'')}$, for example. We make a simplifying assumption that all operations are null-ary and return the same dummy value, and that all operations are defined on all resources. 

\subsection{$\opercalc$ Dynamic Rules}

Before giving the dynamic rules we extend the definition of $\kwa{substitution}$ to be defined on the extra forms. The extra cases are given in Figure \ref{fig:opercalc_sub_defn}. The function is defined the same on existing forms as in $\stlc$, so we do not repeat them. We also make an extra restriction in $\opercalc$ that a variable may only be substituted for a value. This restriction is imposed because if a variable can be replaced with an arbitrary expression, we might also be introducing arbitrary effects, which violates the preservation of effects. Because we only consider the call-by-value strategy, in which expressions are reduced to values before being bound to names, this restriction is no issue.

\begin{figure}[h]

\bm{$\kwa{substitution :: e \times v \times v \rightarrow e}$}

\begin{itemize}
	\setlength\itemsep{-0.7em}
	\item[] $[v/y]r = r$
	\item[] $[v/y](e_1.\pi) = ([v/y]e_1).\pi$
\end{itemize}

\vspace{-7pt}
\caption{Substitution function in $\opercalc$.}
\label{fig:opercalc_sub_defn}
\end{figure}

During reduction an operation call may be evaluated. When this happens a runtime effect is said to have taken place. The form of the single-step reduction judgement is now $e \longrightarrow e~|~\varepsilon$ to reflect this fact; the resulting pair is the reduced expression, and the set of effects incurred as a result. In the case of single-step reduction, this is at most a single effect. Judgements for single-step reductions are summarised in Figure \ref{fig:opercalc_singlestep}.

\begin{figure}[h]

\noindent
\fbox{$e \longrightarrow e~|~\varepsilon$}

\[
\begin{array}{c}

\infer[\textsc{(E-App1)}]
	{e_1 e_2 \longrightarrow e_1'~ e_2~|~\varepsilon}
	{e_1 \longrightarrow e_1'~|~\varepsilon}
	~~~~~~
\infer[\textsc{(E-App2)}]
	{v_1 ~ e_2 \longrightarrow v_1 ~ e_2'~|~\varepsilon} 
	{e_2 \longrightarrow e_2'~|~\varepsilon}
~~~~~~
\infer[\textsc{(E-App3)}]
	{ (\lambda x: \tau. e) v_2 \longrightarrow [ v_2/x] e~|~\varnothing }
	{}\\[4ex]
	
\infer[\textsc{(E-OperCall1)}]
	{ e.\pi \longrightarrow  e'.\pi~|~\varepsilon }
	{ e \rightarrow  e'~|~\varepsilon}
		
	~~~~~~
	
\infer[\textsc{(E-OperCall2)}]
	{r.\pi \longrightarrow \kwa{unit}~|~\{ r.\pi \} }
	{}
	 \\[4ex]
	 
\end{array}
\]


\vspace{-7pt}
\caption{Single-step reductions in $\opercalc$.}
\label{fig:opercalc_singlestep}
\end{figure}

The first three rules are analogous to the rules from $\stlc$. \textsc{E-App1} and \textsc{E-App2} incur the effects of reducing their subexpressions. Because \textsc{E-App3} is simply performing a substitution, it incurs no effects. The first new rule is \textsc{E-OperCall1}, which reduces the receiver of an operation call; the effects incurred are the effects incurred by reducing the receiver. When an operation $\pi$ is invoked on a resource literal $r$, \textsc{E-OperCall2} will reduce it to $\unit$, incurring $\{ r.\pi \}$ as a result. $\unit$ is a derived form. It is the only value of its type, so is used to represent the absence of information. Because we choose not to model the semantics of operation calls, $\unit$ is a good dummy-value for operation calls to be returning.

From the single-step reductions we define the multi-step reductions in Figure \ref{fig:opercalc_multistep_defn}. A multi-step reduction consists of zero or more single-steps. The resulting effect-set is the union of all the effect-sets produced by the intermediate single-steps.

\begin{figure}[h]

\noindent
\fbox{$ e \longrightarrow^{*}  e~|~\varepsilon$}

\[
\begin{array}{c}

\infer[\textsc{(E-MultiStep1)}]
	{ e \rightarrow^{*}  e~|~\varnothing}
	{}
~~~
\infer[\textsc{(E-MultiStep2)}]
	{ e \rightarrow^{*}  e'~|~\varepsilon}
	{ e \rightarrow  e'~|~\varepsilon} \\[3ex]
	
\infer[\textsc{(E-MultiStep3)}]
	{ e \rightarrow^{*}  e''~|~\varepsilon_1 \cup \varepsilon_2}
	{ e \rightarrow^{*}  e'~|~\varepsilon_1 &  e' \rightarrow^{*}  e''~|~\varepsilon_2}
\end{array}
\]

\vspace{-7pt}
\caption{Multi-step reductions in $\opercalc$.}
\label{fig:opercalc_multistep_defn}
\end{figure}

 
 
 
 
 
 
\subsection{$\opercalc$ Static Rules}

A grammar for the types of $\opercalc$ is given in Figure \ref{fig:opercalc_types}. Typing contexts are the same as in $\stlc$. The base types are sets of resources, denoted $\{ \bar r \}$. If an expression is associated with type $\{ \bar r \}$, then evaluating $e$ will reduce to one of the resource literals $r \in \bar r$ (assuming it terminates). Although $\{ \bar r \}$ is syntactically defined as a sequence, it should be interpreted as a set; $\{ \kwa{File, Socket} \}$ is the same type as $\{ \kwa{Socket, File} \}$. There is a single type-constructor, $\rightarrow_{\varepsilon}$. If an expression is associated with type $\tau_1 \rightarrow_{\varepsilon} \tau_2$, then it is a function which takes a $\tau_1$ as input, returns a $\tau_2$ as output, and during execution incurs no more than those effects in $\varepsilon$. If an effect $r.\pi \in \varepsilon$, then it is not guaranteed that $r.\pi$ will occur during function execution; but if $r.\pi \notin \varepsilon$, then it cannot occur during function execution.

\begin{figure}[h]
\vspace{-5pt}

\[
\begin{array}{lll}

\begin{array}{lllr}

\tau & ::= & ~ & types: \\
		& | & \{ \bar r \} \\
		& | & \tau \rightarrow_{\varepsilon} \tau \\ 
		&&\\
\end{array}

\begin{array}{lllr}

\Gamma & ::= & ~ & type~ctx: \\
				& | & \varnothing \\
				& | & \Gamma, x: \tau \\
				&&\\
\end{array}

\end{array}
\]

\vspace{-7pt}
\caption{Grammar for types in $\opercalc$.}
\label{fig:opercalc_types}
\end{figure}

The only way for code to gain authority over a capability is to be given that capability as a function argument. Because functions in $\opercalc$ must have their input types annotated with the effect-set they might incur on the arrow, we say that $\opercalc$ programs are annotated.

Given a program, we want to know what set of effects might be incurred when it is executed. For example, $(\lambda c: \{ \kwa{File, Socket} \}. c.write) \File$ incurs $\kwa{File.write}$ when executed. Judgements in the type system of $\opercalc$ therefore ascribe a type and a set of effects to a piece of code. The judgement form is $\Gamma \vdash e: \tau~\kw{with} \varepsilon$, which can be read as meaning that $e$ will successively reduce to terms of type $\tau$ and incur no more effects than those in $\varepsilon$. Static rules for $\opercalc$ are given in Figure \ref{fig:opercalc_static_rules}.

\begin{figure}[h]

\noindent
\fbox{$\Gamma \vdash e: \tau~\kw{with} \varepsilon$}

\[
\begin{array}{c}

\infer[\textsc{($\varepsilon$-Var)}]
	{ \Gamma, x:\tau \vdash x: \tau~\kw{with} \varnothing }
	{}
	
	~~~
	
\infer[\textsc{($\varepsilon$-Resource)}]
 	{ \Gamma, r: \{ r \} \vdash r : \{ r \}~\kw{with} \varnothing }
 	{} \\[3ex]
 	
 	~~~
	\infer[\textsc{($\varepsilon$-Abs)}]
	{ \Gamma \vdash \lambda x:\tau_2 . e : \tau_2 \rightarrow_{\varepsilon_3} \tau_3~\kw{with} \varnothing }
	{ \Gamma, x: \tau_2 \vdash e: \tau_3~\kw{with} \varepsilon_3 }
	
	~~~
	
\infer[\textsc{($\varepsilon$-App)}]
	{ \Gamma \vdash e_1~e_2 : \tau_3~\kw{with} \varepsilon_1 \cup \varepsilon_2 \cup \varepsilon  }
	{ \Gamma \vdash e_1: \tau_2 \rightarrow_{\varepsilon} \tau_3~\kw{with} \varepsilon_1 & \Gamma \vdash e_2: \tau_2~\kw{with} \varepsilon_2 } \\[3ex]
	
\infer[\textsc{($\varepsilon$-OperCall)}]
	{ \Gamma \vdash e.\pi: \kw{Unit} \kw{with} \{ \bar r.\pi \} }
	{ \Gamma \vdash e: \{ \bar r \} & \forall r \in \bar r \mid r: \{ r \} \in \Gamma & \pi \in \Pi } \\[3ex]

\infer[\textsc{($\varepsilon$-Subsume)}]
	{ \Gamma \vdash e: \tau' ~\kw{with} \varepsilon'}
	{ \Gamma \vdash e: \tau ~\kw{with} \varepsilon & \tau <: \tau' & \varepsilon \subseteq \varepsilon'}
\end{array}
\]


\vspace{-7pt}
\caption{Type-with-effect judgements in $\opercalc$.}
\label{fig:opercalc_static_rules}
\end{figure}

\textsc{$\varepsilon$-Var} approximates the runtime effects of a variable as $\varnothing$. \textsc{$\varepsilon$-Resource} does the same. Although a resource captures several effects (namely, every possible operation on itself), attempting to ``reduce'' a resource will incur no effects. For a similar reason, \textsc{$\varepsilon$-Abs} approximates the runtime effects of a function literal as $\varnothing$; although the ascribed type has an arrow with a set of effects, equivalent to the approximate effects of the function body. \textsc{$\varepsilon$-App} approximates a lambda application as incurring those effects from evaluating the subexpressions and the effects incurred by executing the body of the function to which the left-hand side evaluates. The effects of a function body are obtained from its arrow-type.

\textsc{$\varepsilon$-OperCall} approximates an operation call as: the effects of reducing the subexpression, and then the operation $\pi$ on every possible resource which that subexpression to which that subexpression might reduce. For example, consider $e.\pi$, where $\Gamma \vdash e: \{ \kwa{File, Socket} \}~\kw{with} \varnothing$. Then $e$ could evaluate to $\kwa{File}$, in which case the actual runtime effect is $\kwa{File.\pi}$, or it could evaluate to $\kwa{Socket}$, in which case the actual runtime effect is $\kwa{Socket.\pi}$. Determining which will actually happen is, in general, undecidable. The safe approximation then is to treat them both as happening. The type of an operation call is $\Unit$, which is the type of $\unit$. $\Unit$ is also a derived type, and $\vdash \unit: \Unit~\kw{with} \varnothing$ by a derived rule \textsc{$\varepsilon$-Unit}. Definitions for this are given in Chapter 4.

The last rule, \textsc{$\varepsilon$-Subsume}, only makes sense in the presence of subtyping rules. It says that the type can be narrowed or the effect-set widened in a judgement to produce a new judgement. The subtyping rules are given in Figure \ref{fig:opercalc_static_rules}.


\begin{figure}[h]
\vspace{-5pt}

\fbox{$\Gamma \vdash e: \tau~\kw{with} \varepsilon$}

\[
\begin{array}{c}

\infer[\textsc{(S-Arrow)}]
	{ \tau_1 \rightarrow_{\varepsilon} \tau_2 <: \tau_1' \rightarrow_{\varepsilon'} \tau_2' }
	{ \tau_1' <: \tau_1 & \tau_2 <: \tau_2' & \varepsilon \subseteq \varepsilon' }
~~~~~~
\infer[\textsc{(S-Resource)}]
	{ \{ \bar r_1 \} <: \{ \bar r_2 \} }
	{ r \in r_1 \implies r \in r_2 }

\end{array}
\]

\vspace{-7pt}
\caption{Subtyping judgements of $\opercalc$.}
\label{fig:opercalc_static_rules}
\end{figure}

The first subtyping rule is \textsc{S-Arrow}, which is similar to the rule for subtyping functions in $\stlc$. The only addition is that the effects of the subtype must be contained in the effects of the supertype, so that instances of the subtype can only incur effects the supertype's interface is expecting.

The other subtyping rule is \textsc{S-Resource}, which says a subset of resource sis also a subtype. To justify this rule, consider $\{ \bar r \} <: \{ \bar r_2 \}$. Any value with type $\{ \bar r_1 \}$ can reduce to any resource literal in $\bar r_1$, so to be compatible with type $\{ \bar r_2 \}$, the resource literals in $\bar r_1$ must also be in $\bar r_2$.

These rules let us determine what sort of effects might be incurred when a piece of code is executed. For example, consider $e = \kwa{(\lambda f: \{ File, Socket \}. f.write)~File}$. The judgement $\vdash e: \Unit~\kw{with} \{ \kwa{File.write, Socket.write} \}$ holds, which says that executing this piece of code might incur either of $\kwa{File.write}$ or $\kwa{Socket.write}$. A derivation for it is given in Figure \ref{fig:opercalc_tree}. To fit in one diagram, all resources and operations have been abbreviated to their first letter. Recall that $\unit$ is a derived form and $\Unit$ a derived type.

\begin{figure}[h]


    \begin{prooftree*}

    		\Infer0[\textsc{($\varepsilon$-Var)}]{f: \{ \kwa{F}, \kwa{S} \} \vdash f: \{ \kwa{F}, \kwa{S} \}}
    		
    		\Infer1[\textsc{($\varepsilon$-OperCall)}]{\kwa{f}: \{ \kwa{F}, \kwa{S} \} \vdash \kwa{f.w} : \Unit~\kw{with} \{ \kwa{F.w, S.w} \} }
    		
    		\Infer1[\textsc{($\varepsilon$-Abs)}]{ \lambda \kwa{f}: \{ \kwa{F}, \kwa{S} \}. \kwa{f.w} : \{ \kwa{F, S} \} \rightarrow_{\kwa{F.w, S.w}} \Unit~\kw{with} \varnothing }
    		
    
       \Infer0[\textsc{($\varepsilon$-Resource)}]{\vdash \kwa{F}: \{ \kwa{F} \}~\kw{with} \varnothing}
    
    		\Infer2[\textsc{($\varepsilon$-App)}]{ \vdash (\lambda \kwa{f}: \{ \kwa{F, S} \}. \kwa{f.write})~\kwa{F} : \Unit~\kw{with} \{ \kwa{F.w, S.w} \}  }
    		
 	\end{prooftree*}
 	
\vspace{-12pt}
\caption{Derivation tree for $(\lambda \kwa{f}: \{ \File, \kwa{Socket} \}.~\kwa{f.write})~\File$.}
\label{fig:opercalc_tree}
\end{figure}

These rules can be used to determine if a piece of code is safe. For example, a function which uses a logger might be $\kwa{e = \lambda l: File \rightarrow_{\kwa{File.append}} Unit.~l~unit}$. Applying the rules to the logger implementation $\kwa{l}$ gives an approximation to the effects it might incur. With that information, we can decide if it is safe to use that particular logger. For example, if $\kwa{l = \lambda f: \{ File \}.~f.read}$ then by \textsc{$\varepsilon$-Abs}, $~\vdash~\kwa{l}: \kw{ \{ File \} \rightarrow_{\kwa{File.read}} Unit} \kw{with} \varnothing$. We can see that applying this function will incur the $\kwa{File.read}$ function, alerting us that this code might be maliciuos. Furthermore, $\kwa{e~l}$ will not typecheck, because $\kwa{e}$ expects a function with $\kwa{File.append}$ on the arrow.


\subsection{$\opercalc$ Soundness}

To show the rules of $\opercalc$ are sound requires an appropriate notion of the static approximations being correct with respect to the reductions. Intuitively, if a static judgement like $\Gamma \vdash e: \tau~\kw{with} \varepsilon$ were correct, then successive reductions on $e$ should never produce effects not in $\varepsilon$. Adding this to our definition of soundness yields the following first definition.

\begin{theorem}[$\opercalc$ Soundness 1]
If $ \Gamma \vdash  e_A:  \tau_A~\kw{with} \varepsilon_A$ and $ e_A$ is not a value, then $e_A \longrightarrow e_B~|~\varepsilon$, where $ \Gamma \vdash e_B:  \tau_B~\kw{with} \varepsilon_B$ and $ \tau_B <:  \tau_A$ and $\varepsilon \subseteq \varepsilon_A$, for some $e_B, \varepsilon, \tau_B, \varepsilon_B$.
\end{theorem}

In this formulation, $\varepsilon_A$ is an approximation to what $e_A$ will do when executed. $e_A$ reduces to $e_B$, incurring the effects in $\varepsilon$, and $e_B$ can be typed in the same context $\Gamma$ with the type $\tau_B$ and effect-approximation $\varepsilon_B$. $\tau_B$ must be a subtype of $\tau_A$, and the runtime effects $\varepsilon$ must be contained in the original approximation $\varepsilon_A$, but no further information about $\varepsilon_B$ is stipulated.

Our approach to proving that multi-step reduction is sound will be to inductively appeal to the soundness of single-step reductions. This is tricky under the given definition of Soundness because it only relates the runtime effects to the approximation of the runtime effects \textit{before} reduction. There are no constraints on the runtime effects \textit{after} reduction. To accommodate a proof of multi-step soundness, we need a stronger version of soundness which relates the approximated effects before reduction ($\varepsilon_A$) to the approximated effects after reduction ($\varepsilon_B$).

First consider how the type after reduction relates to the type before reduction. In $\lambda$-calculi, the type after reduction can be the same or more specific (i.e. $\tau_B <: \tau_A$) than the type before reduction, but never less specific. The idea is that as we reduce the expression we gain more information about its precise type. Similarly, we want to allow for the approximation to get more specific after a reduction. To illustrate why, consider the function $\kwa{get} = \lambda x: \{ \kwa{File, Socket} \} .x$ and the program $\kwa{(get~File).write}$. In the context $\Gamma = \kwa{File: \{ File \}}$, the rule \textsc{$\varepsilon$-App} can be used to approximate the effects of $\kwa{(f~File).write}$ as $\{ \kwa{File.write, Socket.write} \}$. By \textsc{E-App3} we have the reduction $\kwa{(get~File).write} \longrightarrow \kwa{File.write}~|~\varnothing$. The same context can use \textsc{$\varepsilon$-OperCall} to approximate the reduced expression $\kwa{File.write}$ as $\{ \kwa{File.write} \}$; note how the approximation of effects is more precise after reduction. This example shows why the approximation after reduction ($\varepsilon_B$) should be a subset of the approximation before reduction ($\varepsilon_A$). By adding this premise we have our final definition of soundness.

\begin{theorem}[$\opercalc$ Single-step Soundness]
If $ \Gamma \vdash  e_A:  \tau_A~\kw{with} \varepsilon_A$ and $ e_A$ is not a value, then $e_A \longrightarrow e_B~|~\varepsilon$, where $ \Gamma \vdash e_B:  \tau_B~\kw{with} \varepsilon_B$ and $ \tau_B <:  \tau_A$ and $\varepsilon_B \cup \varepsilon \subseteq \varepsilon_A$, for some $e, \varepsilon, \tau_B, \varepsilon_B$.
\end{theorem}

Our approach to proving soundness is to show progress and preservation separately. These in turn rely on canonical forms and the substitution lemma, modified for $\opercalc$ given below. The results are not true if the rule used is \textsc{$\varepsilon$-Subsume} (because the type and approximate effects of a value can be arbitrarily widened), so we must exclude that.

\begin{lemma}[$\opercalc$ Canonical Forms]
Unless the rule used is \textsc{$\varepsilon$-Subsume}, the following are true:
\begin{enumerate}
	\setlength\itemsep{-0.7em}
	\item If $\Gamma \vdash x: \tau~\kw{with} \varepsilon$ then $\varepsilon = \varnothing$.
	\item If $ \Gamma \vdash  v:  \tau~\kw{with} \varepsilon$ then $\varepsilon = \varnothing$.
	\item If $ \Gamma \vdash v: \{ \bar r \}~\kw{with} \varepsilon$ then $v = r$ and $\{ \bar r \} = \{ r \}$.
	\item If $\Gamma \vdash v: \tau_1 \rightarrow_{\varepsilon'} \tau_2~\kw{with} \varepsilon$ then $v = \lambda x:\tau. e$.
\end{enumerate}
\end{lemma}

The first two observations state that a variable will always type with approximate effects $\varnothing$. The third states that if a value is typed to a set of resources, the set of a singleton $\{ r \}$ and the value is the resource literal $r$. The fourth states that if a value types to a function then it is a lambda. Progress follows from Canonical Forms.

\begin{theorem}[$\opercalc$ Progress]
If $ \Gamma \vdash  e:  \tau~\kw{with} \varepsilon$ and $ e$ is not a value or variable, then $ e \longrightarrow  e'~|~\varepsilon$, for some $e', \varepsilon$.
\end{theorem}

\begin{proof} By induction on $ \Gamma \vdash  e:  \tau~\kw{with} \varepsilon$, for $ e$ not a value. If the rule is \textsc{$\varepsilon$-Subsumption} it follows by inductive hypothesis. If $e$ has a reducible subexpression then reduce it. Otherwise use one of \textsc{$\varepsilon$-App3} or \textsc{$\varepsilon$-OperCall2}.
\end{proof}

To show preservation holds we need to know that type-and-effect safety, as it has been formulated in the definition of soundness, is preserved by the substitution in \textsc{E-App3}. As noted in the definition of $\kwa{substitution}$, variables can only be substituted for values in $\opercalc$. Canonical Forms tells us that any value will have its effects approximated as $\varnothing$ (unless $\varepsilon$-Subsume is used). Beyond this observation, the proof is routine.

\begin{lemma}[$\opercalc$ Substitution]
If $\Gamma, x: \tau' \vdash e: \tau~\kw{with} \varepsilon$ and $\Gamma \vdash v: \tau'~\kw{with} \varnothing$ then $\Gamma \vdash [v/x]e: \tau~\kw{with} \varepsilon$.
\end{lemma}

\begin{proof} By induction on the derivation of $\Gamma, x: \tau' \vdash e: \tau~\kw{with} \varepsilon$.
\end{proof}

With this lemma, we can prove the preservation theorem.

\begin{theorem}[$\opercalc$ Preservation]
If $\Gamma \vdash e_A: \tau_A~\kw{with} \varepsilon_A$ and $e_A \longrightarrow e_B~|~\varepsilon$, then $\tau_B <: \tau_A$ and $\varepsilon_B \cup \varepsilon \subseteq \varepsilon_A$, for some $e_B, \varepsilon, \tau_B, \varepsilon_B$.
\end{theorem}

\begin{proof} By induction on the derivation of $\Gamma \vdash e_A: \tau_A~\kw{with} \varepsilon_A$, and then the derivation of $e_A \longrightarrow e_B~|~\varepsilon$. Since $e_A$ can be reduced, we need only consider those rules which apply to non-values and non-variables. \\

\textit{Case:} \textsc{$\varepsilon$-App} Then $e_A = e_1 ~ e_2$ and $e_1: \tau_2 \rightarrow_{\varepsilon} \tau_3~\kw{with} \varepsilon_1$ and $\Gamma \vdash e_2: \tau_2~\kw{with} \varepsilon_2$. If the reduction rule used was \textsc{E-App1} or \textsc{E-App2}, then the result follows by applying the inductive hypothesis to $e_1$ and $e_2$ respectively. Otherwise the rule used was \textsc{E-App3}. Then $(\lambda x: \tau_2. e) v_2 \longrightarrow [ v_2/x] e~|~\varnothing$. By inversion on the typing rule for $\lambda x:  \tau_2. e$ we know $\Gamma, x:  \tau_2 \vdash  e:  \tau_3~\kw{with} \varepsilon_3$. By canonical forms, $\varepsilon_2 = \varnothing$ because $ e_2 =  v_2$ is a value. Then by the substitution lemma, $ \Gamma \vdash [ v_2/x] e :  \tau_3~\kw{with} \varepsilon_3$. By canonical forms, $\varepsilon_1 = \varepsilon_2 = \varnothing = \varepsilon_C$. Therefore $\varepsilon_A = \varepsilon_3 = \varepsilon_B \cup \varepsilon_C$.\\

\textit{Case:} \textsc{$\varepsilon$-OperCall}. Then $e_A = e_1.\pi$ and $ \Gamma \vdash e_1 : \{ \bar r \}~\kw{with} \varepsilon_1$. If the reduction rule used was \textsc{E-OperCall1} then the result follows by applying the inductive hypothesis to $ e_1$. Otherwise the reduction rule used was \textsc{E-OperCall2} and $v_1.\pi \longrightarrow \kwa{unit}~|~\{ r.\pi \}$. By assumption, $\Gamma \vdash v_1.\pi : \kwa{unit}~\kw{with} \{ r.\pi \}$, and by \textsc{$\varepsilon$-Unit}, $\Gamma \vdash \unit: \Unit~\kw{with} \varnothing$. Therefore, $\tau_B = \tau_A = \Unit$ and $\varepsilon \cup \varepsilon_B = \{ r.\pi \} = \varepsilon_A$.\\

\end{proof}

Our single-step soundness theorem now holds immediately by joining the progress and preservation theorems into one.

\begin{theorem}[$\opercalc$ Single-step Soundness]
If $ \Gamma \vdash  e_A:  \tau_A~\kw{with} \varepsilon_A$ and $ e_A$ is not a value, then $e_A \longrightarrow e_B~|~\varepsilon$, where $ \Gamma \vdash e_B:  \tau_B~\kw{with} \varepsilon_B$ and $ \tau_B <:  \tau_A$ and $\varepsilon_B \cup \varepsilon \subseteq \varepsilon_A$, for some $e_B, \varepsilon, \tau_B, \varepsilon_B$.
\end{theorem}
\begin{proof}
If $ e_A$ is not a value then the reduction exists by the progress theorem. The rest follows by the preservation theorem.
\end{proof}

Knowing that single-step reductions are sound, the soundness of multi-step reductions can be shown by inductively applying single-step soundness on their length.

\begin{theorem}[$\opercalc$ Multi-step Soundness]
If $ \Gamma \vdash  e_A:  \tau_A~\kw{with} \varepsilon_A$ and $e_A \longrightarrow^{*} e_B~|~\varepsilon$, where $\Gamma \vdash e_B: \tau_B~\kw{with} \varepsilon_B$ and $ \tau_B <: \tau_A$ and $\varepsilon_B \cup \varepsilon \subseteq \varepsilon_A$.
\end{theorem}

\begin{proof} By induction on the length of the multi-step reduction. If the length is 0 then $e_A = e_B$ and the result holds vacuously. If the length is $n+1$, then the first $n$-step reduction is sound by inductive hypothesis and the last step is sound by single-step soundness, so the entire $n+1$-step reduction is sound.
\end{proof}






\section{$\epscalc$: Capability Calculus}

$\opercalc$ requires every function to be annotated --- if we relax this requirement, can a type system say anything useful about pieces of unannotated code? There are practical reasons to permit unannotated code in an effect-conscious language. Previous effect systems have been criticised for their verbosity \cite{rytz2012}, which might disincline a programmer from bothering to use them. The structured mixing of annotated and unannotated code can alleviate the problem by allowing developers to rapidly prototype in the unannotated sublanguage and incrementally add annotations as they are needed, giving a balance between convenience and safety.

In general, reasoning about unannotated code is difficult because there are no constraints on what effects might be incurred. Figure \ref{fig:unannotated_reasoning} demonstrates the issue: $\kwa{someMethod}$ takes a function $f$ as input and executes it, but the effects of $f$ depend on the implementation. Without more information, such as extra constraints on the problem, more annotations, or a more complex type system, there is no way to know what effects might be incurred by $\kwa{someMethod}$.

\begin{figure}[h]
\begin{lstlisting}
def someMethod(f: Unit $\rightarrow$ Unit):
   f()
\end{lstlisting}
\vspace{-7pt}
\caption{What effects can $\kwa{someMethod}$ incur?}
\label{fig:unannotated_reasoning}
\end{figure}

A capability-safe design can help us: if the capabilities exercised by the unannotated code are supplied by an annotated environment, then whatever effects they capture are a conservative upper-bound on what can happen in the unannotated code. To demonstrate, consider a developer who wants to decide whether the module in Figure \ref{fig:cc_motivation} is trustworthy. The module is a $\kwa{Logger}$, possessing two capabilities $\kwa{File}$ and $\kwa{Socket}$, and providing a single unannotated function $\kwa{log}$.

\begin{figure}[h]
\begin{lstlisting}
resource module Logger
require File
require Socket

def log(x: Unit): Unit
   ...
\end{lstlisting}
\vspace{-7pt}
\caption{What effects can $\kwa{someMethod}$ incur?}
\label{fig:cc_motivation}
\end{figure}

What effects will be incurred if $\kwa{Logger.log}$ is invoked? One approach is to examine its source code, but this manual process is tedious and error-prone. In many real-world situations the source code may not be available. A capability-based argument can do better: the only authority which $\kwa{Logger}$ can exercise is that which it has been explicitly given. Here, the $\kwa{Logger}$ can be given a $\kwa{File}$ and a $\kwa{Socket}$, so $\kwa{ \{ \kwa{File.*, Socket.*} \} }$ is an upper bound on the effects of $\kwa{Logger}$. Knowing $\kwa{Logger}$ could be manipulating sockets, a developer may decide this implementation cannot be trusted and choose not to use it.

The reasoning we employed only required us to examine the interface of the unannotated code for the capabilities that passed into it. To model this situation in $\epscalc$, we add a new $\kwa{import}$ expression selecting what effects $\varepsilon$ the unannotated code may exercise. The static rules can check if the capabilities being imported violate $\varepsilon$. If the rules accept the code, then $\varepsilon$ is a safe approximation of the unannotated code's effects; that capability-safe design enables this inference is the key result. The rest of this chapter is devoted to formalising the idea and proving it sound.

\subsection{$\epscalc$ Grammar}

The grammar of $\epscalc$ is split into rules for annotated code and analogous rules for unannotated code. To distinguish the two, we put a hat above annotated types, expressions, and contexts: $\hat e$, $\hat \tau$, and $\hat \Gamma$ are annotated, while $e$, $\tau$, and $\Gamma$ are unannotated. The rules for unannotated programs and their types are given in Figure \ref{fig:epscalc_unannotated_grammar}.

\begin{figure}[h]
\vspace{-5pt}

\[
\begin{array}{lll}

\begin{array}{lllr}
e & ::= & ~ & exprs: \\
	& | & x & variable \\
	& | & v & value \\
	& | & e ~ e & application \\
	& | & e.\pi & operation \\
	&&\\

v & ::= & ~ & values: \\
	& | & r & resource~literal \\
	& | & \lambda x: \tau.e & abstraction \\
	&&\\
\end{array}

\begin{array}{lllr}

\tau & ::= & ~ & types: \\
		& | & \{ \bar r \} \\
		& | & \tau \rightarrow \tau \\ 
		&&\\

\Gamma & ::= & ~ & type~ctx: \\
				& | & \varnothing \\
				& | & \Gamma, x: \tau \\
				&&\\
				
\end{array}

\end{array}
\]

\vspace{-7pt}
\caption{Effect calculus.}
\label{fig:epscalc_unannotated_grammar}
\end{figure}

The rules are much the same as in $\opercalc$, but the sole type-constructor $\rightarrow$ is not annotated with a set of effects. If an expression $e$ is associated with the type $\tau_1 \rightarrow \tau_2$, it means $e$ is a function which, when given a $\tau_1$, will return a $\tau_2$. This type says nothing about what effects may or may not be incurred by $e$. Unannotated types $\tau$ are built using $\rightarrow$ and sets of resources $\{ \bar r \}$. An unannotated context $\Gamma$ maps variables to unannotated types.

Rules for annotated programs and their types are given in Figure \ref{fig:epscalc_annotated_grammar}. Except for the new $\kwa{import}$ expression, the rules are the same as in $\opercalc$. Annotated types $\hat \tau$ are built using the type constructor $\rightarrow_{\varepsilon}$ and sets of resources $\{ \bar r \}$. An annotated context $\hat \Gamma$ maps variables to annotated types.

\begin{figure}[h]
\vspace{-5pt}

\[
\begin{array}{lll}

\begin{array}{lllr}

\hat e & ::= & ~ & labelled~exprs: \\
	& | & x \\
	& | & \hat v \\
	& | & \hat e ~ \hat e \\
	& | & \hat e.\pi \\
	& | & \kwa{import}(\varepsilon)~x = \hat e~\kwa{in}~e & import \\
	&&\\

\hat v & ::= & ~ & labelled~values: \\
	& | & r \\
	& | & \lambda x: \hat \tau.\hat e \\
	&&\\

\end{array}

& ~~~~~~~~&

\begin{array}{lllr}

\hat \tau & ::= & ~ & labelled ~types: \\
		& | & \{ \bar r \} \\
		& | & \hat \tau \rightarrow_{\varepsilon} \hat \tau \\
		&&\\

\hat \Gamma & ::= & ~ & labelled~type~ctx:\\
				& | & \varnothing \\
				& | & \hat \Gamma, x: \hat \tau \\
				&&\\

\end{array}

\end{array}
\]

\vspace{-7pt}
\caption{Effect calculus.}
\label{fig:epscalc_annotated_grammar}
\end{figure}

The new form $\kwa{import}$ introduces a name $x$ with annotated definition $\hat e$ into a body of unannotated code $e$. This should be understood as $e$ importing the capability $\hat e$. $\varepsilon$ is the authority which $e$ is allowed to exercise, so any resources and operation calls used in $e$ must be declared in $\varepsilon$. $\kwa{import}$ is the only way to nest unannotated code inside annotated code. It is not possible to nest annotated code inside unannotated code, because of the general difficulty of reasoning about what the unannotated code may do. We will not be interested in unannotated programs, unless they appear inside an $\kwa{import}$ expression.

\subsection{$\epscalc$ Dynamic Rules}

Different approaches might be taken to define the small-step semantics of $\epscalc$: one is to define reductions for both annotated and unannotated programs, but this clutters the formalism with irrelevant, uninteresting rules; another is to define reductions for either of the two, and translate programs into the appropriate form before executing them. Because our static rules focus on what can be said about unannotated code nested inside annotated code, we take this second approach: reductions are defined on annotated forms, and unannotated forms nested inside annotated code are transformed at runtime.

Excluding $\kwa{import}$, the annotated sublanguage of $\epscalc$ is the same as $\opercalc$, so we take the reduction rules of $\opercalc$ as also being reduction rules in $\epscalc$. For brevity, they are not restated. The new rules in $\epscalc$ are for reducing $\kwa{import}$ expressions. The idea is that when a piece of unannotated code $e$ is encountered inside annotated code, the surrounding $\kwa{import}$ will select its authority $\varepsilon$, so we can annotate $e$ with $\varepsilon$ to wrangle it into a form that can be further reduced by the rules from $\opercalc$. To this end, we define $\annot{e}{\varepsilon}$ in Figure \ref{fig:annot_defn}, which recursively annotates the parts of $e$ with $\varepsilon$. There are versions of $\kwa{annot}$ defined for expressions and types. We need to annotate contexts later, so the definition is given here.

\begin{figure}[h]
\vspace{-5pt}

$\bm{\kwa{annot :: e \times \varepsilon \rightarrow \hat e}}$

\begin{itemize}
	\setlength\itemsep{-0.7em}
	\item[] $\annot{r}{\_} = r$
	\item[] $\annot{\lambda x: \tau_1 . e}{\varepsilon} = \lambda x: \annot{\tau_1}{\varepsilon} . \annot{e}{\varepsilon}$
	\item[] $\annot{e_1~e_2}{\varepsilon} = \kwa{annot}(e_1, \varepsilon)~\kwa{annot}(e_2, \varepsilon)$
	\item[] $\annot{e_1.\pi}{\varepsilon} = \annot{e_1}{\varepsilon}.\pi$
\end{itemize}
	
$\bm{\kwa{annot :: \tau \times \varepsilon \rightarrow \hat \tau}}$

\begin{itemize}
	\setlength\itemsep{-0.7em}
	\item[] $\annot{\{ \bar r \}}{\_} = \{ \bar r \}$
	\item[] $\annot{\tau \rightarrow \tau}{\varepsilon} = \tau \rightarrow_{\varepsilon} \tau$.	
\end{itemize}

$\bm{\kwa{annot :: \Gamma \times \varepsilon \rightarrow \hat \Gamma}}$

\begin{itemize}
	\setlength\itemsep{-0.7em}
	\item[] $\annot{\varnothing}{\_} = \varnothing$
	\item[] $\annot{\Gamma, x: \tau}{\varepsilon} = \annot{\Gamma}{\varepsilon}, x: \annot{\tau}{\varepsilon}$
\end{itemize}

\vspace{-7pt}
\caption{Definition of $\kwa{annot}$.}
\label{fig:annot_defn}
\end{figure}

It is worth mentioning that $\kwa{annot}$ operates on a purely syntatic level. Nothing in the definition will stop you annotating a program with something silly, so any use of $\kwa{annot}$ must be justified.

Finally, before giving the dynamic rules we must update the definition of $\kwa{substitution}$. Because our dynamic rules are defined on annotated programs, so too will $\kwa{substitution}$ be defined. Except for the new case for $\kwa{import}$ expressions given in Figure \ref{fig:epscalc_sub_defn}, the definition is the same from $\opercalc$. We still stipulate that variables can only be replaced with values, to prevent the introduction of arbitrary effects.

\begin{figure}[h]

\bm{$\kwa{substitution :: \hat e \times \hat v \times \hat v \rightarrow \hat e}$}

\begin{itemize}
	\setlength\itemsep{-0.7em}
	\item[] $[\hat v/y](\import{\varepsilon}{x}{\hat e}{e}) = \import{\varepsilon}{x}{[\hat v/y]\hat e}{e}$
\end{itemize}

\vspace{-7pt}
\caption{New case for $\kwa{substitution}$ in $\epscalc$.}
\label{fig:epscalc_sub_defn}
\end{figure}

The new single-step reductions on $\kwa{import}$ expressions are given in \ref{fig:opercalc_reductions}. \textsc{E-Import1} reduces the definition of the capability being imported. If the capability being imported is a value $\hat v$, then \textsc{E-Import2} annotates $e$ with the authority $\varepsilon$; this is $\annot{e}{\varepsilon}$. The name of the capability $x$ is then replaced with its definition; this is $[\hat v/x]\annot{e}{\varepsilon}$. The single-step incurs no effects.


\begin{figure}[h]

\noindent
\fbox{$\hat e \longrightarrow \hat e~|~\varepsilon$}

\[
\begin{array}{c}
\infer[\textsc{(E-Import1)}]
	{\kwa{import}(\varepsilon)~x = \hat e~\kw{in} e \longrightarrow \kwa{import}(\varepsilon)~x = \hat e'~\kw{in} e~|~\varepsilon'}
	{\hat e \longrightarrow \hat e'~|~\varepsilon'}\\[4ex]

\infer[\textsc{(E-Import2)}]
	{\kwa{import}(\varepsilon)~x = \hat v~\kw{in} e \longrightarrow [\hat v/x]\kwa{annot}(e, \varepsilon)~|~\varnothing}
	{}

\end{array}
\]


\vspace{-7pt}
\caption{New single-step reductions in $\epscalc$.}
\label{fig:opercalc_reductions}
\end{figure}

Multi-step reductions in $\epscalc$ are defined the same as in $\opercalc$. For brevity, they are not restated.

















\subsection{$\epscalc$ Static Rules}

Since a term might be annotated or unannotated, we need to be able to recognise when either is well-typed. We do not reason about the effects of unannotated code directly, so judgements about them take the form $\Gamma \vdash e: \tau$. The subtyping judgement for unannotated code takes the form $\tau <: \tau$. A summary of these typing and subtyping rules is given in \ref{fig:unannotated_static_rules}; each is analogous to some rule in $\opercalc$, but the parts relating to effects have been removed.

\begin{figure}[h]

\fbox{$\Gamma \vdash e: \tau$}

\[
\begin{array}{c}


\infer[\textsc{(T-Var)}]
	{\Gamma, x: \tau \vdash x: \tau}
	{}
~~~~~~
\infer[\textsc{(T-Resource)}]
	{\Gamma, r: \{ r \} \vdash r : \{ r \}}
	{}

~~~~~~
\infer[\textsc{(T-Abs)}]
	{\Gamma \vdash \lambda x: \tau_1.e : \tau_1 \rightarrow \tau_2}
	{\Gamma, x: \tau_1 \vdash e: \tau_2}\\[4ex]
	
\infer[\textsc{(T-App)}]
	{\Gamma \vdash e_1~e_2: \tau_3}
	{\Gamma \vdash e_1: \tau_2 \rightarrow \tau_3 & \Gamma \vdash e_2: \tau_2}
~~~~~~
\infer[\textsc{(T-OperCall)}]
	{\Gamma \vdash e.\pi: \kwa{Unit}}
	{\Gamma \vdash e: \{ \bar r \}}

\end{array}
\]



\fbox{$\tau <: \tau$}

\[
\begin{array}{c}

\infer[\textsc{(S-Arrow)}]
	{ \tau_1 \rightarrow \tau_2 <: \tau_1' \rightarrow \tau_2' }
	{ \tau_1' <: \tau_1 & \tau_2 <: \tau_2' }
	~~~
\infer[\textsc{(S-Resources)}]
	{ \{ \bar r_1 \} <: \{ \bar r_2 \} }
	{ \{ \bar r_1 \} \subseteq \{ \bar r_2 \} }

\end{array}
\]

\vspace{-7pt}
\caption{(Sub)typing judgements for the unannotated sublanguage of $\epscalc$}
\label{fig:unannotated_static_rules}
\end{figure}

Since the annotated subset of $\epscalc$ contains $\opercalc$, all the $\opercalc$ rules apply, but now we put hats on everything to signify that a typing judgement is being made about annotated code inside an annotated context. This looks like $\hat \Gamma \vdash \hat e: \hat \tau~\kw{with} \varepsilon$. Except for notation the judgements are the same, so we shall not repeat them. The only new rule is \textsc{$\varepsilon$-Import}, which gives the type and approximate effects of an $\kwa{import}$ expression. This is the only way to reason about what effects might be incurred by some unannotated code. The rule is complicated, so we start with a simple version and spend the rest of the section building up to the final version of \textsc{$\varepsilon$-Import}.

To begin, typing $\import{\varepsilon}{x}{\hat v}{e}$ in a context $\hat \Gamma$ requires us to know that the imported capability $\hat e$ is well-typed, so we add the premise $\hat \Gamma \vdash \hat e: \hat \tau~\kw{with} \varepsilon_1$. Since $x = \hat e$ is an import, it can be used throughout $e$. However, we do not want $e$ to exercise ambient authority beyond that which has been explicitly selected, so whatever capabilities are used must be selected by the $\kwa{import}$ expression; therefore, we require that $e$ can be typechecked using only the binding $x: \hat \tau$. There is a problem though: $e$ is unannotated and $\hat \tau$ is annotated, and there is no rule for typechecking unannotated code in an annotated context. To get around this, we define a function $\kwa{erase}$ in Figure \ref{fig:erase_defn} which removes the annotations from a type. We then add $x: \erase{\hat \tau} \vdash e: \tau$ as a premise.

\begin{figure}[h]
\vspace{-5pt}

$\bm{\kwa{erase :: \hat \tau \rightarrow \tau}}$
\begin{itemize}
	\setlength\itemsep{-0.7em}
	\item[] $\erase{\{ \bar r \}}$
	\item[] $\erase{\hat \tau_1 \rightarrow_{\varepsilon} \hat \tau_2} = \erase{\hat \tau_1} \rightarrow \erase{\hat \tau_2}$
\end{itemize}


\vspace{-7pt}
\caption{Definitions of $\kwa{annot}$ and $\kwa{erase}$.}
\label{fig:erase_defn}
\end{figure}

Since $\import{\varepsilon}{x}{\hat v}{e} \longrightarrow [\hat v/x]\annot{e}{\varepsilon}$ by \textsc{E-Import2}, it is sensible that the ascribed type would be $\annot{\tau}{\varepsilon}$: the type of the unannotated code, annotated with its selected authority $\varepsilon$. The approximate effects are $\varepsilon_1 \cup \varepsilon$; the former comes from reducing the imported capability --- which happens before the (annotated) body of the $\kwa{import}$ is executed --- and the latter contains all the effects which the unannotated code is allowed to incur. The first version of \textsc{$\varepsilon$-Import} is given in Figure \ref{fig:import_rule_1}.


\begin{figure}[h]

\fbox{$\tau <: \tau$}

\[
\begin{array}{c}

\infer[\textsc{($\varepsilon$-Import1)}]
	{ \hat \Gamma \vdash \import{\varepsilon}{x}{\hat e}{e}: \kwa{annot}(\tau, \varepsilon)~\kw{with} \varepsilon \cup \varepsilon_1 }
	{ \hat \Gamma \vdash \hat e: \hat \tau~\kw{with} \varepsilon_1 & x: \kwa{erase}(\hat \tau) \vdash e: \tau }

\end{array}
\]
\vspace{-7pt}
\caption{A first rule for type-and-effect checking $\kwa{import}$ expressions.}
\label{fig:import_rule_1}
\end{figure}

At the moment there is no relation between $\varepsilon$ --- the effects which $e$ is allowed to incur --- and those effects captured by the imported capability. Consider $\hat e' = \import{\varnothing}{x}{\File}{\kwa{x.write}}$, which imports a $\File$ and writes to it, but declares its authority as $\varnothing$. According to \textsc{$\varepsilon$-Import1}, $\vdash \hat e': \Unit~\kw{with} \varnothing$, but this is clearly wrong since $\hat e'$ writes to $\kwa{File}$. We need to constrain the imported capability to only capture effects in $\varepsilon$. To this end we define a function $\kwa{effects}$, which collects the set of effects that an annotated type captures. A first definition is given in Figure \ref{fig:fx_defn}. We can then add the premise $\kwa{effects}(\hat \tau) \subseteq \varepsilon$ to require that any imported capability must not capture authority beyond that selected in $\varepsilon$. The updated rule is given in Figure \ref{fig:import_rule_2}.

\begin{figure}[h]

$\bm{\kwa{effects :: \hat \tau \rightarrow \varepsilon}}$ \begin{itemize}
	\setlength\itemsep{-0.7em}
	\item[] $\fx{\{ \bar r \}} = \{ r.\pi \mid r \in \bar r, \pi \in \Pi \}$
	\item[] $\fx{\hat \tau_1 \rightarrow_{\varepsilon} \hat \tau_2} = \fx{\hat \tau_1} \cup \varepsilon \cup \fx{\hat \tau_2}$
\end{itemize}
\vspace{-7pt}
\caption{A first definition of $\kwa{effects}$.}
\label{fig:fx_defn}
\end{figure}

\begin{figure}[h]

\[
\begin{array}{c}

\infer[\textsc{($\varepsilon$-Import2)}]
	{ \hat \Gamma \vdash \import{\varepsilon}{x}{\hat e}{e}: \kwa{annot}(\tau, \varepsilon)~\kw{with} \varepsilon \cup \varepsilon_1 }
	{ \hat \Gamma \vdash \hat e: \hat \tau~\kw{with} \varepsilon_1 & x: \kwa{erase}(\hat \tau) \vdash e: \tau & \kwa{effects}(\hat \tau) \subseteq \varepsilon}

\end{array}
\]
\vspace{-7pt}
\caption{A second rule for type-and-effect checking $\kwa{import}$ expressions.}
\label{fig:import_rule_2}
\end{figure}

The counterexample which defeated \textsc{$\varepsilon$-Import1} is now rejected by \textsc{$\varepsilon$-Import2}, but there are still issues: the annotations on one import can be broken by another import. To illustrate, consider Figure \ref{fig:rule_import2_counterexample} where two\footnote{Our formalisation only permits a single capability to be imported, but this discussion leads to a generalisation needed for the rules be safe when multiple imports are allowed.} capabilities are imported. This program imports a function $\kwa{go}$ which, when given a $\Unit \rightarrow_{\varnothing} \Unit$ function with no effects, will execute it. The other import is $\kwa{File}$. The unannotated code creates a $\Unit \rightarrow \Unit$ function which writes to $\kwa{File}$ and passes it to $\kwa{go}$, which subsequently incurs $\kwa{File.write}$.

\begin{figure}[h]

\begin{lstlisting}
import({File.*})
   go = $\lambda$x: Unit $\rightarrow_{\varnothing}$ Unit. x unit
   f = File
in
   go ($\lambda$y: Unit. f.write)

\end{lstlisting}

\vspace{-7pt}
\caption{Permitting multiple imports will break \textsc{$\varepsilon$-Import2}.}
\label{fig:rule_import2_counterexample}
\end{figure}

In the world of annotated code it is not possible to pass a file-writing function to $\kwa{go}$, but because the judgement $x: \erase{\hat \tau} \vdash e: \tau$ discards the annotations on $\kwa{go}$, and since the file-writing function has type $\unit \rightarrow \unit$, the unannotated world accepts it as well-typed. The $\kwa{import}$ selects $\{ \kwa{File.*} \}$ as its authority, so the approximation is actually safe at the top-level, but it contains code that violates the type signature of $\kwa{go}$. We want to prevent this.

If $\kwa{go}$ had the type $\Unit \rightarrow_{\{ \kwa{File.write} \}} \Unit$ the above example would be safe, but a modified version where a file-reading function is passed to $\kwa{go}$ would have the same issue. $\kwa{go}$ is only safe when it expects every effect that the unannotated code might incur; if $\kwa{go}$ had the type $\Unit \rightarrow_{\{ \kwa{File.*} \}} \Unit$, then the unannotated code cannot pass it a capability with an effect it isn't already expecting, so the annotation on $\kwa{go}$ cannot be violated. Therefore we require imported capabilities to have authority to incur the effects in $\varepsilon$.

To achieve greater control in how we say this, the definition of $\kwa{effects}$ is split into two separate functions called $\kwa{effects}$ and $\kwa{ho \hyphen effects}$. If values of $\hat \tau$ possess a capability that can be used to incur the effect $r.\pi$, then $r.\pi \in \fx{\hat \tau}$. If values of $\hat \tau$ can incur an effect $r.\pi$, but need to be given the capability by someone else in order to do that, then $r.\pi \in \hofx{\hat \tau}$.


\begin{figure}[h]

$\bm{\kwa{effects :: \hat \tau \rightarrow \varepsilon}}$ \begin{itemize}
	\setlength\itemsep{-0.7em}
	\item[] $\fx{\{ \bar r \}} = \{ r.\pi \mid r \in \bar r, \pi \in \Pi \}$
	\item[] $\fx{\hat \tau_1 \rightarrow_{\varepsilon} \hat \tau_2} = \hofx{\hat \tau_1} \cup \varepsilon \cup \fx{\hat \tau_2}$
\end{itemize}

$\bm{\kwa{ho \hyphen effects} :: \hat \tau \rightarrow \varepsilon}$ \begin{itemize}
	\setlength\itemsep{-0.7em}
	\item[] $\hofx{\{ \bar r \}} = \varnothing$
	\item[] $\hofx{\hat \tau_1 \rightarrow_{\varepsilon} \hat \tau_2} = \fx{\hat \tau_1} \cup \hofx{\hat \tau_2}$
\end{itemize}

\vspace{-7pt}
\caption{Effect functions.}
\label{fig:fx_defns}
\end{figure}

$\kwa{effects}$ and $\kwa{ho \hyphen effects}$ are mutually recursive, with base cases for resource types. Any effect can be directly incurred by a resource on itself, hence $\fx{\{ \bar r \}} = \{ r.\pi \mid r \in \bar r, \pi \in \Pi \}$. A resource cannot be used to indirectly invoke some other effect, so $\hofx{\{ \bar r \}} = \varnothing$. The mutual recursion echoes the subtyping rule for functions. Recall that functions are contravariant in their input type and covariant in their output type. Similarly, both functions recurse on the input-type using the other function, and recurse on the output-type using the same function.

In light of these new definitions, we still require $\fx{\hat \tau} \subseteq \varepsilon$ --- unannotated code must select any effect its capabilities can incur --- but we add a new premise $\varepsilon \subseteq \hofx{\hat \tau}$, stipulating that imported capabilities must select every effect they could be given by unannotated code. The counterexample from Figure \ref{fig:rule_import2_counterexample} is now rejected, because $\hofx{\Unit \rightarrow_{\varnothing} \Unit) \rightarrow_{\varnothing} \Unit} = \varnothing$, but $\{ \kwa{File.*} \} \not\subseteq \varnothing$. But this is \textit{still} not sufficient! Consider $\varepsilon \subseteq \hofx{ \hat \tau_1 \rightarrow_{\varepsilon'} \hat \tau_2 }$. We want \textit{every} higher-order capability involved to be expecting $\varepsilon$. Expanding the definition, $\varepsilon \subseteq \fx{\hat \tau_1} \cup \hofx{\hat \tau_2}$. Let $r.\pi \in \varepsilon$ and suppose $r.\pi \in \fx{\hat \tau_1}$, but $r.\pi \notin \hofx{\hat \tau_2}$. Then $\varepsilon \subseteq \fx{\hat \tau_1} \cup \hofx{\hat \tau_2}$ is still true, but $\hat \tau_2$ is not expecting $r.\pi$. Unannotated code could then violate the annotations on $\hat \tau_2$ by causing it to invoke $r.\pi$, using the same trickery from before. The cause of the issue is that $\subseteq$ does not distribute over $\rightarrow_{\varepsilon'}$. We want a relation like $\varepsilon \subseteq \fx{\hat \tau_1} \cup \hofx{\hat \tau_2}$, but where $\subseteq$ distributes over the input and output type. Figure \ref{fig:safe_defns} defines exactly this: $\kwa{safe}$ is a distributive version of $\varepsilon \subseteq \fx{\hat \tau}$ and $\kwa{ho \hyphen safe}$ is a distributive version of $\varepsilon \subseteq \hofx{\hat \tau}$.


\begin{figure}[h]

\noindent
$\fbox{$\kwa{safe(\hat \tau, \varepsilon)}$}$

\[
\begin{array}{c}

\infer[\textsc{(Safe-Resource)}]
	{}
	{ \{ r.\pi \mid r \in \bar r, \pi \in \Pi \} \subseteq \varepsilon } \\[3ex]

\infer[\textsc{(Safe-Arrow)}]
	{\kwa{safe}(\hat \tau_1 \rightarrow_{\varepsilon'} \hat \tau_2, \varepsilon)}
	{\varepsilon \subseteq \varepsilon' & \kwa{ho \hyphen safe}(\hat \tau_1, \varepsilon) & \kwa{safe}(\hat \tau_2, \varepsilon)} \\[3ex]

\end{array}
\]

\noindent
$\fbox{$\kwa{ho \hyphen safe(\hat \tau, \varepsilon)}$}$

\[
\begin{array}{c}

\infer[\textsc{(HOSafe-Resource)}]
	{ \kwa{ho \hyphen safe}( \{ \bar r \}, \varepsilon)} 
	{} \\[3ex]

\infer[\textsc{(HOSafe-Arrow)}]
	{ \kwa{ho \hyphen safe}( \hat \tau_1 \rightarrow_{\varepsilon'} \hat \tau_2, \varepsilon ) }
	{ \kwa{safe}(\hat \tau_1, \varepsilon)  & \kwa{ho \hyphen safe}(\hat \tau_2, \varepsilon) }\\[3ex]

\end{array}
\]

\vspace{-7pt}
\caption{Safety judgements in the epsilon calculus.}
\label{fig:safe_defns}
\end{figure}

Note again how the mutual recursion of $\kwa{safe}$ and $\kwa{ho \hyphen safe}$ mimics the co(ntra)variance rules for function subtyping. Some properties are also immediate: $\safe{\hat \tau}{\varepsilon}$ implies $\varepsilon \subseteq \fx{\hat \tau}$ and $\hosafe{\hat \tau}{\varepsilon}$ implies $\varepsilon \subseteq \hofx{\hat \tau}$, but the converses are not true, because the safety predicates are distributive and therefore stronger.

An amended version of \textsc{$\varepsilon$-Import} is given in Figure \ref{fig:import_rule3}. It contains a new premise $\hosafe{\hat \tau}{\varepsilon}$ which formalises the notion that every capability which could given to a value of $\hat \tau$ --- or any of its constituent pieces --- must be expecting the effects in $\varepsilon$ that the unannotated code might pass to it..

\begin{figure}[h]

\noindent
\fbox{$\hat \Gamma \vdash \hat e: \hat \tau~\kw{with} \varepsilon$}

\[
\begin{array}{c}

\infer[\textsc{($\varepsilon$-Import3)}]
	{ \hat \Gamma \vdash \kwa{import}(\varepsilon)~x = \hat e~\kw{in} e: \kwa{annot}(\tau, \varepsilon)~\kw{with} \varepsilon \cup \varepsilon_1 }
{{\def\arraystretch{1.4}
  \begin{array}{c}
\hat \Gamma \vdash \hat e: \hat \tau~\kw{with} \varepsilon_1
~~~~~~
\kwa{effects}(\hat \tau) \subseteq \varepsilon \\
\hosafe{\hat \tau}{\varepsilon} ~~~~~~ x: \kwa{erase}(\hat \tau) \vdash e: \tau
  \end{array}}} 
 
\end{array}
\]

\vspace{-7pt}
\caption{A third rule for type-and-effect checking $\kwa{import}$ expressions.}
\label{fig:import_rule3}
\end{figure}

The premises so far restrict what authority can be selected by unannotated code, but what about authority passed as a function argument? Consider $\hat e = \import{\varnothing}{x}{\unit}{\kwa{\lambda f: { File }.~f.write}}$. The unannotated code selects no capabilities and returns a function which, when given $\kwa{File}$, incurs $\kwa{File.write}$. This satisfies the premises in \textsc{$\varepsilon$-Import}, but its annotated type is \textsc{$\varepsilon$-Import} is $\{ \File \} \rightarrow_{\varnothing} \Unit$ --- not good!

Suppose the unannotated code defines a function $f$, which gets annotated with $\varepsilon$ to produce $\annot{f}{\varepsilon}$. Suppose $\annot{f}{\varepsilon}$ is invoked at a later point and incurs the effect $r.\pi$. What is the source of $r.\pi$? If $r.\pi$ was selected by the $\kwa{import}$ expression surrounding $f$, it is safe for $\annot{f}{\varepsilon}$ to incur this effect. Otherwise, $\annot{f}{\varepsilon}$ may have been passed an argument which can be used to incur $r.\pi$, in which case $r.\pi$ is a higher-order effect of $\annot{f}{\varepsilon}$. If the argument is a function, then by the soundness of $\opercalc$, it must be that $r.\pi \in \varepsilon$, or it will not typecheck. If the argument is a resource $r$ then $\annot{f}{\varepsilon}$ may exercise $r.\pi$, which our rule does not yet account for.



We want $\varepsilon$ to contain every effect captured by resources passed into $\annot{f}{\varepsilon}$ as arguments. We can do this by inspecting its (unannotated type) for resource sets. For example, if the unannotated code has the type $\kwa{ \{ File \} \rightarrow \Unit}$, then we need $\kwa{ \{ File.* \} }$ in $\varepsilon$. To do this, we add a new premise $\hofx{\annot{\tau}{\varnothing}} \subseteq \varepsilon$. $\kwa{hofx}$ is only defined on annotated types, so we first annotate $\tau$ with $\varnothing$. We are only inspecting the resources passed into $f$ as an argument, so the annotations on the arrow should be ignored -- annotating $\tau$ with $\varnothing$ is therefore a good choice.

We can now handle the example from before: $\import{\varnothing}{x}{\unit}{\kwa{\lambda f: { File }.~f.write}}$. The unannotated code types via the judgement $\kwa{x: Unit \vdash \lambda f: { File }.~f.write: \{ File \} \rightarrow Unit}$. Its higher-order effects are $\hofx{\annot{ \{ \File \} \rightarrow \Unit}{\varnothing}} = \{ \kwa{File.*} \}$, but $\{ \kwa{File.*} \} \not\subseteq \varnothing$, so the example safely rejects.

The final version of \textsc{$\varepsilon$-Import} is given in Figure \ref{fig:import_rule}.

\begin{figure}[h]

\noindent
\fbox{$\hat \Gamma \vdash \hat e: \hat \tau~\kw{with} \varepsilon$}

\[
\begin{array}{c}

\infer[\textsc{($\varepsilon$-Import)}]
	{ \hat \Gamma \vdash \kwa{import}(\varepsilon)~x = \hat e~\kw{in} e: \kwa{annot}(\tau, \varepsilon)~\kw{with} \varepsilon \cup \varepsilon_1 }
{{\def\arraystretch{1.4}
  \begin{array}{c}
\kwa{effects}(\hat \tau) \cup \hofx{\annot{\tau}{\varnothing}}\subseteq \varepsilon \\
\hat \Gamma \vdash \hat e: \hat \tau~\kw{with} \varepsilon_1 ~~~~~~ \kwa{ho \hyphen safe}(\hat \tau, \varepsilon) ~~~~~~ x: \kwa{erase}(\hat \tau) \vdash e: \tau
  \end{array}}} 
 
\end{array}
\]


\vspace{-7pt}
\caption{The final rule for typing imports.}
\label{fig:import_rule}
\end{figure}

We can now model the example from the beginning of Section 3.2., where the $\kwa{Logger}$ implementation selects the capabilities $\kwa{File}$ and $\kwa{Socket}$ and exposes an unannotated function $\kwa{log}$ with type $\Unit \rightarrow \Unit$. \textsc{$\varepsilon$-Import} would annotate $\kwa{log}$ so it has the type $\Unit \rightarrow_{ \{ \kwa{File.*, Socket.*} \} } \Unit$. If an annotated $\kwa{Client}$ only expects the $\kwa{File.append}$ effect, the $\opercalc$ rules will reject any attempt to give $\kwa{Logger}$ to $\kwa{Client}$ because $\kwa{ \{ File.*, Socket.* \} }$ exceeds $ \kwa{ \{File.append  \}}$. More detailed examples are given in Chapter 4.

\subsection{$\epscalc$ Soundness}

Only annotated programs can be reduced and have their effects approximated, so the statement of soundness only applies to them. The theorem statement is given below.

\begin{theorem}[$\epscalc$ Single-step Soundness]
If $\hat \Gamma \vdash \hat e_A: \hat \tau_A~\kw{with} \varepsilon_A$ and $\hat e_A$ is not a value, then $\hat e_A \longrightarrow \hat e_B~|~\varepsilon$, where $\hat \Gamma \vdash \hat e_B: \hat \tau_B~\kw{with} \varepsilon_B$ and $\hat \tau_B <: \hat \tau_A$ and $\varepsilon_B \cup \varepsilon \subseteq \varepsilon_A$, for some $\hat e_B, \varepsilon, \hat \tau_B, \varepsilon_B$.
\end{theorem}

From here onwards we adopt a different convention to avoid name clashes. The selected authority of an $\kwa{import}$ is written $\varepsilon_{s}$ (``epsilon select'') and the imported capability is written $\hat e_i$ or $\hat v_i$ (``e import'' and ``v import''), and has type $\tau_i$ and approximate effects $\varepsilon_i$.

The rules of $\opercalc$ are also rules of $\epscalc$, and have been proven sound in Section 3.1.4., so we do not repeat them here. We present the same theorems and lemmas, but only discuss and prove the cases which use new rules from $\epscalc$. Some lemmas are new, so we shall prove all of their cases. We begin with canonical forms, which is unchanged. The substitution lemma gains an extra case, but the proof is routine.

\begin{lemma}[$\epscalc$ Canonical Forms]
Unless the rule used is \textsc{$\varepsilon$-Subsume}, the following are true:
\begin{enumerate}
	\setlength\itemsep{-0.7em}
	\item If $\hat \Gamma \vdash x: \hat \tau~\kw{with} \varepsilon$ then $\varepsilon = \varnothing$.
	\item If $\hat \Gamma \vdash \hat v: \hat \tau~\kw{with} \varepsilon$ then $\varepsilon = \varnothing$.
	\item If $\hat \Gamma \vdash \hat v: \{ \bar r \}~\kw{with} \varepsilon$ then $\hat v = r$ and $\{ \bar r \} = \{ r \}$.
	\item If $\hat \Gamma \vdash \hat v: \hat \tau_1 \rightarrow_{\varepsilon'} \hat \tau_2~\kw{with} \varepsilon$ then $\hat v = \lambda x:\tau. \hat e$.
\end{enumerate}
\end{lemma}

\begin{lemma}[$\epscalc$ Substitution]
If $\hat \Gamma, x: \hat \tau' \vdash \hat e: \hat \tau~\kw{with} \varepsilon$ and $\hat \Gamma \vdash \hat v: \hat \tau'~\kw{with} \varnothing$ then $\hat \Gamma \vdash [\hat v/x]\hat e: \hat \tau~\kw{with} \varepsilon$.
\end{lemma}

\begin{proof} By induction on the derivation of $\hat \Gamma, x: \hat \tau' \vdash \hat e: \hat \tau~\kw{with} \varepsilon$.\\

\textit{Case:} \textsc{$\varepsilon$-Import}. By definition, $[\hat v/y](\import{\varepsilon_s}{y}{\hat e_i}{e}) = \import{\varepsilon_s}{y}{[\hat v/x] \hat e_i}{e}$. The result follows by applying the inductive assumption to $[\hat v/x] \hat e_i$.
\end{proof}

The progress theorem also has an extra case, and the proof is routine.

\begin{theorem}[$\epscalc$ Progress]
If $\hat \Gamma \vdash \hat e: \hat \tau~\kw{with} \varepsilon$ and $\hat e$ is not a value, then $\hat e \longrightarrow \hat e'~|~\varepsilon$, for some $\hat e', \varepsilon$.
\end{theorem}

\begin{proof} By induction on the derivation of $\hat \Gamma \vdash \hat e: \hat \tau~\kw{with} \varepsilon$.\\

\textit{Case:} \textsc{$\varepsilon$-Import}. Then $\hat e = \import{\varepsilon_s}{x}{\hat e_i}{e}$. If $\hat e_i$ is a non-value then $\hat e$ reduces by \textsc{E-Import1}. Otherwise $\hat e$ reduces by \textsc{E-Import2}.
\end{proof}

The preservation theorem has an extra case for when the typing rule used is \textsc{$\varepsilon$-Import}. This has two subcases, depending on whether the reduction rule used was \textsc{E-Import1} and \textsc{E-Import2}. The former is straightforward to prove, but the latter is tricky; we need several lemmas to do it.

Firstly, since $\varepsilon_s$ is an upper bound on what effects can be incurred by the unannotated code, it should also be an upper bound on what effects can be incurred by the capabilities imported into the unannotated code; therefore, if we take $\hat \tau_i$ and replace its annotations with $\varepsilon_s$, we should get a more general function type $\hat \tau_i <: \annot{\erase{\hat \tau_i}}{\varepsilon}$. This result is given as the pair of lemmas below.

\begin{lemma}[$\epscalc$ Approximation 1]
If $\kwa{effects}(\hat \tau) \subseteq \varepsilon$ and $\kwa{ho \hyphen safe}(\hat \tau, \varepsilon)$ then $\hat \tau <: \kwa{annot}(\kwa{erase}(\hat \tau), \varepsilon)$.
\end{lemma}

\begin{lemma}[$\epscalc$ Approximation 2]
If $\kwa{ho \hyphen effects}(\hat \tau) \subseteq \varepsilon$ and $\safe{\hat \tau}{\varepsilon}$ then $\kwa{annot(erase}(\hat \tau), \varepsilon) <: \hat \tau$.
\end{lemma}

\begin{proof}
By simultaneous induction on derivations of $\hosafe{\hat \tau}{\varepsilon}$ and $\safe{\hat \tau}{\varepsilon}$.
\end{proof}

Recall that function types are contravariant in their input, so the subtyping and subsetting relations flip direction when considering the input type of a function. This is why there are two lemmas: one for each direction.

Now, if \textsc{E-Import2} is applied, the reduction has the form $\import{\varepsilon_{s}}{x}{\hat v_i}{e} \longrightarrow [\hat v_i/x]\annot{e}{\varepsilon_s}~|~\varnothing$. Since $x: \erase{\hat \tau} \vdash e: \tau$, it is reasonable to expect that (1) $\hat \Gamma \vdash \annot{e}{\varepsilon_s}: \annot{\tau}{\varepsilon_s}~\kw{with} \varepsilon_s$ would be true, because although $\annot{e}{\varepsilon_s}$ has annotations and $e$ does not, annotations do not change runtime semantics --- the two programs have the same structure and capture the same effects. If judgement (1) holds, then $\hat \Gamma \vdash [\hat v_i/x]\annot{e}{\varepsilon_s}: \annot{\tau}{\varepsilon_s}~\kw{with} \varepsilon_s$ by the substitution lemma; that it does hold is the subject of the following lemma.

\begin{lemma}[$\epscalc$ Annotation]
If the following are true:

\begin{enumerate}
	\setlength\itemsep{-0.7em}
	\item $\hat \Gamma \vdash \hat v_i : \hat \tau_i~\kw{with} \varnothing$
	\item $\Gamma, y: \kwa{erase}(\hat \tau_i) \vdash e: \tau$
	\item $\kwa{effects}(\hat \tau_i) \cup \hofx{\annot{\tau}{\varnothing}} \cup \fx{\annot{\Gamma}{\varnothing}} \subseteq \varepsilon_{s}$
	\item $\kwa{ho \hyphen safe}(\hat \tau_i, \varepsilon_s)$
\end{enumerate}

\noindent
Then $\hat \Gamma, \kwa{annot}(\Gamma, \varepsilon_s), y: \hat \tau_i \vdash \kwa{annot}(e, \varepsilon_s) : \kwa{annot}(\tau, \varepsilon_s)~\kw{with} \varepsilon_s$.
\end{lemma}


The premises of the lemma are very specific to the premises of \textsc{$\varepsilon$-Import}, but generalised to accommodate a proof by induction: $e$ is allowed to typecheck with bindings in $\Gamma$, so long as $\Gamma$ does not introduce any resources whose authority is not already in $\varepsilon_s$. We need this $\Gamma$ because some effects \textit{look} ambient in certain sub-scopes of $e$, and we need to keep track of them. For example, $\kwa{f.write}$ exercises ambient authority over whatever resource is bound to $f$, but when enclosed by an appropriate abstraction like $\kwa{\lambda f: {File}.~f.write}$, $f$ is no longer ambient. Proving the lemma requires us to inductively step into the bodies of functions, at which point certain capabilities look ambient and need to be bound in the context --- therefore, we permit $e$ to typecheck in a larger environment $\Gamma$. We stipulate $\fx{\annot{\Gamma}{\varnothing}} \subseteq \varepsilon_s$ so that any effects captured by $\Gamma$ are not ambient. Note that when $\Gamma = \varnothing$ then $\varepsilon' = \varepsilon_s$ and applying the lemma gives the judgement $\hat \Gamma, \kwa{annot}(\Gamma, \varepsilon_s), y: \hat \tau_i \vdash \kwa{annot}(e, \varepsilon_s) : \kwa{annot}(\tau_i, \varepsilon_s)~\kw{with} \varepsilon_s$. This is ultimately the judgement we want, so when we apply the annotation lemma, we choose $\Gamma = \varnothing$.

The proof of the annotation lemma is quite long, but a sketch is given below.

\begin{proof}
By induction on derivations of $\Gamma, y: \kwa{erase}(\hat \tau_i) \vdash e: \tau$.\\

\textit{Case:} \textsc{T-Var}. Then $e = x$. If $x \neq y$ use \textsc{$\varepsilon$-Var} and \textsc{$\varepsilon$-Subsume}. Otherwise $x = y$. Then $y: \erase{\hat \tau_i} \vdash x: \tau$ implies that $\hat \tau_i = \tau$. Apply the approximation lemma and simplify to obtain $\hat \tau_i <: \annot{\tau_i}{\varepsilon_s}$, and then use \textsc{$\varepsilon$-Subsume} to get the result.\\

\textit{Case:} \textsc{T-Resource}. Use \textsc{$\varepsilon$-Resource} and \textsc{$\varepsilon$-Subsume}.\\

\textit{Case:} \textsc{T-Abs}. Use inversion to get a judgement for the body of the function $\Gamma, y: \erase{\hat \tau_i}, x: \tau_2 \vdash e_{body}: \tau_3~\kw{with} \varepsilon_s$. Apply the inductive hypothesis to $e_{body}$ with $\Gamma, x: \tau_2$ as the context in which $e_{body}$ typechecks, noting that the premises are satisfied because $\hofx{\annot{\tau}}{\varnothing} \subseteq \varepsilon_s$ implies $\kwa{fx}(\annot{\tau_2}{\varnothing} \subseteq \varepsilon_s$. Then use \textsc{$\varepsilon$-Abs} and \textsc{$\varepsilon$-Subsume}.	\\

\textsc{Case:} \textsc{T-App}. Apply the inductive assumption to the subexpressions, then use \textsc{$\varepsilon$-App} and simplify.\\

\textsc{Case:} \textsc{T-OperCall}. Apply the inductive hypothesis to the receiver and use \textsc{$\varepsilon$-OperCall}. This gives the approximate effects $\varepsilon_s \cup \{ \bar r.\pi \}$. By considering where the binding is in $\hat \Gamma, \annot{\Gamma}{\varepsilon_s}, y: \hat \tau$, conclude that $\{ \bar r.\pi \} \subseteq \varepsilon_s$.\\

\end{proof}

\noindent


Armed with the annotation lemma, we can now prove the preservation theorem.


\begin{theorem}[$\epscalc$ Preservation]
If $\hat \Gamma \vdash \hat e_A: \hat \tau_A~\kw{with} \varepsilon_A$ and $\hat e_A \longrightarrow \hat e_B~|~\varepsilon$, then $\hat \Gamma \vdash \hat e_B: \hat \tau_B~\kw{with} \varepsilon_B$, where $\hat e_B <: \hat e_A$ and $\varepsilon \cup \varepsilon_B \subseteq \varepsilon_A$, for some $\hat e_B, \varepsilon, \hat \tau_B, \varepsilon_B$.
\end{theorem}

\begin{proof} By induction on $\hat \Gamma \vdash \hat e_A: \hat \tau_A~\kw{with} \varepsilon_A$, and then on $\hat e_A \longrightarrow \hat e_B~|~\varepsilon$. \\

\textit{Case:} \textsc{$\varepsilon$-Import}. Then $e_A = \import{\varepsilon}{x}{\hat e}{e}$. If the reduction rule used was \textsc{E-Import1} then the result follows by applying the inductive hypothesis to $\hat e$.

Otherwise $\hat e$ is a value and the reduction used was \textsc{E-Import2}. The following are true:
\begin{enumerate}
	\setlength\itemsep{-0.7em}
	\item $e_A = \kwa{import}(\varepsilon)~x = \hat v~\kw{in} e$
	\item $\hat \Gamma \vdash e_A: \kwa{annot}(\tau, \varepsilon)~\kw{with} \varepsilon \cup \varepsilon_1$
	\item $\kwa{import}(\varepsilon)~x = \hat v~\kw{in} e \longrightarrow [\hat v/x]\kwa{annot}(e, \varepsilon)~|~\varnothing$
	\item $\hat \Gamma \vdash \hat v: \hat \tau~\kw{with} \varnothing$
	\item $\varepsilon = \kwa{effects}(\hat \tau)$
	\item $\kwa{ho \hyphen safe}(\hat \tau, \varepsilon)$
	\item $x: \kwa{erase}(\hat \tau) \vdash e: \tau$
\end{enumerate}

\noindent
Apply the annotation lemma with $\Gamma = \varnothing$ to get $\hat \Gamma, x: \hat \tau \vdash \kwa{annot}(e, \varepsilon): \kwa{annot}(\tau, \varepsilon)~\kw{with} \varepsilon$. From assumption (4) we know $\hat \Gamma \vdash \hat v: \hat \tau~\kw{with} \varnothing$, so the substitution lemma may be applied, giving $\hat \Gamma \vdash [\hat v/x]\kwa{annot}(e, \varepsilon): \kwa{annot}(\tau, \varepsilon)~\kw{with} \varepsilon$. By canonical forms, $\varepsilon_1 = \varepsilon_C = \varnothing$. Then $\varepsilon_B = \varepsilon = \varepsilon_A \cup \varepsilon_C$. By examination, $\tau_A = \tau_B = \kwa{annot}(\tau, \varepsilon)$.
\end{proof}

From progress and preservation, the single-step and multi-step soundness theorems for $\epscalc$ hold. The proofs are identical to the ones in $\opercalc$.

\begin{theorem}[$\epscalc$ Single-step Soundness]
If $\hat \Gamma \vdash \hat e_A: \hat \tau_A~\kw{with} \varepsilon_A$ and $\hat e_A$ is not a value, then $\hat e_A \longrightarrow \hat e_B~|~\varepsilon$, where $\hat \Gamma \vdash \hat e_B: \hat \tau_B~\kw{with} \varepsilon_B$ and $\hat \tau_B <: \hat \tau_A$ and $\varepsilon_B \cup \varepsilon \subseteq \varepsilon_A$, for some $\hat e_B$, $\varepsilon$, $\hat \tau_B$, and $\varepsilon_B$.
\end{theorem}

\begin{theorem}[$\epscalc$ Multi-step Soundness]
If $\hat \Gamma \vdash \hat e_A: \hat \tau_A~\kw{with} \varepsilon_A$ and $\hat e_A \longrightarrow^{*} e_B~|~\varepsilon$, then $\hat \Gamma \vdash \hat e_B: \hat \tau_B~\kw{with} \varepsilon_B$, where $\hat \tau_B <: \hat \tau_A$ and $\varepsilon_B \cup \varepsilon \subseteq \varepsilon_A$, for some $\hat \tau_B$, $\varepsilon_B$.
\end{theorem}






